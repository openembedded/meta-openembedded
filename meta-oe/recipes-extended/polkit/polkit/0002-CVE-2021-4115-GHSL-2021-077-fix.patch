From c86aea01a06ad4d6c428137e9cfe2f74b1ae7f01 Mon Sep 17 00:00:00 2001
From: Jan Rybar <jrybar@redhat.com>
Date: Mon, 21 Feb 2022 08:29:05 +0000
Subject: [PATCH 2/3] CVE-2021-4115 (GHSL-2021-077) fix

Signed-off-by: Mikko Rapeli <mikko.rapeli@bmw.de>

---
 src/polkit/polkitsystembusname.c | 38 ++++++++++++++++++++++++++++----
 1 file changed, 34 insertions(+), 4 deletions(-)

CVE: CVE-2021-4115
Upstream-Status: Backport [41cb093f554da8772362654a128a84dd8a5542a7]

diff --git a/src/polkit/polkitsystembusname.c b/src/polkit/polkitsystembusname.c
index 8ed1363..2fbf5f1 100644
--- a/src/polkit/polkitsystembusname.c
+++ b/src/polkit/polkitsystembusname.c
@@ -62,6 +62,10 @@ enum
   PROP_NAME,
 };
 
+
+guint8 dbus_call_respond_fails;      // has to be global because of callback
+
+
 static void subject_iface_init (PolkitSubjectIface *subject_iface);
 
 G_DEFINE_TYPE_WITH_CODE (PolkitSystemBusName, polkit_system_bus_name, G_TYPE_OBJECT,
@@ -364,6 +368,7 @@ on_retrieved_unix_uid_pid (GObject              *src,
   if (!v)
     {
       data->caught_error = TRUE;
+      dbus_call_respond_fails += 1;
     }
   else
     {
@@ -405,6 +410,8 @@ polkit_system_bus_name_get_creds_sync (PolkitSystemBusName           *system_bus
   tmp_context = g_main_context_new ();
   g_main_context_push_thread_default (tmp_context);
 
+  dbus_call_respond_fails = 0;
+
   /* Do two async calls as it's basically as fast as one sync call.
    */
   g_dbus_connection_call (connection,
@@ -432,11 +439,34 @@ polkit_system_bus_name_get_creds_sync (PolkitSystemBusName           *system_bus
 			  on_retrieved_unix_uid_pid,
 			  &data);
 
-  while (!((data.retrieved_uid && data.retrieved_pid) || data.caught_error))
-    g_main_context_iteration (tmp_context, TRUE);
+  while (TRUE)
+  {
+    /* If one dbus call returns error, we must wait until the other call
+     * calls _call_finish(), otherwise fd leak is possible.
+     * Resolves: GHSL-2021-077
+    */
 
-  if (data.caught_error)
-    goto out;
+    if ( (dbus_call_respond_fails > 1) )
+    {
+      // we got two faults, we can leave
+      goto out;
+    }
+
+    if ((data.caught_error && (data.retrieved_pid || data.retrieved_uid)))
+    {
+      // we got one fault and the other call finally finished, we can leave
+      goto out;
+    }
+
+    if ( !(data.retrieved_uid && data.retrieved_pid) )
+    {
+      g_main_context_iteration (tmp_context, TRUE);
+    }
+    else
+    {
+      break;
+    }
+  }
 
   if (out_uid)
     *out_uid = data.uid;
-- 
2.20.1

