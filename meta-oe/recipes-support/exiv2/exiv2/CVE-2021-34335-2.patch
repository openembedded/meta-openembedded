From fb3bfc509905b20cbde061ff3ec8be9d8a04e7c3 Mon Sep 17 00:00:00 2001
From: Kevin Backhouse <kevinbackhouse@github.com>
Date: Wed, 30 Jun 2021 11:57:46 +0100
Subject: [PATCH] Defensive coding to avoid 0x80000000/0xFFFFFFFF FPE.

CVE: CVE-2021-34335
Upstream-Status: Backport [https://github.com/Exiv2/exiv2/pull/1750/commits/2d8d44e47b1500030e5b249bffbaf1e80aa74815]
Signed-off-by: Gyorgy Sarvari <skandigraun@gmail.com>
---
 include/exiv2/value.hpp | 6 +++---
 src/tags_int.cpp        | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/include/exiv2/value.hpp b/include/exiv2/value.hpp
index 7ca57f3..f726f8c 100644
--- a/include/exiv2/value.hpp
+++ b/include/exiv2/value.hpp
@@ -1569,7 +1569,7 @@ namespace Exiv2 {
     {
         value_.clear();
         long ts = TypeInfo::typeSize(typeId());
-        if (ts != 0)
+        if (ts > 0)
             if (len % ts != 0) len = (len / ts) * ts;
         for (long i = 0; i < len; i += ts) {
             value_.push_back(getValue<T>(buf + i, byteOrder));
@@ -1653,7 +1653,7 @@ namespace Exiv2 {
     template<>
     inline long ValueType<Rational>::toLong(long n) const
     {
-        ok_ = (value_[n].second != 0 && INT_MIN < value_[n].first && value_[n].first < INT_MAX );
+        ok_ = (value_[n].second > 0 && INT_MIN < value_[n].first && value_[n].first < INT_MAX );
         if (!ok_) return 0;
         return value_[n].first / value_[n].second;
     }
@@ -1661,7 +1661,7 @@ namespace Exiv2 {
     template<>
     inline long ValueType<URational>::toLong(long n) const
     {
-        ok_ = (value_[n].second != 0 && value_[n].first < LARGE_INT);
+        ok_ = (value_[n].second > 0 && value_[n].first < LARGE_INT);
         if (!ok_) return 0;
         return value_[n].first / value_[n].second;
     }
diff --git a/src/tags_int.cpp b/src/tags_int.cpp
index 6f76a87..df05522 100644
--- a/src/tags_int.cpp
+++ b/src/tags_int.cpp
@@ -2228,7 +2228,7 @@ namespace Exiv2 {
     std::ostream& printLong(std::ostream& os, const Value& value, const ExifData*)
     {
         Rational r = value.toRational();
-        if (r.second != 0) return os << static_cast<long>(r.first) / r.second;
+        if (r.second > 0) return os << static_cast<long>(r.first) / r.second;
         return os << "(" << value << ")";
     } // printLong
 
