From 1743c78786aac899134a2b2484d802e6adde3ac4 Mon Sep 17 00:00:00 2001
From: Divyanshu Rathore <Divyanshu.Rathore@bmwtechworks.in>
Date: Tue, 2 Dec 2025 20:41:36 +0530
Subject: [PATCH 17/18] ImageMagick: Add support patch 3 to fix CVE-2023-34151

Upstream-Status: Backport [https://github.com/ImageMagick/ImageMagick/commit/4daec2d748cb2f7540ca0d3f694fb2384b0a5601]

Comment: Refreshed hunk to match latest kirkstone

Signed-off-by: Divyanshu Rathore <Divyanshu.Rathore@bmwtechworks.in>
---
 MagickCore/annotate.c       |  8 ++---
 MagickCore/draw.c           | 60 +++++++++++++++----------------
 MagickCore/effect.c         |  8 ++---
 MagickCore/gem.c            |  2 +-
 MagickCore/geometry.c       | 18 +++++-----
 MagickCore/image-private.h  | 70 +++++++++++++++++++++++++------------
 MagickCore/image.c          | 20 +++++------
 MagickCore/pixel.c          | 36 +++++++++----------
 MagickCore/property.c       |  4 +--
 MagickCore/shear.c          | 22 ++++++------
 MagickCore/transform.c      |  4 +--
 MagickCore/visual-effects.c | 40 ++++++++++-----------
 MagickWand/drawing-wand.c   |  8 ++---
 coders/histogram.c          |  6 ++--
 coders/icon.c               |  1 +
 coders/pcl.c                |  4 +--
 coders/tiff.c               |  4 +--
 coders/txt.c                |  4 +--
 configure                   |  8 ++---
 19 files changed, 177 insertions(+), 150 deletions(-)

diff --git a/MagickCore/annotate.c b/MagickCore/annotate.c
index 14f8d05d8..4be938be5 100644
--- a/MagickCore/annotate.c
+++ b/MagickCore/annotate.c
@@ -1734,8 +1734,8 @@ static MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,
 
           if (status == MagickFalse)
             continue;
-          x_offset=CastDoubleToSSizeT(ceil(point.x-0.5));
-          y_offset=CastDoubleToSSizeT(ceil(point.y+y-0.5));
+          x_offset=CastDoubleToLong(ceil(point.x-0.5));
+          y_offset=CastDoubleToLong(ceil(point.y+y-0.5));
           if ((y_offset < 0) || (y_offset >= (ssize_t) image->rows))
             continue;
           q=(Quantum *) NULL;
@@ -1750,7 +1750,7 @@ static MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,
           n=y*bitmap->bitmap.pitch;
           for (x=0; x < (ssize_t) bitmap->bitmap.width; x++, n++)
           {
-            x_offset=CastDoubleToSSizeT(ceil(point.x+x-0.5));
+            x_offset=CastDoubleToLong(ceil(point.x+x-0.5));
             if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))
               {
                 if (q != (Quantum *) NULL)
@@ -2102,7 +2102,7 @@ static MagickBooleanType RenderPostscript(Image *image,
       crop_info=GetImageBoundingBox(annotate_image,exception);
       crop_info.height=(size_t) ((resolution.y/DefaultResolution)*
         ExpandAffine(&draw_info->affine)*draw_info->pointsize+0.5);
-      crop_info.y=CastDoubleToSSizeT(ceil((resolution.y/DefaultResolution)*
+      crop_info.y=CastDoubleToLong(ceil((resolution.y/DefaultResolution)*
         extent.y/8.0-0.5));
       (void) FormatLocaleString(geometry,MagickPathExtent,
         "%.20gx%.20g%+.20g%+.20g",(double) crop_info.width,(double)
diff --git a/MagickCore/draw.c b/MagickCore/draw.c
index 02df7d231..facea115e 100644
--- a/MagickCore/draw.c
+++ b/MagickCore/draw.c
@@ -1233,8 +1233,8 @@ MagickExport MagickBooleanType DrawAffineImage(Image *image,
   edge.y2=MagickMin(max.y,(double) image->rows-1.0);
   inverse_affine=InverseAffineMatrix(affine);
   GetPixelInfo(image,&zero);
-  start=CastDoubleToSSizeT(ceil(edge.y1-0.5));
-  stop=CastDoubleToSSizeT(floor(edge.y2+0.5));
+  start=CastDoubleToLong(ceil(edge.y1-0.5));
+  stop=CastDoubleToLong(floor(edge.y2+0.5));
   source_view=AcquireVirtualCacheView(source,exception);
   image_view=AcquireAuthenticCacheView(image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
@@ -1267,16 +1267,16 @@ MagickExport MagickBooleanType DrawAffineImage(Image *image,
     inverse_edge=AffineEdge(source,&inverse_affine,(double) y,&edge);
     if (inverse_edge.x2 < inverse_edge.x1)
       continue;
-    q=GetCacheViewAuthenticPixels(image_view,CastDoubleToSSizeT(
-      ceil(inverse_edge.x1-0.5)),y,(size_t) CastDoubleToSSizeT(floor(
+    q=GetCacheViewAuthenticPixels(image_view,CastDoubleToLong(
+      ceil(inverse_edge.x1-0.5)),y,(size_t) CastDoubleToLong(floor(
       inverse_edge.x2+0.5)-ceil(inverse_edge.x1-0.5)+1),1,exception);
     if (q == (Quantum *) NULL)
       continue;
     pixel=zero;
     composite=zero;
     x_offset=0;
-    for (x=CastDoubleToSSizeT(ceil(inverse_edge.x1-0.5));
-         x <= CastDoubleToSSizeT(floor(inverse_edge.x2+0.5)); x++)
+    for (x=CastDoubleToLong(ceil(inverse_edge.x1-0.5));
+         x <= CastDoubleToLong(floor(inverse_edge.x2+0.5)); x++)
     {
       point.x=(double) x*inverse_affine.sx+y*inverse_affine.ry+
         inverse_affine.tx;
@@ -2090,8 +2090,8 @@ MagickExport MagickBooleanType DrawGradientImage(Image *image,
         case UndefinedSpread:
         case PadSpread:
         {
-          if ((x != CastDoubleToSSizeT(ceil(gradient_vector->x1-0.5))) ||
-              (y != CastDoubleToSSizeT(ceil(gradient_vector->y1-0.5))))
+          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||
+              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))
             {
               offset=GetStopColorOffset(gradient,x,y);
               if (gradient->type != RadialGradient)
@@ -2118,8 +2118,8 @@ MagickExport MagickBooleanType DrawGradientImage(Image *image,
         }
         case ReflectSpread:
         {
-          if ((x != CastDoubleToSSizeT(ceil(gradient_vector->x1-0.5))) ||
-              (y != CastDoubleToSSizeT(ceil(gradient_vector->y1-0.5))))
+          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||
+              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))
             {
               offset=GetStopColorOffset(gradient,x,y);
               if (gradient->type != RadialGradient)
@@ -2160,8 +2160,8 @@ MagickExport MagickBooleanType DrawGradientImage(Image *image,
 
           antialias=MagickFalse;
           repeat=0.0;
-          if ((x != CastDoubleToSSizeT(ceil(gradient_vector->x1-0.5))) ||
-              (y != CastDoubleToSSizeT(ceil(gradient_vector->y1-0.5))))
+          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||
+              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))
             {
               offset=GetStopColorOffset(gradient,x,y);
               if (gradient->type == LinearGradient)
@@ -3457,21 +3457,21 @@ static MagickBooleanType RenderMVGContent(Image *image,
                 (void) GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 (void) GetNextToken(q,&q,extent,token);
-                bounds.x=CastDoubleToSSizeT(ceil(GetDrawValue(token,
+                bounds.x=CastDoubleToLong(ceil(GetDrawValue(token,
                   &next_token)-0.5));
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 (void) GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   (void) GetNextToken(q,&q,extent,token);
-                bounds.y=CastDoubleToSSizeT(ceil(GetDrawValue(token,
+                bounds.y=CastDoubleToLong(ceil(GetDrawValue(token,
                   &next_token)-0.5));
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 (void) GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   (void) GetNextToken(q,&q,extent,token);
-                bounds.width=(size_t) CastDoubleToSSizeT(floor(GetDrawValue(
+                bounds.width=(size_t) CastDoubleToLong(floor(GetDrawValue(
                   token,&next_token)+0.5));
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
@@ -3882,28 +3882,28 @@ static MagickBooleanType RenderMVGContent(Image *image,
         if (LocaleCompare("viewbox",keyword) == 0)
           {
             (void) GetNextToken(q,&q,extent,token);
-            graphic_context[n]->viewbox.x=CastDoubleToSSizeT(ceil(
+            graphic_context[n]->viewbox.x=CastDoubleToLong(ceil(
               GetDrawValue(token,&next_token)-0.5));
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             (void) GetNextToken(q,&q,extent,token);
             if (*token == ',')
               (void) GetNextToken(q,&q,extent,token);
-            graphic_context[n]->viewbox.y=CastDoubleToSSizeT(ceil(
+            graphic_context[n]->viewbox.y=CastDoubleToLong(ceil(
               GetDrawValue(token,&next_token)-0.5));
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             (void) GetNextToken(q,&q,extent,token);
             if (*token == ',')
               (void) GetNextToken(q,&q,extent,token);
-            graphic_context[n]->viewbox.width=(size_t) CastDoubleToSSizeT(
+            graphic_context[n]->viewbox.width=(size_t) CastDoubleToLong(
               floor(GetDrawValue(token,&next_token)+0.5));
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             (void) GetNextToken(q,&q,extent,token);
             if (*token == ',')
               (void) GetNextToken(q,&q,extent,token);
-            graphic_context[n]->viewbox.height=(size_t) CastDoubleToSSizeT(
+            graphic_context[n]->viewbox.height=(size_t) CastDoubleToLong(
               floor(GetDrawValue(token,&next_token)+0.5));
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
@@ -5017,8 +5017,8 @@ static MagickBooleanType DrawPolygonPrimitive(Image *image,
         GetPixelInfo(image,&pixel);
         for ( ; x <= stop_x; x++)
         {
-          if ((x == CastDoubleToSSizeT(ceil(primitive_info->point.x-0.5))) &&
-              (y == CastDoubleToSSizeT(ceil(primitive_info->point.y-0.5))))
+          if ((x == CastDoubleToLong(ceil(primitive_info->point.x-0.5))) &&
+              (y == CastDoubleToLong(ceil(primitive_info->point.y-0.5))))
             {
               GetFillColor(draw_info,x-start_x,y-start_y,&pixel,exception);
               SetPixelViaPixelInfo(image,&pixel,q);
@@ -5164,8 +5164,8 @@ static void LogPrimitiveInfo(const PrimitiveInfo *primitive_info)
     coordinates,
     y;
 
-  x=CastDoubleToSSizeT(ceil(primitive_info->point.x-0.5));
-  y=CastDoubleToSSizeT(ceil(primitive_info->point.y-0.5));
+  x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));
+  y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));
   switch (primitive_info->primitive)
   {
     case AlphaPrimitive:
@@ -5278,8 +5278,8 @@ MagickExport MagickBooleanType DrawPrimitive(Image *image,
       status&=SetImageMask(image,CompositePixelMask,draw_info->composite_mask,
         exception);
     }
-  x=CastDoubleToSSizeT(ceil(primitive_info->point.x-0.5));
-  y=CastDoubleToSSizeT(ceil(primitive_info->point.y-0.5));
+  x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));
+  y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));
   image_view=AcquireAuthenticCacheView(image,exception);
   switch (primitive_info->primitive)
   {
@@ -5557,8 +5557,8 @@ MagickExport MagickBooleanType DrawPrimitive(Image *image,
       composite_images=DestroyImageList(composite_images);
       (void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)
         NULL,(void *) NULL);
-      x1=CastDoubleToSSizeT(ceil(primitive_info[1].point.x-0.5));
-      y1=CastDoubleToSSizeT(ceil(primitive_info[1].point.y-0.5));
+      x1=CastDoubleToLong(ceil(primitive_info[1].point.x-0.5));
+      y1=CastDoubleToLong(ceil(primitive_info[1].point.y-0.5));
       if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||
           ((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))
         {
@@ -6167,7 +6167,7 @@ static MagickBooleanType TraceArcPath(MVGInfo *mvg_info,const PointInfo start,
   else
     if ((theta > 0.0) && (sweep == MagickFalse))
       theta-=2.0*MagickPI;
-  arc_segments=(size_t) CastDoubleToSSizeT(ceil(fabs((double) (theta/(0.5*
+  arc_segments=(size_t) CastDoubleToLong(ceil(fabs((double) (theta/(0.5*
     MagickPI+MagickEpsilon)))));
   status=MagickTrue;
   p=primitive_info;
@@ -7517,7 +7517,7 @@ static PrimitiveInfo *TraceStrokePolygon(const DrawInfo *draw_info,
           theta.q=atan2(box_q[2].y-center.y,box_q[2].x-center.x);
           if (theta.q < theta.p)
             theta.q+=2.0*MagickPI;
-          arc_segments=(size_t) CastDoubleToSSizeT(ceil((double) ((theta.
+          arc_segments=(size_t) CastDoubleToLong(ceil((double) ((theta.
             q-theta.p)/(2.0*sqrt(PerceptibleReciprocal(mid))))));
           CheckPathExtent(MaxStrokePad,arc_segments+MaxStrokePad);
           stroke_q[q].x=box_q[1].x;
@@ -7590,7 +7590,7 @@ static PrimitiveInfo *TraceStrokePolygon(const DrawInfo *draw_info,
           theta.q=atan2(box_p[2].y-center.y,box_p[2].x-center.x);
           if (theta.p < theta.q)
             theta.p+=2.0*MagickPI;
-          arc_segments=(size_t) CastDoubleToSSizeT(ceil((double) ((theta.p-
+          arc_segments=(size_t) CastDoubleToLong(ceil((double) ((theta.p-
             theta.q)/(2.0*sqrt((double) (1.0/mid))))));
           CheckPathExtent(arc_segments+MaxStrokePad,MaxStrokePad);
           stroke_p[p++]=box_p[1];
diff --git a/MagickCore/effect.c b/MagickCore/effect.c
index a37a1999e..bfb1363f2 100644
--- a/MagickCore/effect.c
+++ b/MagickCore/effect.c
@@ -288,7 +288,7 @@ MagickExport Image *AdaptiveBlurImage(const Image *image,const double radius,
         center,
         j;
 
-      j=CastDoubleToSSizeT(ceil((double) width*(1.0-QuantumScale*
+      j=CastDoubleToLong(ceil((double) width*(1.0-QuantumScale*
         GetPixelIntensity(edge_image,r))-0.5));
       if (j < 0)
         j=0;
@@ -609,7 +609,7 @@ MagickExport Image *AdaptiveSharpenImage(const Image *image,const double radius,
         center,
         j;
 
-      j=CastDoubleToSSizeT(ceil((double) width*(1.0-QuantumScale*
+      j=CastDoubleToLong(ceil((double) width*(1.0-QuantumScale*
         GetPixelIntensity(edge_image,r))-0.5));
       if (j < 0)
         j=0;
@@ -2402,9 +2402,9 @@ MagickExport Image *MotionBlurImage(const Image *image,const double radius,
   point.y=(double) width*cos(DegreesToRadians(angle));
   for (i=0; i < (ssize_t) width; i++)
   {
-    offset[i].x=CastDoubleToSSizeT(ceil((double) (i*point.y)/
+    offset[i].x=CastDoubleToLong(ceil((double) (i*point.y)/
       hypot(point.x,point.y)-0.5));
-    offset[i].y=CastDoubleToSSizeT(ceil((double) (i*point.x)/
+    offset[i].y=CastDoubleToLong(ceil((double) (i*point.x)/
       hypot(point.x,point.y)-0.5));
   }
   /*
diff --git a/MagickCore/gem.c b/MagickCore/gem.c
index 4eb8c3fc5..2c5911f67 100644
--- a/MagickCore/gem.c
+++ b/MagickCore/gem.c
@@ -692,7 +692,7 @@ MagickPrivate void ConvertHWBToRGB(const double hue,const double whiteness,
       *blue=QuantumRange*v;
       return;
     }
-  i=CastDoubleToSSizeT(floor(6.0*hue));
+  i=CastDoubleToLong(floor(6.0*hue));
   f=6.0*hue-i;
   if ((i & 0x01) != 0)
     f=1.0-f;
diff --git a/MagickCore/geometry.c b/MagickCore/geometry.c
index dd46a96fc..e9a5981bd 100644
--- a/MagickCore/geometry.c
+++ b/MagickCore/geometry.c
@@ -241,7 +241,7 @@ MagickExport MagickStatusType GetGeometry(const char *geometry,ssize_t *x,
               if (LocaleNCompare(p,"0x",2) == 0)
                 *width=(size_t) strtol(p,&p,10);
               else
-                *width=CastDoubleToSizeT(StringToDouble(p,&p));
+                *width=CastDoubleToUnsigned(StringToDouble(p,&p));
             }
           if (p != q)
             flags|=WidthValue;
@@ -260,7 +260,7 @@ MagickExport MagickStatusType GetGeometry(const char *geometry,ssize_t *x,
               */
               q=p;
               if (height != (size_t *) NULL)
-                *height=CastDoubleToSizeT(StringToDouble(p,&p));
+                *height=CastDoubleToUnsigned(StringToDouble(p,&p));
               if (p != q)
                 flags|=HeightValue;
             }
@@ -279,7 +279,7 @@ MagickExport MagickStatusType GetGeometry(const char *geometry,ssize_t *x,
       }
       q=p;
       if (x != (ssize_t *) NULL)
-        *x=CastDoubleToSSizeT(StringToDouble(p,&p));
+        *x=CastDoubleToLong(StringToDouble(p,&p));
       if (p != q)
         {
           flags|=XValue;
@@ -300,7 +300,7 @@ MagickExport MagickStatusType GetGeometry(const char *geometry,ssize_t *x,
       }
       q=p;
       if (y != (ssize_t *) NULL)
-        *y=CastDoubleToSSizeT(StringToDouble(p,&p));
+        *y=CastDoubleToLong(StringToDouble(p,&p));
       if (p != q)
         {
           flags|=YValue;
@@ -1285,8 +1285,8 @@ MagickExport MagickStatusType ParseGravityGeometry(const Image *image,
       scale.y=geometry_info.sigma;
       if ((status & SigmaValue) == 0)
         scale.y=scale.x;
-      region_info->width=CastDoubleToSizeT(scale.x*image->columns/100.0);
-      region_info->height=CastDoubleToSizeT(scale.y*image->rows/100.0);
+      region_info->width=CastDoubleToUnsigned(scale.x*image->columns/100.0);
+      region_info->height=CastDoubleToUnsigned(scale.y*image->rows/100.0);
     }
   if ((flags & AspectRatioValue) != 0)
     {
@@ -1308,12 +1308,12 @@ MagickExport MagickStatusType ParseGravityGeometry(const Image *image,
       if (geometry_ratio >= image_ratio)
         {
           region_info->width=image->columns;
-          region_info->height=CastDoubleToSizeT((double) image->rows*image_ratio/
+          region_info->height=CastDoubleToUnsigned((double) image->rows*image_ratio/
             geometry_ratio);
         }
       else
         {
-          region_info->width=CastDoubleToSizeT((double) image->columns*
+          region_info->width=CastDoubleToUnsigned((double) image->columns*
             geometry_ratio/image_ratio);
           region_info->height=image->rows;
         }
@@ -1450,7 +1450,7 @@ MagickExport MagickStatusType ParseMetaGeometry(const char *geometry,ssize_t *x,
         }
       else
         {
-          *width=CastDoubleToSizeT(PerceptibleReciprocal(
+          *width=CastDoubleToUnsigned(PerceptibleReciprocal(
             image_ratio)*former_width*geometry_ratio);
           *height=former_height;
         }
diff --git a/MagickCore/image-private.h b/MagickCore/image-private.h
index 694c19d54..8ce0208d5 100644
--- a/MagickCore/image-private.h
+++ b/MagickCore/image-private.h
@@ -53,40 +53,66 @@ extern "C" {
 #define UndefinedCompressionQuality  0UL
 #define UndefinedTicksPerSecond  100L
 
-static inline QuantumAny CastDoubleToQuantumAny(const double x)
+static inline ssize_t CastDoubleToLong(const double x)
 {
   if (IsNaN(x) != 0)
-    return(0);
-  if (x > ((double) ((QuantumAny) ~0)))
-    return((QuantumAny) ~0);
-  if (x < 0.0)
-    return(0.0);
-  return((QuantumAny) (x+0.5));
+    {
+      errno=ERANGE;
+      return(0);
+    }
+  if (floor(x) > ((double) MAGICK_SSIZE_MAX-1))
+    {
+      errno=ERANGE;
+      return((ssize_t) MAGICK_SSIZE_MAX);
+    }
+  if (ceil(x) < ((double) MAGICK_SSIZE_MIN+1))
+    {
+      errno=ERANGE;
+      return((ssize_t) MAGICK_SSIZE_MIN);
+    }
+  return((ssize_t) x);
 }
 
-static inline size_t CastDoubleToSizeT(const double x)
+static inline QuantumAny CastDoubleToQuantumAny(const double x)
 {
   if (IsNaN(x) != 0)
-    return(0);
-  if (x > ((double) MAGICK_SIZE_MAX+0.5))
-    return((size_t) MAGICK_SIZE_MAX);
-  return((size_t) floor(x+0.5));
+    {
+      errno=ERANGE;
+      return(0);
+    }
+  if (x > ((double) ((QuantumAny) ~0)))
+    {
+      errno=ERANGE;
+      return((QuantumAny) ~0);
+    }
+  if (x < 0.0)
+    {
+      errno=ERANGE;
+      return((QuantumAny) 0);
+    }
+  return((QuantumAny) (x+0.5));
 }
 
-static inline ssize_t CastDoubleToSSizeT(const double x)
+static inline size_t CastDoubleToUnsigned(const double x)
 {
   if (IsNaN(x) != 0)
-    return(0);
-  if (x > ((double) MAGICK_SSIZE_MAX+0.5))
-    return((ssize_t) MAGICK_SSIZE_MAX);
-  if (x < ((double) MAGICK_SSIZE_MIN-0.5))
-    return((ssize_t) MAGICK_SSIZE_MIN);
-  if (x >= 0.0)
-    return((ssize_t) floor(x+0.5));
-  return((ssize_t) ceil(x-0.5));
+    {
+      errno=ERANGE;
+      return(0);
+    }
+  if (floor(x) > ((double) MAGICK_SSIZE_MAX-1))
+    {
+      errno=ERANGE;
+      return((size_t) MAGICK_SIZE_MAX);
+    }
+  if (ceil(x) < 0.0)
+    {
+      errno=ERANGE;
+      return(0);
+    }
+  return((size_t) x);
 }
 
-
 static inline double DegreesToRadians(const double degrees)
 {
   return((double) (MagickPI*degrees/180.0));
diff --git a/MagickCore/image.c b/MagickCore/image.c
index 7b8caa0d2..3e6fdd114 100644
--- a/MagickCore/image.c
+++ b/MagickCore/image.c
@@ -282,21 +282,21 @@ MagickExport Image *AcquireImage(const ImageInfo *image_info,
       if ((flags & GreaterValue) != 0)
         {
           if ((double) image->delay > floor(geometry_info.rho+0.5))
-            image->delay=(size_t) CastDoubleToSSizeT(floor(
+            image->delay=(size_t) CastDoubleToLong(floor(
               geometry_info.rho+0.5));
         }
       else
         if ((flags & LessValue) != 0)
           {
             if ((double) image->delay < floor(geometry_info.rho+0.5))
-              image->ticks_per_second=CastDoubleToSSizeT(floor(
+              image->ticks_per_second=CastDoubleToLong(floor(
                 geometry_info.sigma+0.5));
           }
         else
-          image->delay=(size_t) CastDoubleToSSizeT(floor(
+          image->delay=(size_t) CastDoubleToLong(floor(
             geometry_info.rho+0.5));
       if ((flags & SigmaValue) != 0)
-        image->ticks_per_second=CastDoubleToSSizeT(floor(
+        image->ticks_per_second=CastDoubleToLong(floor(
           geometry_info.sigma+0.5));
     }
   option=GetImageOption(image_info,"dispose");
@@ -881,18 +881,18 @@ MagickExport Image *CloneImage(const Image *image,const size_t columns,
   scale=1.0;
   if (image->columns != 0)
     scale=(double) columns/(double) image->columns;
-  clone_image->page.width=(size_t) CastDoubleToSSizeT(floor(scale*
+  clone_image->page.width=(size_t) CastDoubleToLong(floor(scale*
     image->page.width+0.5));
-  clone_image->page.x=CastDoubleToSSizeT(ceil(scale*image->page.x-0.5));
-  clone_image->tile_offset.x=CastDoubleToSSizeT(ceil(scale*
+  clone_image->page.x=CastDoubleToLong(ceil(scale*image->page.x-0.5));
+  clone_image->tile_offset.x=CastDoubleToLong(ceil(scale*
     image->tile_offset.x-0.5));
   scale=1.0;
   if (image->rows != 0)
     scale=(double) rows/(double) image->rows;
-  clone_image->page.height=(size_t) CastDoubleToSSizeT(floor(scale*
+  clone_image->page.height=(size_t) CastDoubleToLong(floor(scale*
     image->page.height+0.5));
-  clone_image->page.y=CastDoubleToSSizeT(ceil(scale*image->page.y-0.5));
-  clone_image->tile_offset.y=CastDoubleToSSizeT(ceil(scale*
+  clone_image->page.y=CastDoubleToLong(ceil(scale*image->page.y-0.5));
+  clone_image->tile_offset.y=CastDoubleToLong(ceil(scale*
     image->tile_offset.y-0.5));
   clone_image->cache=ClonePixelCache(image->cache);
   if (SetImageExtent(clone_image,columns,rows,exception) == MagickFalse)
diff --git a/MagickCore/pixel.c b/MagickCore/pixel.c
index c2aea7c1d..5c1c5296f 100644
--- a/MagickCore/pixel.c
+++ b/MagickCore/pixel.c
@@ -4515,8 +4515,8 @@ MagickExport MagickBooleanType InterpolatePixelChannel(
   status=MagickTrue;
   *pixel=0.0;
   traits=GetPixelChannelTraits(image,channel);
-  x_offset=CastDoubleToSSizeT(floor(x));
-  y_offset=CastDoubleToSSizeT(floor(y));
+  x_offset=CastDoubleToLong(floor(x));
+  y_offset=CastDoubleToLong(floor(y));
   interpolate=method;
   if (interpolate == UndefinedInterpolatePixel)
     interpolate=image->interpolate;
@@ -4533,8 +4533,8 @@ MagickExport MagickBooleanType InterpolatePixelChannel(
       if (interpolate == Average9InterpolatePixel)
         {
           count=3;
-          x_offset=CastDoubleToSSizeT(floor(x+0.5)-1.0);
-          y_offset=CastDoubleToSSizeT(floor(y+0.5)-1.0);
+          x_offset=CastDoubleToLong(floor(x+0.5)-1.0);
+          y_offset=CastDoubleToLong(floor(y+0.5)-1.0);
         }
       else
         if (interpolate == Average16InterpolatePixel)
@@ -4717,8 +4717,8 @@ MagickExport MagickBooleanType InterpolatePixelChannel(
     }
     case NearestInterpolatePixel:
     {
-      x_offset=CastDoubleToSSizeT(floor(x+0.5));
-      y_offset=CastDoubleToSSizeT(floor(y+0.5));
+      x_offset=CastDoubleToLong(floor(x+0.5));
+      y_offset=CastDoubleToLong(floor(y+0.5));
       p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);
       if (p == (const Quantum *) NULL)
         {
@@ -4935,8 +4935,8 @@ MagickExport MagickBooleanType InterpolatePixelChannels(
   assert(source->signature == MagickCoreSignature);
   assert(source_view != (CacheView *) NULL);
   status=MagickTrue;
-  x_offset=CastDoubleToSSizeT(floor(x));
-  y_offset=CastDoubleToSSizeT(floor(y));
+  x_offset=CastDoubleToLong(floor(x));
+  y_offset=CastDoubleToLong(floor(y));
   interpolate=method;
   if (interpolate == UndefinedInterpolatePixel)
     interpolate=source->interpolate;
@@ -4953,8 +4953,8 @@ MagickExport MagickBooleanType InterpolatePixelChannels(
       if (interpolate == Average9InterpolatePixel)
         {
           count=3;
-          x_offset=CastDoubleToSSizeT(floor(x+0.5)-1.0);
-          y_offset=CastDoubleToSSizeT(floor(y+0.5)-1.0);
+          x_offset=CastDoubleToLong(floor(x+0.5)-1.0);
+          y_offset=CastDoubleToLong(floor(y+0.5)-1.0);
         }
       else
         if (interpolate == Average16InterpolatePixel)
@@ -5218,8 +5218,8 @@ MagickExport MagickBooleanType InterpolatePixelChannels(
     }
     case NearestInterpolatePixel:
     {
-      x_offset=CastDoubleToSSizeT(floor(x+0.5));
-      y_offset=CastDoubleToSSizeT(floor(y+0.5));
+      x_offset=CastDoubleToLong(floor(x+0.5));
+      y_offset=CastDoubleToLong(floor(y+0.5));
       p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,1,1,exception);
       if (p == (const Quantum *) NULL)
         {
@@ -5502,8 +5502,8 @@ MagickExport MagickBooleanType InterpolatePixelInfo(const Image *image,
   assert(image->signature == MagickCoreSignature);
   assert(image_view != (CacheView *) NULL);
   status=MagickTrue;
-  x_offset=CastDoubleToSSizeT(floor(x));
-  y_offset=CastDoubleToSSizeT(floor(y));
+  x_offset=CastDoubleToLong(floor(x));
+  y_offset=CastDoubleToLong(floor(y));
   interpolate=method;
   if (interpolate == UndefinedInterpolatePixel)
     interpolate=image->interpolate;
@@ -5522,8 +5522,8 @@ MagickExport MagickBooleanType InterpolatePixelInfo(const Image *image,
       if (interpolate == Average9InterpolatePixel)
         {
           count=3;
-          x_offset=CastDoubleToSSizeT(floor(x+0.5)-1.0);
-          y_offset=CastDoubleToSSizeT(floor(y+0.5)-1.0);
+          x_offset=CastDoubleToLong(floor(x+0.5)-1.0);
+          y_offset=CastDoubleToLong(floor(y+0.5)-1.0);
         }
       else if (interpolate == Average16InterpolatePixel)
         {
@@ -5847,8 +5847,8 @@ MagickExport MagickBooleanType InterpolatePixelInfo(const Image *image,
     }
     case NearestInterpolatePixel:
     {
-      x_offset=CastDoubleToSSizeT(floor(x+0.5));
-      y_offset=CastDoubleToSSizeT(floor(y+0.5));
+      x_offset=CastDoubleToLong(floor(x+0.5));
+      y_offset=CastDoubleToLong(floor(y+0.5));
       p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);
       if (p == (const Quantum *) NULL)
         {
diff --git a/MagickCore/property.c b/MagickCore/property.c
index b13fa7a17..1b42adaee 100644
--- a/MagickCore/property.c
+++ b/MagickCore/property.c
@@ -4372,13 +4372,13 @@ MagickExport MagickBooleanType SetImageProperty(Image *image,
             if ((flags & LessValue) != 0)
               {
                 if ((double) image->delay < floor(geometry_info.rho+0.5))
-                  image->delay=CastDoubleToSSizeT(
+                  image->delay=CastDoubleToLong(
                     floor(geometry_info.sigma+0.5));
               }
             else
               image->delay=(size_t) floor(geometry_info.rho+0.5);
           if ((flags & SigmaValue) != 0)
-            image->ticks_per_second=CastDoubleToSSizeT(floor(
+            image->ticks_per_second=CastDoubleToLong(floor(
               geometry_info.sigma+0.5));
           return(MagickTrue);
         }
diff --git a/MagickCore/shear.c b/MagickCore/shear.c
index 62a98013e..05703ca34 100644
--- a/MagickCore/shear.c
+++ b/MagickCore/shear.c
@@ -163,10 +163,10 @@ static MagickBooleanType CropToFitImage(Image **image,
     if (max.y < extent[i].y)
       max.y=extent[i].y;
   }
-  geometry.x=CastDoubleToSSizeT(ceil(min.x-0.5));
-  geometry.y=CastDoubleToSSizeT(ceil(min.y-0.5));
-  geometry.width=(size_t) CastDoubleToSSizeT(floor(max.x-min.x+0.5));
-  geometry.height=(size_t) CastDoubleToSSizeT(floor(max.y-min.y+0.5));
+  geometry.x=CastDoubleToLong(ceil(min.x-0.5));
+  geometry.y=CastDoubleToLong(ceil(min.y-0.5));
+  geometry.width=(size_t) CastDoubleToLong(floor(max.x-min.x+0.5));
+  geometry.height=(size_t) CastDoubleToLong(floor(max.y-min.y+0.5));
   page=(*image)->page;
   (void) ParseAbsoluteGeometry("0x0+0+0",&(*image)->page);
   crop_image=CropImage(*image,&geometry,exception);
@@ -1217,7 +1217,7 @@ static MagickBooleanType XShearImage(Image *image,const double degrees,
         displacement*=(-1.0);
         direction=LEFT;
       }
-    step=CastDoubleToSSizeT(floor((double) displacement));
+    step=CastDoubleToLong(floor((double) displacement));
     area=(double) (displacement-step);
     step++;
     pixel=background;
@@ -1434,7 +1434,7 @@ static MagickBooleanType YShearImage(Image *image,const double degrees,
         displacement*=(-1.0);
         direction=UP;
       }
-    step=CastDoubleToSSizeT(floor((double) displacement));
+    step=CastDoubleToLong(floor((double) displacement));
     area=(double) (displacement-step);
     step++;
     pixel=background;
@@ -1617,11 +1617,11 @@ MagickExport Image *ShearImage(const Image *image,const double x_shear,
   /*
     Compute image size.
   */
-  bounds.width=image->columns+CastDoubleToSSizeT(floor(fabs(shear.x)*
+  bounds.width=image->columns+CastDoubleToLong(floor(fabs(shear.x)*
     image->rows+0.5));
-  bounds.x=CastDoubleToSSizeT(ceil((double) image->columns+((fabs(shear.x)*
+  bounds.x=CastDoubleToLong(ceil((double) image->columns+((fabs(shear.x)*
     image->rows)-image->columns)/2.0-0.5));
-  bounds.y=CastDoubleToSSizeT(ceil((double) image->rows+((fabs(shear.y)*
+  bounds.y=CastDoubleToLong(ceil((double) image->rows+((fabs(shear.y)*
     bounds.width)-image->rows)/2.0-0.5));
   /*
     Surround image with border.
@@ -1770,9 +1770,9 @@ MagickExport Image *ShearRotateImage(const Image *image,const double degrees,
   bounds.height=(size_t) floor(fabs((double) bounds.width*shear.y)+height+0.5);
   shear_width=(size_t) floor(fabs((double) bounds.height*shear.x)+
     bounds.width+0.5);
-  bounds.x=CastDoubleToSSizeT(floor((double) ((shear_width > bounds.width) ?
+  bounds.x=CastDoubleToLong(floor((double) ((shear_width > bounds.width) ?
     width : bounds.width-shear_width+2)/2.0+0.5));
-  bounds.y=CastDoubleToSSizeT(floor(((double) bounds.height-height+2)/2.0+0.5));
+  bounds.y=CastDoubleToLong(floor(((double) bounds.height-height+2)/2.0+0.5));
   /*
     Surround image with a border.
   */
diff --git a/MagickCore/transform.c b/MagickCore/transform.c
index 6afe0a3de..385d5eb68 100644
--- a/MagickCore/transform.c
+++ b/MagickCore/transform.c
@@ -773,8 +773,8 @@ static inline ssize_t PixelRoundOffset(double x)
     Round the fraction to nearest integer.
   */
   if ((x-floor(x)) < (ceil(x)-x))
-    return(CastDoubleToSSizeT(floor(x)));
-  return(CastDoubleToSSizeT(ceil(x)));
+    return(CastDoubleToLong(floor(x)));
+  return(CastDoubleToLong(ceil(x)));
 }
 
 MagickExport Image *CropImageToTiles(const Image *image,
diff --git a/MagickCore/visual-effects.c b/MagickCore/visual-effects.c
index 069904a08..789660231 100644
--- a/MagickCore/visual-effects.c
+++ b/MagickCore/visual-effects.c
@@ -1439,8 +1439,8 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
       */
       depth--;
       attenuate++;
-      x_mid=CastDoubleToSSizeT(ceil((segment->x1+segment->x2)/2-0.5));
-      y_mid=CastDoubleToSSizeT(ceil((segment->y1+segment->y2)/2-0.5));
+      x_mid=CastDoubleToLong(ceil((segment->x1+segment->x2)/2-0.5));
+      y_mid=CastDoubleToLong(ceil((segment->y1+segment->y2)/2-0.5));
       local_info=(*segment);
       local_info.x2=(double) x_mid;
       local_info.y2=(double) y_mid;
@@ -1463,8 +1463,8 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
         &local_info,attenuate,depth,exception);
       return(status == 0 ? MagickFalse : MagickTrue);
     }
-  x_mid=CastDoubleToSSizeT(ceil((segment->x1+segment->x2)/2-0.5));
-  y_mid=CastDoubleToSSizeT(ceil((segment->y1+segment->y2)/2-0.5));
+  x_mid=CastDoubleToLong(ceil((segment->x1+segment->x2)/2-0.5));
+  y_mid=CastDoubleToLong(ceil((segment->y1+segment->y2)/2-0.5));
   if ((fabs(segment->x1-x_mid) < MagickEpsilon) &&
       (fabs(segment->x2-x_mid) < MagickEpsilon) &&
       (fabs(segment->y1-y_mid) < MagickEpsilon) &&
@@ -1481,10 +1481,10 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
       /*
         Left pixel.
       */
-      x=CastDoubleToSSizeT(ceil(segment->x1-0.5));
-      u=GetCacheViewVirtualPixels(u_view,x,CastDoubleToSSizeT(ceil(
+      x=CastDoubleToLong(ceil(segment->x1-0.5));
+      u=GetCacheViewVirtualPixels(u_view,x,CastDoubleToLong(ceil(
         segment->y1-0.5)),1,1,exception);
-      v=GetCacheViewVirtualPixels(v_view,x,CastDoubleToSSizeT(ceil(
+      v=GetCacheViewVirtualPixels(v_view,x,CastDoubleToLong(ceil(
         segment->y2-0.5)),1,1,exception);
       q=QueueCacheViewAuthenticPixels(image_view,x,y_mid,1,1,exception);
       if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
@@ -1504,10 +1504,10 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
           /*
             Right pixel.
           */
-          x=CastDoubleToSSizeT(ceil(segment->x2-0.5));
-          u=GetCacheViewVirtualPixels(u_view,x,CastDoubleToSSizeT(ceil(
+          x=CastDoubleToLong(ceil(segment->x2-0.5));
+          u=GetCacheViewVirtualPixels(u_view,x,CastDoubleToLong(ceil(
             segment->y1-0.5)),1,1,exception);
-          v=GetCacheViewVirtualPixels(v_view,x,CastDoubleToSSizeT(ceil(
+          v=GetCacheViewVirtualPixels(v_view,x,CastDoubleToLong(ceil(
             segment->y2-0.5)),1,1,exception);
           q=QueueCacheViewAuthenticPixels(image_view,x,y_mid,1,1,exception);
           if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
@@ -1533,10 +1533,10 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
           /*
             Bottom pixel.
           */
-          y=CastDoubleToSSizeT(ceil(segment->y2-0.5));
-          u=GetCacheViewVirtualPixels(u_view,CastDoubleToSSizeT(ceil(
+          y=CastDoubleToLong(ceil(segment->y2-0.5));
+          u=GetCacheViewVirtualPixels(u_view,CastDoubleToLong(ceil(
             segment->x1-0.5)),y,1,1,exception);
-          v=GetCacheViewVirtualPixels(v_view,CastDoubleToSSizeT(ceil(
+          v=GetCacheViewVirtualPixels(v_view,CastDoubleToLong(ceil(
             segment->x2-0.5)),y,1,1,exception);
           q=QueueCacheViewAuthenticPixels(image_view,x_mid,y,1,1,exception);
           if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
@@ -1557,10 +1557,10 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
           /*
             Top pixel.
           */
-          y=CastDoubleToSSizeT(ceil(segment->y1-0.5));
-          u=GetCacheViewVirtualPixels(u_view,CastDoubleToSSizeT(ceil(
+          y=CastDoubleToLong(ceil(segment->y1-0.5));
+          u=GetCacheViewVirtualPixels(u_view,CastDoubleToLong(ceil(
             segment->x1-0.5)),y,1,1,exception);
-          v=GetCacheViewVirtualPixels(v_view,CastDoubleToSSizeT(ceil(
+          v=GetCacheViewVirtualPixels(v_view,CastDoubleToLong(ceil(
             segment->x2-0.5)),y,1,1,exception);
           q=QueueCacheViewAuthenticPixels(image_view,x_mid,y,1,1,exception);
           if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
@@ -1583,11 +1583,11 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
       /*
         Middle pixel.
       */
-      x=CastDoubleToSSizeT(ceil(segment->x1-0.5));
-      y=CastDoubleToSSizeT(ceil(segment->y1-0.5));
+      x=CastDoubleToLong(ceil(segment->x1-0.5));
+      y=CastDoubleToLong(ceil(segment->y1-0.5));
       u=GetCacheViewVirtualPixels(u_view,x,y,1,1,exception);
-      x=CastDoubleToSSizeT(ceil(segment->x2-0.5));
-      y=CastDoubleToSSizeT(ceil(segment->y2-0.5));
+      x=CastDoubleToLong(ceil(segment->x2-0.5));
+      y=CastDoubleToLong(ceil(segment->y2-0.5));
       v=GetCacheViewVirtualPixels(v_view,x,y,1,1,exception);
       q=QueueCacheViewAuthenticPixels(image_view,x_mid,y_mid,1,1,exception);
       if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
diff --git a/MagickWand/drawing-wand.c b/MagickWand/drawing-wand.c
index 002798ba0..cc1fbc640 100644
--- a/MagickWand/drawing-wand.c
+++ b/MagickWand/drawing-wand.c
@@ -4285,10 +4285,10 @@ WandExport MagickBooleanType DrawPushPattern(DrawingWand *wand,
     x,y,width,height);
   wand->indent_depth++;
   wand->pattern_id=AcquireString(pattern_id);
-  wand->pattern_bounds.x=CastDoubleToSSizeT(ceil(x-0.5));
-  wand->pattern_bounds.y=CastDoubleToSSizeT(ceil(y-0.5));
-  wand->pattern_bounds.width=(size_t) CastDoubleToSSizeT(floor(width+0.5));
-  wand->pattern_bounds.height=(size_t) CastDoubleToSSizeT(floor(height+0.5));
+  wand->pattern_bounds.x=CastDoubleToLong(ceil(x-0.5));
+  wand->pattern_bounds.y=CastDoubleToLong(ceil(y-0.5));
+  wand->pattern_bounds.width=(size_t) CastDoubleToLong(floor(width+0.5));
+  wand->pattern_bounds.height=(size_t) CastDoubleToLong(floor(height+0.5));
   wand->pattern_offset=wand->mvg_length;
   return(MagickTrue);
 }
diff --git a/coders/histogram.c b/coders/histogram.c
index 15ee9772d..0df364c12 100644
--- a/coders/histogram.c
+++ b/coders/histogram.c
@@ -295,7 +295,7 @@ static MagickBooleanType WriteHISTOGRAMImage(const ImageInfo *image_info,
       break;
     if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
       {
-        y=CastDoubleToSSizeT(ceil((double) histogram_image->rows-scale*
+        y=CastDoubleToLong(ceil((double) histogram_image->rows-scale*
           histogram[x].red-0.5));
         r=q+y*GetPixelChannels(histogram_image);
         for ( ; y < (ssize_t) histogram_image->rows; y++)
@@ -306,7 +306,7 @@ static MagickBooleanType WriteHISTOGRAMImage(const ImageInfo *image_info,
       }
     if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
       {
-        y=CastDoubleToSSizeT(ceil((double) histogram_image->rows-scale*
+        y=CastDoubleToLong(ceil((double) histogram_image->rows-scale*
           histogram[x].green-0.5));
         r=q+y*GetPixelChannels(histogram_image);
         for ( ; y < (ssize_t) histogram_image->rows; y++)
@@ -317,7 +317,7 @@ static MagickBooleanType WriteHISTOGRAMImage(const ImageInfo *image_info,
       }
     if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
       {
-        y=CastDoubleToSSizeT(ceil((double) histogram_image->rows-scale*
+        y=CastDoubleToLong(ceil((double) histogram_image->rows-scale*
           histogram[x].blue-0.5));
         r=q+y*GetPixelChannels(histogram_image);
         for ( ; y < (ssize_t) histogram_image->rows; y++)
diff --git a/coders/icon.c b/coders/icon.c
index 2ccbc82b1..f54225ff9 100644
--- a/coders/icon.c
+++ b/coders/icon.c
@@ -227,6 +227,7 @@ static Image *ReadICONImage(const ImageInfo *image_info,
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
+  (void) memset(&icon_file,0,sizeof(icon_file));
   icon_file.reserved=(short) ReadBlobLSBShort(image);
   icon_file.resource_type=(short) ReadBlobLSBShort(image);
   icon_file.count=(short) ReadBlobLSBShort(image);
diff --git a/coders/pcl.c b/coders/pcl.c
index 8197a0c39..8056ae0c9 100644
--- a/coders/pcl.c
+++ b/coders/pcl.c
@@ -294,8 +294,8 @@ static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)
     /*
       Set PCL render geometry.
     */
-    width=(size_t) floor(bounds.x2-bounds.x1+0.5);
-    height=(size_t) floor(bounds.y2-bounds.y1+0.5);
+    width=(size_t) CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));
+    height=(size_t) CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));
     if (width > page.width)
       page.width=width;
     if (height > page.height)
diff --git a/coders/tiff.c b/coders/tiff.c
index a0bdd6313..68a6d5b09 100644
--- a/coders/tiff.c
+++ b/coders/tiff.c
@@ -1506,9 +1506,9 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))
       {
-        image->page.x=CastDoubleToSSizeT(ceil(x_position*
+        image->page.x=CastDoubleToLong(ceil(x_position*
           image->resolution.x-0.5));
-        image->page.y=CastDoubleToSSizeT(ceil(y_position*
+        image->page.y=CastDoubleToLong(ceil(y_position*
           image->resolution.y-0.5));
       }
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)
diff --git a/coders/txt.c b/coders/txt.c
index 91323583d..f8312a4fd 100644
--- a/coders/txt.c
+++ b/coders/txt.c
@@ -273,7 +273,7 @@ static Image *ReadTEXTImage(const ImageInfo *image_info,
       draw_info=DestroyDrawInfo(draw_info);
       ThrowReaderException(TypeError,"UnableToGetTypeMetrics");
     }
-  page.y=CastDoubleToSSizeT(ceil((double) page.y+metrics.ascent-0.5));
+  page.y=CastDoubleToLong(ceil((double) page.y+metrics.ascent-0.5));
   (void) FormatLocaleString(geometry,MagickPathExtent,"%gx%g%+g%+g",(double)
     image->columns,(double) image->rows,(double) page.x,(double) page.y);
   (void) CloneString(&draw_info->geometry,geometry);
@@ -574,7 +574,7 @@ static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
           black),range);
         pixel.alpha=(MagickRealType) ScaleAnyToQuantum(CastDoubleToQuantumAny(
           alpha),range);
-        q=GetAuthenticPixels(image,CastDoubleToSSizeT(x_offset),CastDoubleToSSizeT(
+        q=GetAuthenticPixels(image,CastDoubleToLong(x_offset),CastDoubleToLong(
           y_offset),1,1,exception);
         if (q == (Quantum *) NULL)
           {
diff --git a/configure b/configure
index 0b3c67e72..85aade112 100755
--- a/configure
+++ b/configure
@@ -4552,7 +4552,7 @@ MAGICK_PATCHLEVEL_VERSION=62
 
 MAGICK_VERSION=7.0.10-62
 
-MAGICK_GIT_REVISION=18417:ff04e172d:20210207
+MAGICK_GIT_REVISION=fecfed4d0:20230414
 
 
 # Substitute library versioning
@@ -25948,9 +25948,9 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-       int f(int  x){return 1;}
-                        int f(char x){return 1;}
-                        int f(bool x){return 1;}
+       int f(int  x){return x;}
+                        int f(char x){return x == '\1' ? 1 : 0;}
+                        int f(bool x){return x ? 1 : 0;}
 int
 main ()
 {
-- 
2.34.1

