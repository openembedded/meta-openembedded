From 95a74f9639872c667213b9ce201c1a388d538d30 Mon Sep 17 00:00:00 2001
From: Divyanshu Rathore <Divyanshu.Rathore@bmwtechworks.in>
Date: Tue, 2 Dec 2025 14:02:56 +0530
Subject: [PATCH 16/18] ImageMagick: Add support patch 2 to fix CVE-2023-34151

Upstream-Status: Backport [https://github.com/ImageMagick/ImageMagick/commit/f7b5682435d37ad5ea8142d69629c93228e6376d]

Comment: Refreshed hunk to match latest kirkstone

Signed-off-by: Divyanshu Rathore <Divyanshu.Rathore@bmwtechworks.in>
---
 MagickCore/annotate.c       |  8 ++---
 MagickCore/draw.c           | 60 ++++++++++++++++++-------------------
 MagickCore/effect.c         |  8 ++---
 MagickCore/gem.c            |  2 +-
 MagickCore/geometry.c       | 24 +++++++--------
 MagickCore/image-private.h  | 37 ++++++++++++++++-------
 MagickCore/image.c          | 20 ++++++-------
 MagickCore/pixel.c          | 36 +++++++++++-----------
 MagickCore/property.c       |  4 +--
 MagickCore/shear.c          | 22 +++++++-------
 MagickCore/studio.h         |  2 --
 MagickCore/transform.c      |  4 +--
 MagickCore/visual-effects.c | 40 ++++++++++++-------------
 MagickWand/drawing-wand.c   |  8 ++---
 MagickWand/studio.h         |  2 --
 coders/histogram.c          |  6 ++--
 coders/jpeg.c               |  3 +-
 coders/png.c                | 12 ++++----
 coders/tiff.c               |  4 +--
 coders/txt.c                |  4 +--
 20 files changed, 159 insertions(+), 147 deletions(-)

diff --git a/MagickCore/annotate.c b/MagickCore/annotate.c
index 4be938be5..14f8d05d8 100644
--- a/MagickCore/annotate.c
+++ b/MagickCore/annotate.c
@@ -1734,8 +1734,8 @@ static MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,
 
           if (status == MagickFalse)
             continue;
-          x_offset=CastDoubleToLong(ceil(point.x-0.5));
-          y_offset=CastDoubleToLong(ceil(point.y+y-0.5));
+          x_offset=CastDoubleToSSizeT(ceil(point.x-0.5));
+          y_offset=CastDoubleToSSizeT(ceil(point.y+y-0.5));
           if ((y_offset < 0) || (y_offset >= (ssize_t) image->rows))
             continue;
           q=(Quantum *) NULL;
@@ -1750,7 +1750,7 @@ static MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,
           n=y*bitmap->bitmap.pitch;
           for (x=0; x < (ssize_t) bitmap->bitmap.width; x++, n++)
           {
-            x_offset=CastDoubleToLong(ceil(point.x+x-0.5));
+            x_offset=CastDoubleToSSizeT(ceil(point.x+x-0.5));
             if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))
               {
                 if (q != (Quantum *) NULL)
@@ -2102,7 +2102,7 @@ static MagickBooleanType RenderPostscript(Image *image,
       crop_info=GetImageBoundingBox(annotate_image,exception);
       crop_info.height=(size_t) ((resolution.y/DefaultResolution)*
         ExpandAffine(&draw_info->affine)*draw_info->pointsize+0.5);
-      crop_info.y=CastDoubleToLong(ceil((resolution.y/DefaultResolution)*
+      crop_info.y=CastDoubleToSSizeT(ceil((resolution.y/DefaultResolution)*
         extent.y/8.0-0.5));
       (void) FormatLocaleString(geometry,MagickPathExtent,
         "%.20gx%.20g%+.20g%+.20g",(double) crop_info.width,(double)
diff --git a/MagickCore/draw.c b/MagickCore/draw.c
index facea115e..02df7d231 100644
--- a/MagickCore/draw.c
+++ b/MagickCore/draw.c
@@ -1233,8 +1233,8 @@ MagickExport MagickBooleanType DrawAffineImage(Image *image,
   edge.y2=MagickMin(max.y,(double) image->rows-1.0);
   inverse_affine=InverseAffineMatrix(affine);
   GetPixelInfo(image,&zero);
-  start=CastDoubleToLong(ceil(edge.y1-0.5));
-  stop=CastDoubleToLong(floor(edge.y2+0.5));
+  start=CastDoubleToSSizeT(ceil(edge.y1-0.5));
+  stop=CastDoubleToSSizeT(floor(edge.y2+0.5));
   source_view=AcquireVirtualCacheView(source,exception);
   image_view=AcquireAuthenticCacheView(image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
@@ -1267,16 +1267,16 @@ MagickExport MagickBooleanType DrawAffineImage(Image *image,
     inverse_edge=AffineEdge(source,&inverse_affine,(double) y,&edge);
     if (inverse_edge.x2 < inverse_edge.x1)
       continue;
-    q=GetCacheViewAuthenticPixels(image_view,CastDoubleToLong(
-      ceil(inverse_edge.x1-0.5)),y,(size_t) CastDoubleToLong(floor(
+    q=GetCacheViewAuthenticPixels(image_view,CastDoubleToSSizeT(
+      ceil(inverse_edge.x1-0.5)),y,(size_t) CastDoubleToSSizeT(floor(
       inverse_edge.x2+0.5)-ceil(inverse_edge.x1-0.5)+1),1,exception);
     if (q == (Quantum *) NULL)
       continue;
     pixel=zero;
     composite=zero;
     x_offset=0;
-    for (x=CastDoubleToLong(ceil(inverse_edge.x1-0.5));
-         x <= CastDoubleToLong(floor(inverse_edge.x2+0.5)); x++)
+    for (x=CastDoubleToSSizeT(ceil(inverse_edge.x1-0.5));
+         x <= CastDoubleToSSizeT(floor(inverse_edge.x2+0.5)); x++)
     {
       point.x=(double) x*inverse_affine.sx+y*inverse_affine.ry+
         inverse_affine.tx;
@@ -2090,8 +2090,8 @@ MagickExport MagickBooleanType DrawGradientImage(Image *image,
         case UndefinedSpread:
         case PadSpread:
         {
-          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||
-              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))
+          if ((x != CastDoubleToSSizeT(ceil(gradient_vector->x1-0.5))) ||
+              (y != CastDoubleToSSizeT(ceil(gradient_vector->y1-0.5))))
             {
               offset=GetStopColorOffset(gradient,x,y);
               if (gradient->type != RadialGradient)
@@ -2118,8 +2118,8 @@ MagickExport MagickBooleanType DrawGradientImage(Image *image,
         }
         case ReflectSpread:
         {
-          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||
-              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))
+          if ((x != CastDoubleToSSizeT(ceil(gradient_vector->x1-0.5))) ||
+              (y != CastDoubleToSSizeT(ceil(gradient_vector->y1-0.5))))
             {
               offset=GetStopColorOffset(gradient,x,y);
               if (gradient->type != RadialGradient)
@@ -2160,8 +2160,8 @@ MagickExport MagickBooleanType DrawGradientImage(Image *image,
 
           antialias=MagickFalse;
           repeat=0.0;
-          if ((x != CastDoubleToLong(ceil(gradient_vector->x1-0.5))) ||
-              (y != CastDoubleToLong(ceil(gradient_vector->y1-0.5))))
+          if ((x != CastDoubleToSSizeT(ceil(gradient_vector->x1-0.5))) ||
+              (y != CastDoubleToSSizeT(ceil(gradient_vector->y1-0.5))))
             {
               offset=GetStopColorOffset(gradient,x,y);
               if (gradient->type == LinearGradient)
@@ -3457,21 +3457,21 @@ static MagickBooleanType RenderMVGContent(Image *image,
                 (void) GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 (void) GetNextToken(q,&q,extent,token);
-                bounds.x=CastDoubleToLong(ceil(GetDrawValue(token,
+                bounds.x=CastDoubleToSSizeT(ceil(GetDrawValue(token,
                   &next_token)-0.5));
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 (void) GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   (void) GetNextToken(q,&q,extent,token);
-                bounds.y=CastDoubleToLong(ceil(GetDrawValue(token,
+                bounds.y=CastDoubleToSSizeT(ceil(GetDrawValue(token,
                   &next_token)-0.5));
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 (void) GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   (void) GetNextToken(q,&q,extent,token);
-                bounds.width=(size_t) CastDoubleToLong(floor(GetDrawValue(
+                bounds.width=(size_t) CastDoubleToSSizeT(floor(GetDrawValue(
                   token,&next_token)+0.5));
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
@@ -3882,28 +3882,28 @@ static MagickBooleanType RenderMVGContent(Image *image,
         if (LocaleCompare("viewbox",keyword) == 0)
           {
             (void) GetNextToken(q,&q,extent,token);
-            graphic_context[n]->viewbox.x=CastDoubleToLong(ceil(
+            graphic_context[n]->viewbox.x=CastDoubleToSSizeT(ceil(
               GetDrawValue(token,&next_token)-0.5));
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             (void) GetNextToken(q,&q,extent,token);
             if (*token == ',')
               (void) GetNextToken(q,&q,extent,token);
-            graphic_context[n]->viewbox.y=CastDoubleToLong(ceil(
+            graphic_context[n]->viewbox.y=CastDoubleToSSizeT(ceil(
               GetDrawValue(token,&next_token)-0.5));
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             (void) GetNextToken(q,&q,extent,token);
             if (*token == ',')
               (void) GetNextToken(q,&q,extent,token);
-            graphic_context[n]->viewbox.width=(size_t) CastDoubleToLong(
+            graphic_context[n]->viewbox.width=(size_t) CastDoubleToSSizeT(
               floor(GetDrawValue(token,&next_token)+0.5));
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             (void) GetNextToken(q,&q,extent,token);
             if (*token == ',')
               (void) GetNextToken(q,&q,extent,token);
-            graphic_context[n]->viewbox.height=(size_t) CastDoubleToLong(
+            graphic_context[n]->viewbox.height=(size_t) CastDoubleToSSizeT(
               floor(GetDrawValue(token,&next_token)+0.5));
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
@@ -5017,8 +5017,8 @@ static MagickBooleanType DrawPolygonPrimitive(Image *image,
         GetPixelInfo(image,&pixel);
         for ( ; x <= stop_x; x++)
         {
-          if ((x == CastDoubleToLong(ceil(primitive_info->point.x-0.5))) &&
-              (y == CastDoubleToLong(ceil(primitive_info->point.y-0.5))))
+          if ((x == CastDoubleToSSizeT(ceil(primitive_info->point.x-0.5))) &&
+              (y == CastDoubleToSSizeT(ceil(primitive_info->point.y-0.5))))
             {
               GetFillColor(draw_info,x-start_x,y-start_y,&pixel,exception);
               SetPixelViaPixelInfo(image,&pixel,q);
@@ -5164,8 +5164,8 @@ static void LogPrimitiveInfo(const PrimitiveInfo *primitive_info)
     coordinates,
     y;
 
-  x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));
-  y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));
+  x=CastDoubleToSSizeT(ceil(primitive_info->point.x-0.5));
+  y=CastDoubleToSSizeT(ceil(primitive_info->point.y-0.5));
   switch (primitive_info->primitive)
   {
     case AlphaPrimitive:
@@ -5278,8 +5278,8 @@ MagickExport MagickBooleanType DrawPrimitive(Image *image,
       status&=SetImageMask(image,CompositePixelMask,draw_info->composite_mask,
         exception);
     }
-  x=CastDoubleToLong(ceil(primitive_info->point.x-0.5));
-  y=CastDoubleToLong(ceil(primitive_info->point.y-0.5));
+  x=CastDoubleToSSizeT(ceil(primitive_info->point.x-0.5));
+  y=CastDoubleToSSizeT(ceil(primitive_info->point.y-0.5));
   image_view=AcquireAuthenticCacheView(image,exception);
   switch (primitive_info->primitive)
   {
@@ -5557,8 +5557,8 @@ MagickExport MagickBooleanType DrawPrimitive(Image *image,
       composite_images=DestroyImageList(composite_images);
       (void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)
         NULL,(void *) NULL);
-      x1=CastDoubleToLong(ceil(primitive_info[1].point.x-0.5));
-      y1=CastDoubleToLong(ceil(primitive_info[1].point.y-0.5));
+      x1=CastDoubleToSSizeT(ceil(primitive_info[1].point.x-0.5));
+      y1=CastDoubleToSSizeT(ceil(primitive_info[1].point.y-0.5));
       if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||
           ((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))
         {
@@ -6167,7 +6167,7 @@ static MagickBooleanType TraceArcPath(MVGInfo *mvg_info,const PointInfo start,
   else
     if ((theta > 0.0) && (sweep == MagickFalse))
       theta-=2.0*MagickPI;
-  arc_segments=(size_t) CastDoubleToLong(ceil(fabs((double) (theta/(0.5*
+  arc_segments=(size_t) CastDoubleToSSizeT(ceil(fabs((double) (theta/(0.5*
     MagickPI+MagickEpsilon)))));
   status=MagickTrue;
   p=primitive_info;
@@ -7517,7 +7517,7 @@ static PrimitiveInfo *TraceStrokePolygon(const DrawInfo *draw_info,
           theta.q=atan2(box_q[2].y-center.y,box_q[2].x-center.x);
           if (theta.q < theta.p)
             theta.q+=2.0*MagickPI;
-          arc_segments=(size_t) CastDoubleToLong(ceil((double) ((theta.
+          arc_segments=(size_t) CastDoubleToSSizeT(ceil((double) ((theta.
             q-theta.p)/(2.0*sqrt(PerceptibleReciprocal(mid))))));
           CheckPathExtent(MaxStrokePad,arc_segments+MaxStrokePad);
           stroke_q[q].x=box_q[1].x;
@@ -7590,7 +7590,7 @@ static PrimitiveInfo *TraceStrokePolygon(const DrawInfo *draw_info,
           theta.q=atan2(box_p[2].y-center.y,box_p[2].x-center.x);
           if (theta.p < theta.q)
             theta.p+=2.0*MagickPI;
-          arc_segments=(size_t) CastDoubleToLong(ceil((double) ((theta.p-
+          arc_segments=(size_t) CastDoubleToSSizeT(ceil((double) ((theta.p-
             theta.q)/(2.0*sqrt((double) (1.0/mid))))));
           CheckPathExtent(arc_segments+MaxStrokePad,MaxStrokePad);
           stroke_p[p++]=box_p[1];
diff --git a/MagickCore/effect.c b/MagickCore/effect.c
index bfb1363f2..a37a1999e 100644
--- a/MagickCore/effect.c
+++ b/MagickCore/effect.c
@@ -288,7 +288,7 @@ MagickExport Image *AdaptiveBlurImage(const Image *image,const double radius,
         center,
         j;
 
-      j=CastDoubleToLong(ceil((double) width*(1.0-QuantumScale*
+      j=CastDoubleToSSizeT(ceil((double) width*(1.0-QuantumScale*
         GetPixelIntensity(edge_image,r))-0.5));
       if (j < 0)
         j=0;
@@ -609,7 +609,7 @@ MagickExport Image *AdaptiveSharpenImage(const Image *image,const double radius,
         center,
         j;
 
-      j=CastDoubleToLong(ceil((double) width*(1.0-QuantumScale*
+      j=CastDoubleToSSizeT(ceil((double) width*(1.0-QuantumScale*
         GetPixelIntensity(edge_image,r))-0.5));
       if (j < 0)
         j=0;
@@ -2402,9 +2402,9 @@ MagickExport Image *MotionBlurImage(const Image *image,const double radius,
   point.y=(double) width*cos(DegreesToRadians(angle));
   for (i=0; i < (ssize_t) width; i++)
   {
-    offset[i].x=CastDoubleToLong(ceil((double) (i*point.y)/
+    offset[i].x=CastDoubleToSSizeT(ceil((double) (i*point.y)/
       hypot(point.x,point.y)-0.5));
-    offset[i].y=CastDoubleToLong(ceil((double) (i*point.x)/
+    offset[i].y=CastDoubleToSSizeT(ceil((double) (i*point.x)/
       hypot(point.x,point.y)-0.5));
   }
   /*
diff --git a/MagickCore/gem.c b/MagickCore/gem.c
index 2c5911f67..4eb8c3fc5 100644
--- a/MagickCore/gem.c
+++ b/MagickCore/gem.c
@@ -692,7 +692,7 @@ MagickPrivate void ConvertHWBToRGB(const double hue,const double whiteness,
       *blue=QuantumRange*v;
       return;
     }
-  i=CastDoubleToLong(floor(6.0*hue));
+  i=CastDoubleToSSizeT(floor(6.0*hue));
   f=6.0*hue-i;
   if ((i & 0x01) != 0)
     f=1.0-f;
diff --git a/MagickCore/geometry.c b/MagickCore/geometry.c
index 5c6e2ad69..dd46a96fc 100644
--- a/MagickCore/geometry.c
+++ b/MagickCore/geometry.c
@@ -241,7 +241,7 @@ MagickExport MagickStatusType GetGeometry(const char *geometry,ssize_t *x,
               if (LocaleNCompare(p,"0x",2) == 0)
                 *width=(size_t) strtol(p,&p,10);
               else
-                *width=((size_t) floor(StringToDouble(p,&p)+0.5)) & 0x7fffffff;
+                *width=CastDoubleToSizeT(StringToDouble(p,&p));
             }
           if (p != q)
             flags|=WidthValue;
@@ -260,7 +260,7 @@ MagickExport MagickStatusType GetGeometry(const char *geometry,ssize_t *x,
               */
               q=p;
               if (height != (size_t *) NULL)
-                *height=((size_t) floor(StringToDouble(p,&p)+0.5)) & 0x7fffffff;
+                *height=CastDoubleToSizeT(StringToDouble(p,&p));
               if (p != q)
                 flags|=HeightValue;
             }
@@ -279,7 +279,7 @@ MagickExport MagickStatusType GetGeometry(const char *geometry,ssize_t *x,
       }
       q=p;
       if (x != (ssize_t *) NULL)
-        *x=((ssize_t) ceil(StringToDouble(p,&p)-0.5)) & 0x7fffffff;
+        *x=CastDoubleToSSizeT(StringToDouble(p,&p));
       if (p != q)
         {
           flags|=XValue;
@@ -300,7 +300,7 @@ MagickExport MagickStatusType GetGeometry(const char *geometry,ssize_t *x,
       }
       q=p;
       if (y != (ssize_t *) NULL)
-        *y=((ssize_t) ceil(StringToDouble(p,&p)-0.5)) & 0x7fffffff;
+        *y=CastDoubleToSSizeT(StringToDouble(p,&p));
       if (p != q)
         {
           flags|=YValue;
@@ -1285,8 +1285,8 @@ MagickExport MagickStatusType ParseGravityGeometry(const Image *image,
       scale.y=geometry_info.sigma;
       if ((status & SigmaValue) == 0)
         scale.y=scale.x;
-      region_info->width=(size_t) floor((scale.x*image->columns/100.0)+0.5);
-      region_info->height=(size_t) floor((scale.y*image->rows/100.0)+0.5);
+      region_info->width=CastDoubleToSizeT(scale.x*image->columns/100.0);
+      region_info->height=CastDoubleToSizeT(scale.y*image->rows/100.0);
     }
   if ((flags & AspectRatioValue) != 0)
     {
@@ -1308,13 +1308,13 @@ MagickExport MagickStatusType ParseGravityGeometry(const Image *image,
       if (geometry_ratio >= image_ratio)
         {
           region_info->width=image->columns;
-          region_info->height=(size_t) floor((double) (image->rows*image_ratio/
-            geometry_ratio)+0.5);
+          region_info->height=CastDoubleToSizeT((double) image->rows*image_ratio/
+            geometry_ratio);
         }
       else
         {
-          region_info->width=(size_t) floor((double) (image->columns*
-            geometry_ratio/image_ratio)+0.5);
+          region_info->width=CastDoubleToSizeT((double) image->columns*
+            geometry_ratio/image_ratio);
           region_info->height=image->rows;
         }
     }
@@ -1450,8 +1450,8 @@ MagickExport MagickStatusType ParseMetaGeometry(const char *geometry,ssize_t *x,
         }
       else
         {
-          *width=(size_t) floor((double) (PerceptibleReciprocal(
-            image_ratio)*former_width*geometry_ratio)+0.5);
+          *width=CastDoubleToSizeT(PerceptibleReciprocal(
+            image_ratio)*former_width*geometry_ratio);
           *height=former_height;
         }
       former_width=(*width);
diff --git a/MagickCore/image-private.h b/MagickCore/image-private.h
index 59b88fb6f..694c19d54 100644
--- a/MagickCore/image-private.h
+++ b/MagickCore/image-private.h
@@ -41,6 +41,9 @@ extern "C" {
 #define MagickSQ1_2  0.70710678118654752440084436210484903928483593768847
 #define MagickSQ2    1.41421356237309504880168872420969807856967187537695
 #define MagickSQ2PI  2.50662827463100024161235523934010416269302368164062
+#define MAGICK_SIZE_MAX  (SIZE_MAX)
+#define MAGICK_SSIZE_MAX  (SSIZE_MAX)
+#define MAGICK_SSIZE_MIN  (-(SSIZE_MAX)-1)
 #define MatteColor  "#bdbdbd"  /* gray */
 #define PSDensityGeometry  "72.0x72.0"
 #define PSPageGeometry  "612x792"
@@ -50,17 +53,6 @@ extern "C" {
 #define UndefinedCompressionQuality  0UL
 #define UndefinedTicksPerSecond  100L
 
-static inline ssize_t CastDoubleToLong(const double value)
-{
-  if (IsNaN(value) != 0)
-    return(0);
-  if (value > (double) MAGICK_SSIZE_MAX)
-    return((ssize_t) MAGICK_SSIZE_MAX);
-  if (value < (double) MAGICK_SSIZE_MIN)
-    return((ssize_t) MAGICK_SSIZE_MIN);
-  return((ssize_t) value);
-}
-
 static inline QuantumAny CastDoubleToQuantumAny(const double x)
 {
   if (IsNaN(x) != 0)
@@ -72,6 +64,29 @@ static inline QuantumAny CastDoubleToQuantumAny(const double x)
   return((QuantumAny) (x+0.5));
 }
 
+static inline size_t CastDoubleToSizeT(const double x)
+{
+  if (IsNaN(x) != 0)
+    return(0);
+  if (x > ((double) MAGICK_SIZE_MAX+0.5))
+    return((size_t) MAGICK_SIZE_MAX);
+  return((size_t) floor(x+0.5));
+}
+
+static inline ssize_t CastDoubleToSSizeT(const double x)
+{
+  if (IsNaN(x) != 0)
+    return(0);
+  if (x > ((double) MAGICK_SSIZE_MAX+0.5))
+    return((ssize_t) MAGICK_SSIZE_MAX);
+  if (x < ((double) MAGICK_SSIZE_MIN-0.5))
+    return((ssize_t) MAGICK_SSIZE_MIN);
+  if (x >= 0.0)
+    return((ssize_t) floor(x+0.5));
+  return((ssize_t) ceil(x-0.5));
+}
+
+
 static inline double DegreesToRadians(const double degrees)
 {
   return((double) (MagickPI*degrees/180.0));
diff --git a/MagickCore/image.c b/MagickCore/image.c
index 3e6fdd114..7b8caa0d2 100644
--- a/MagickCore/image.c
+++ b/MagickCore/image.c
@@ -282,21 +282,21 @@ MagickExport Image *AcquireImage(const ImageInfo *image_info,
       if ((flags & GreaterValue) != 0)
         {
           if ((double) image->delay > floor(geometry_info.rho+0.5))
-            image->delay=(size_t) CastDoubleToLong(floor(
+            image->delay=(size_t) CastDoubleToSSizeT(floor(
               geometry_info.rho+0.5));
         }
       else
         if ((flags & LessValue) != 0)
           {
             if ((double) image->delay < floor(geometry_info.rho+0.5))
-              image->ticks_per_second=CastDoubleToLong(floor(
+              image->ticks_per_second=CastDoubleToSSizeT(floor(
                 geometry_info.sigma+0.5));
           }
         else
-          image->delay=(size_t) CastDoubleToLong(floor(
+          image->delay=(size_t) CastDoubleToSSizeT(floor(
             geometry_info.rho+0.5));
       if ((flags & SigmaValue) != 0)
-        image->ticks_per_second=CastDoubleToLong(floor(
+        image->ticks_per_second=CastDoubleToSSizeT(floor(
           geometry_info.sigma+0.5));
     }
   option=GetImageOption(image_info,"dispose");
@@ -881,18 +881,18 @@ MagickExport Image *CloneImage(const Image *image,const size_t columns,
   scale=1.0;
   if (image->columns != 0)
     scale=(double) columns/(double) image->columns;
-  clone_image->page.width=(size_t) CastDoubleToLong(floor(scale*
+  clone_image->page.width=(size_t) CastDoubleToSSizeT(floor(scale*
     image->page.width+0.5));
-  clone_image->page.x=CastDoubleToLong(ceil(scale*image->page.x-0.5));
-  clone_image->tile_offset.x=CastDoubleToLong(ceil(scale*
+  clone_image->page.x=CastDoubleToSSizeT(ceil(scale*image->page.x-0.5));
+  clone_image->tile_offset.x=CastDoubleToSSizeT(ceil(scale*
     image->tile_offset.x-0.5));
   scale=1.0;
   if (image->rows != 0)
     scale=(double) rows/(double) image->rows;
-  clone_image->page.height=(size_t) CastDoubleToLong(floor(scale*
+  clone_image->page.height=(size_t) CastDoubleToSSizeT(floor(scale*
     image->page.height+0.5));
-  clone_image->page.y=CastDoubleToLong(ceil(scale*image->page.y-0.5));
-  clone_image->tile_offset.y=CastDoubleToLong(ceil(scale*
+  clone_image->page.y=CastDoubleToSSizeT(ceil(scale*image->page.y-0.5));
+  clone_image->tile_offset.y=CastDoubleToSSizeT(ceil(scale*
     image->tile_offset.y-0.5));
   clone_image->cache=ClonePixelCache(image->cache);
   if (SetImageExtent(clone_image,columns,rows,exception) == MagickFalse)
diff --git a/MagickCore/pixel.c b/MagickCore/pixel.c
index 5c1c5296f..c2aea7c1d 100644
--- a/MagickCore/pixel.c
+++ b/MagickCore/pixel.c
@@ -4515,8 +4515,8 @@ MagickExport MagickBooleanType InterpolatePixelChannel(
   status=MagickTrue;
   *pixel=0.0;
   traits=GetPixelChannelTraits(image,channel);
-  x_offset=CastDoubleToLong(floor(x));
-  y_offset=CastDoubleToLong(floor(y));
+  x_offset=CastDoubleToSSizeT(floor(x));
+  y_offset=CastDoubleToSSizeT(floor(y));
   interpolate=method;
   if (interpolate == UndefinedInterpolatePixel)
     interpolate=image->interpolate;
@@ -4533,8 +4533,8 @@ MagickExport MagickBooleanType InterpolatePixelChannel(
       if (interpolate == Average9InterpolatePixel)
         {
           count=3;
-          x_offset=CastDoubleToLong(floor(x+0.5)-1.0);
-          y_offset=CastDoubleToLong(floor(y+0.5)-1.0);
+          x_offset=CastDoubleToSSizeT(floor(x+0.5)-1.0);
+          y_offset=CastDoubleToSSizeT(floor(y+0.5)-1.0);
         }
       else
         if (interpolate == Average16InterpolatePixel)
@@ -4717,8 +4717,8 @@ MagickExport MagickBooleanType InterpolatePixelChannel(
     }
     case NearestInterpolatePixel:
     {
-      x_offset=CastDoubleToLong(floor(x+0.5));
-      y_offset=CastDoubleToLong(floor(y+0.5));
+      x_offset=CastDoubleToSSizeT(floor(x+0.5));
+      y_offset=CastDoubleToSSizeT(floor(y+0.5));
       p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);
       if (p == (const Quantum *) NULL)
         {
@@ -4935,8 +4935,8 @@ MagickExport MagickBooleanType InterpolatePixelChannels(
   assert(source->signature == MagickCoreSignature);
   assert(source_view != (CacheView *) NULL);
   status=MagickTrue;
-  x_offset=CastDoubleToLong(floor(x));
-  y_offset=CastDoubleToLong(floor(y));
+  x_offset=CastDoubleToSSizeT(floor(x));
+  y_offset=CastDoubleToSSizeT(floor(y));
   interpolate=method;
   if (interpolate == UndefinedInterpolatePixel)
     interpolate=source->interpolate;
@@ -4953,8 +4953,8 @@ MagickExport MagickBooleanType InterpolatePixelChannels(
       if (interpolate == Average9InterpolatePixel)
         {
           count=3;
-          x_offset=CastDoubleToLong(floor(x+0.5)-1.0);
-          y_offset=CastDoubleToLong(floor(y+0.5)-1.0);
+          x_offset=CastDoubleToSSizeT(floor(x+0.5)-1.0);
+          y_offset=CastDoubleToSSizeT(floor(y+0.5)-1.0);
         }
       else
         if (interpolate == Average16InterpolatePixel)
@@ -5218,8 +5218,8 @@ MagickExport MagickBooleanType InterpolatePixelChannels(
     }
     case NearestInterpolatePixel:
     {
-      x_offset=CastDoubleToLong(floor(x+0.5));
-      y_offset=CastDoubleToLong(floor(y+0.5));
+      x_offset=CastDoubleToSSizeT(floor(x+0.5));
+      y_offset=CastDoubleToSSizeT(floor(y+0.5));
       p=GetCacheViewVirtualPixels(source_view,x_offset,y_offset,1,1,exception);
       if (p == (const Quantum *) NULL)
         {
@@ -5502,8 +5502,8 @@ MagickExport MagickBooleanType InterpolatePixelInfo(const Image *image,
   assert(image->signature == MagickCoreSignature);
   assert(image_view != (CacheView *) NULL);
   status=MagickTrue;
-  x_offset=CastDoubleToLong(floor(x));
-  y_offset=CastDoubleToLong(floor(y));
+  x_offset=CastDoubleToSSizeT(floor(x));
+  y_offset=CastDoubleToSSizeT(floor(y));
   interpolate=method;
   if (interpolate == UndefinedInterpolatePixel)
     interpolate=image->interpolate;
@@ -5522,8 +5522,8 @@ MagickExport MagickBooleanType InterpolatePixelInfo(const Image *image,
       if (interpolate == Average9InterpolatePixel)
         {
           count=3;
-          x_offset=CastDoubleToLong(floor(x+0.5)-1.0);
-          y_offset=CastDoubleToLong(floor(y+0.5)-1.0);
+          x_offset=CastDoubleToSSizeT(floor(x+0.5)-1.0);
+          y_offset=CastDoubleToSSizeT(floor(y+0.5)-1.0);
         }
       else if (interpolate == Average16InterpolatePixel)
         {
@@ -5847,8 +5847,8 @@ MagickExport MagickBooleanType InterpolatePixelInfo(const Image *image,
     }
     case NearestInterpolatePixel:
     {
-      x_offset=CastDoubleToLong(floor(x+0.5));
-      y_offset=CastDoubleToLong(floor(y+0.5));
+      x_offset=CastDoubleToSSizeT(floor(x+0.5));
+      y_offset=CastDoubleToSSizeT(floor(y+0.5));
       p=GetCacheViewVirtualPixels(image_view,x_offset,y_offset,1,1,exception);
       if (p == (const Quantum *) NULL)
         {
diff --git a/MagickCore/property.c b/MagickCore/property.c
index 1b42adaee..b13fa7a17 100644
--- a/MagickCore/property.c
+++ b/MagickCore/property.c
@@ -4372,13 +4372,13 @@ MagickExport MagickBooleanType SetImageProperty(Image *image,
             if ((flags & LessValue) != 0)
               {
                 if ((double) image->delay < floor(geometry_info.rho+0.5))
-                  image->delay=CastDoubleToLong(
+                  image->delay=CastDoubleToSSizeT(
                     floor(geometry_info.sigma+0.5));
               }
             else
               image->delay=(size_t) floor(geometry_info.rho+0.5);
           if ((flags & SigmaValue) != 0)
-            image->ticks_per_second=CastDoubleToLong(floor(
+            image->ticks_per_second=CastDoubleToSSizeT(floor(
               geometry_info.sigma+0.5));
           return(MagickTrue);
         }
diff --git a/MagickCore/shear.c b/MagickCore/shear.c
index 05703ca34..62a98013e 100644
--- a/MagickCore/shear.c
+++ b/MagickCore/shear.c
@@ -163,10 +163,10 @@ static MagickBooleanType CropToFitImage(Image **image,
     if (max.y < extent[i].y)
       max.y=extent[i].y;
   }
-  geometry.x=CastDoubleToLong(ceil(min.x-0.5));
-  geometry.y=CastDoubleToLong(ceil(min.y-0.5));
-  geometry.width=(size_t) CastDoubleToLong(floor(max.x-min.x+0.5));
-  geometry.height=(size_t) CastDoubleToLong(floor(max.y-min.y+0.5));
+  geometry.x=CastDoubleToSSizeT(ceil(min.x-0.5));
+  geometry.y=CastDoubleToSSizeT(ceil(min.y-0.5));
+  geometry.width=(size_t) CastDoubleToSSizeT(floor(max.x-min.x+0.5));
+  geometry.height=(size_t) CastDoubleToSSizeT(floor(max.y-min.y+0.5));
   page=(*image)->page;
   (void) ParseAbsoluteGeometry("0x0+0+0",&(*image)->page);
   crop_image=CropImage(*image,&geometry,exception);
@@ -1217,7 +1217,7 @@ static MagickBooleanType XShearImage(Image *image,const double degrees,
         displacement*=(-1.0);
         direction=LEFT;
       }
-    step=CastDoubleToLong(floor((double) displacement));
+    step=CastDoubleToSSizeT(floor((double) displacement));
     area=(double) (displacement-step);
     step++;
     pixel=background;
@@ -1434,7 +1434,7 @@ static MagickBooleanType YShearImage(Image *image,const double degrees,
         displacement*=(-1.0);
         direction=UP;
       }
-    step=CastDoubleToLong(floor((double) displacement));
+    step=CastDoubleToSSizeT(floor((double) displacement));
     area=(double) (displacement-step);
     step++;
     pixel=background;
@@ -1617,11 +1617,11 @@ MagickExport Image *ShearImage(const Image *image,const double x_shear,
   /*
     Compute image size.
   */
-  bounds.width=image->columns+CastDoubleToLong(floor(fabs(shear.x)*
+  bounds.width=image->columns+CastDoubleToSSizeT(floor(fabs(shear.x)*
     image->rows+0.5));
-  bounds.x=CastDoubleToLong(ceil((double) image->columns+((fabs(shear.x)*
+  bounds.x=CastDoubleToSSizeT(ceil((double) image->columns+((fabs(shear.x)*
     image->rows)-image->columns)/2.0-0.5));
-  bounds.y=CastDoubleToLong(ceil((double) image->rows+((fabs(shear.y)*
+  bounds.y=CastDoubleToSSizeT(ceil((double) image->rows+((fabs(shear.y)*
     bounds.width)-image->rows)/2.0-0.5));
   /*
     Surround image with border.
@@ -1770,9 +1770,9 @@ MagickExport Image *ShearRotateImage(const Image *image,const double degrees,
   bounds.height=(size_t) floor(fabs((double) bounds.width*shear.y)+height+0.5);
   shear_width=(size_t) floor(fabs((double) bounds.height*shear.x)+
     bounds.width+0.5);
-  bounds.x=CastDoubleToLong(floor((double) ((shear_width > bounds.width) ?
+  bounds.x=CastDoubleToSSizeT(floor((double) ((shear_width > bounds.width) ?
     width : bounds.width-shear_width+2)/2.0+0.5));
-  bounds.y=CastDoubleToLong(floor(((double) bounds.height-height+2)/2.0+0.5));
+  bounds.y=CastDoubleToSSizeT(floor(((double) bounds.height-height+2)/2.0+0.5));
   /*
     Surround image with a border.
   */
diff --git a/MagickCore/studio.h b/MagickCore/studio.h
index fbdcc2d00..a0e8a9a1a 100644
--- a/MagickCore/studio.h
+++ b/MagickCore/studio.h
@@ -350,8 +350,6 @@ extern int vsnprintf(char *,size_t,const char *,va_list);
   Magick defines.
 */
 #define MagickMaxRecursionDepth  600
-#define MAGICK_SSIZE_MAX  (SSIZE_MAX)
-#define MAGICK_SSIZE_MIN  (-(SSIZE_MAX)-1)
 #define Swap(x,y) ((x)^=(y), (y)^=(x), (x)^=(y))
 #if defined(_MSC_VER)
 # define DisableMSCWarning(nr) __pragma(warning(push)) \
diff --git a/MagickCore/transform.c b/MagickCore/transform.c
index 385d5eb68..6afe0a3de 100644
--- a/MagickCore/transform.c
+++ b/MagickCore/transform.c
@@ -773,8 +773,8 @@ static inline ssize_t PixelRoundOffset(double x)
     Round the fraction to nearest integer.
   */
   if ((x-floor(x)) < (ceil(x)-x))
-    return(CastDoubleToLong(floor(x)));
-  return(CastDoubleToLong(ceil(x)));
+    return(CastDoubleToSSizeT(floor(x)));
+  return(CastDoubleToSSizeT(ceil(x)));
 }
 
 MagickExport Image *CropImageToTiles(const Image *image,
diff --git a/MagickCore/visual-effects.c b/MagickCore/visual-effects.c
index 789660231..069904a08 100644
--- a/MagickCore/visual-effects.c
+++ b/MagickCore/visual-effects.c
@@ -1439,8 +1439,8 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
       */
       depth--;
       attenuate++;
-      x_mid=CastDoubleToLong(ceil((segment->x1+segment->x2)/2-0.5));
-      y_mid=CastDoubleToLong(ceil((segment->y1+segment->y2)/2-0.5));
+      x_mid=CastDoubleToSSizeT(ceil((segment->x1+segment->x2)/2-0.5));
+      y_mid=CastDoubleToSSizeT(ceil((segment->y1+segment->y2)/2-0.5));
       local_info=(*segment);
       local_info.x2=(double) x_mid;
       local_info.y2=(double) y_mid;
@@ -1463,8 +1463,8 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
         &local_info,attenuate,depth,exception);
       return(status == 0 ? MagickFalse : MagickTrue);
     }
-  x_mid=CastDoubleToLong(ceil((segment->x1+segment->x2)/2-0.5));
-  y_mid=CastDoubleToLong(ceil((segment->y1+segment->y2)/2-0.5));
+  x_mid=CastDoubleToSSizeT(ceil((segment->x1+segment->x2)/2-0.5));
+  y_mid=CastDoubleToSSizeT(ceil((segment->y1+segment->y2)/2-0.5));
   if ((fabs(segment->x1-x_mid) < MagickEpsilon) &&
       (fabs(segment->x2-x_mid) < MagickEpsilon) &&
       (fabs(segment->y1-y_mid) < MagickEpsilon) &&
@@ -1481,10 +1481,10 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
       /*
         Left pixel.
       */
-      x=CastDoubleToLong(ceil(segment->x1-0.5));
-      u=GetCacheViewVirtualPixels(u_view,x,CastDoubleToLong(ceil(
+      x=CastDoubleToSSizeT(ceil(segment->x1-0.5));
+      u=GetCacheViewVirtualPixels(u_view,x,CastDoubleToSSizeT(ceil(
         segment->y1-0.5)),1,1,exception);
-      v=GetCacheViewVirtualPixels(v_view,x,CastDoubleToLong(ceil(
+      v=GetCacheViewVirtualPixels(v_view,x,CastDoubleToSSizeT(ceil(
         segment->y2-0.5)),1,1,exception);
       q=QueueCacheViewAuthenticPixels(image_view,x,y_mid,1,1,exception);
       if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
@@ -1504,10 +1504,10 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
           /*
             Right pixel.
           */
-          x=CastDoubleToLong(ceil(segment->x2-0.5));
-          u=GetCacheViewVirtualPixels(u_view,x,CastDoubleToLong(ceil(
+          x=CastDoubleToSSizeT(ceil(segment->x2-0.5));
+          u=GetCacheViewVirtualPixels(u_view,x,CastDoubleToSSizeT(ceil(
             segment->y1-0.5)),1,1,exception);
-          v=GetCacheViewVirtualPixels(v_view,x,CastDoubleToLong(ceil(
+          v=GetCacheViewVirtualPixels(v_view,x,CastDoubleToSSizeT(ceil(
             segment->y2-0.5)),1,1,exception);
           q=QueueCacheViewAuthenticPixels(image_view,x,y_mid,1,1,exception);
           if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
@@ -1533,10 +1533,10 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
           /*
             Bottom pixel.
           */
-          y=CastDoubleToLong(ceil(segment->y2-0.5));
-          u=GetCacheViewVirtualPixels(u_view,CastDoubleToLong(ceil(
+          y=CastDoubleToSSizeT(ceil(segment->y2-0.5));
+          u=GetCacheViewVirtualPixels(u_view,CastDoubleToSSizeT(ceil(
             segment->x1-0.5)),y,1,1,exception);
-          v=GetCacheViewVirtualPixels(v_view,CastDoubleToLong(ceil(
+          v=GetCacheViewVirtualPixels(v_view,CastDoubleToSSizeT(ceil(
             segment->x2-0.5)),y,1,1,exception);
           q=QueueCacheViewAuthenticPixels(image_view,x_mid,y,1,1,exception);
           if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
@@ -1557,10 +1557,10 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
           /*
             Top pixel.
           */
-          y=CastDoubleToLong(ceil(segment->y1-0.5));
-          u=GetCacheViewVirtualPixels(u_view,CastDoubleToLong(ceil(
+          y=CastDoubleToSSizeT(ceil(segment->y1-0.5));
+          u=GetCacheViewVirtualPixels(u_view,CastDoubleToSSizeT(ceil(
             segment->x1-0.5)),y,1,1,exception);
-          v=GetCacheViewVirtualPixels(v_view,CastDoubleToLong(ceil(
+          v=GetCacheViewVirtualPixels(v_view,CastDoubleToSSizeT(ceil(
             segment->x2-0.5)),y,1,1,exception);
           q=QueueCacheViewAuthenticPixels(image_view,x_mid,y,1,1,exception);
           if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
@@ -1583,11 +1583,11 @@ static MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,
       /*
         Middle pixel.
       */
-      x=CastDoubleToLong(ceil(segment->x1-0.5));
-      y=CastDoubleToLong(ceil(segment->y1-0.5));
+      x=CastDoubleToSSizeT(ceil(segment->x1-0.5));
+      y=CastDoubleToSSizeT(ceil(segment->y1-0.5));
       u=GetCacheViewVirtualPixels(u_view,x,y,1,1,exception);
-      x=CastDoubleToLong(ceil(segment->x2-0.5));
-      y=CastDoubleToLong(ceil(segment->y2-0.5));
+      x=CastDoubleToSSizeT(ceil(segment->x2-0.5));
+      y=CastDoubleToSSizeT(ceil(segment->y2-0.5));
       v=GetCacheViewVirtualPixels(v_view,x,y,1,1,exception);
       q=QueueCacheViewAuthenticPixels(image_view,x_mid,y_mid,1,1,exception);
       if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||
diff --git a/MagickWand/drawing-wand.c b/MagickWand/drawing-wand.c
index cc1fbc640..002798ba0 100644
--- a/MagickWand/drawing-wand.c
+++ b/MagickWand/drawing-wand.c
@@ -4285,10 +4285,10 @@ WandExport MagickBooleanType DrawPushPattern(DrawingWand *wand,
     x,y,width,height);
   wand->indent_depth++;
   wand->pattern_id=AcquireString(pattern_id);
-  wand->pattern_bounds.x=CastDoubleToLong(ceil(x-0.5));
-  wand->pattern_bounds.y=CastDoubleToLong(ceil(y-0.5));
-  wand->pattern_bounds.width=(size_t) CastDoubleToLong(floor(width+0.5));
-  wand->pattern_bounds.height=(size_t) CastDoubleToLong(floor(height+0.5));
+  wand->pattern_bounds.x=CastDoubleToSSizeT(ceil(x-0.5));
+  wand->pattern_bounds.y=CastDoubleToSSizeT(ceil(y-0.5));
+  wand->pattern_bounds.width=(size_t) CastDoubleToSSizeT(floor(width+0.5));
+  wand->pattern_bounds.height=(size_t) CastDoubleToSSizeT(floor(height+0.5));
   wand->pattern_offset=wand->mvg_length;
   return(MagickTrue);
 }
diff --git a/MagickWand/studio.h b/MagickWand/studio.h
index 3dcb4d304..4daf7e894 100644
--- a/MagickWand/studio.h
+++ b/MagickWand/studio.h
@@ -305,8 +305,6 @@ extern int vsnprintf(char *,size_t,const char *,va_list);
 /*
   Magick defines.
 */
-#define MAGICK_SSIZE_MAX  (SSIZE_MAX)
-#define MAGICK_SSIZE_MIN  (-(SSIZE_MAX)-1)
 #if defined(_MSC_VER)
 # define DisableMSCWarning(nr) __pragma(warning(push)) \
   __pragma(warning(disable:nr))
diff --git a/coders/histogram.c b/coders/histogram.c
index 0df364c12..15ee9772d 100644
--- a/coders/histogram.c
+++ b/coders/histogram.c
@@ -295,7 +295,7 @@ static MagickBooleanType WriteHISTOGRAMImage(const ImageInfo *image_info,
       break;
     if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
       {
-        y=CastDoubleToLong(ceil((double) histogram_image->rows-scale*
+        y=CastDoubleToSSizeT(ceil((double) histogram_image->rows-scale*
           histogram[x].red-0.5));
         r=q+y*GetPixelChannels(histogram_image);
         for ( ; y < (ssize_t) histogram_image->rows; y++)
@@ -306,7 +306,7 @@ static MagickBooleanType WriteHISTOGRAMImage(const ImageInfo *image_info,
       }
     if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
       {
-        y=CastDoubleToLong(ceil((double) histogram_image->rows-scale*
+        y=CastDoubleToSSizeT(ceil((double) histogram_image->rows-scale*
           histogram[x].green-0.5));
         r=q+y*GetPixelChannels(histogram_image);
         for ( ; y < (ssize_t) histogram_image->rows; y++)
@@ -317,7 +317,7 @@ static MagickBooleanType WriteHISTOGRAMImage(const ImageInfo *image_info,
       }
     if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
       {
-        y=CastDoubleToLong(ceil((double) histogram_image->rows-scale*
+        y=CastDoubleToSSizeT(ceil((double) histogram_image->rows-scale*
           histogram[x].blue-0.5));
         r=q+y*GetPixelChannels(histogram_image);
         for ( ; y < (ssize_t) histogram_image->rows; y++)
diff --git a/coders/jpeg.c b/coders/jpeg.c
index db385358b..d779644ab 100644
--- a/coders/jpeg.c
+++ b/coders/jpeg.c
@@ -2325,7 +2325,8 @@ static MagickBooleanType WriteJPEGImage_(const ImageInfo *image_info,
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       "Image resolution: %.20g,%.20g",image->resolution.x,image->resolution.y);
-  if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))
+  if ((image->resolution.x >= 0) && (image->resolution.x < (double) SHRT_MAX) &&
+      (image->resolution.y >= 0) && (image->resolution.y < (double) SHRT_MAX))
     {
       /*
         Set image resolution.
diff --git a/coders/png.c b/coders/png.c
index e730edb03..6f88e9cdc 100644
--- a/coders/png.c
+++ b/coders/png.c
@@ -10020,23 +10020,23 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
         {
           ping_pHYs_unit_type=PNG_RESOLUTION_METER;
           ping_pHYs_x_resolution=
-             (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);
+             (png_uint_32) CastDoubleToSizeT((100.0*image->resolution.x+0.5)/2.54);
           ping_pHYs_y_resolution=
-             (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);
+             (png_uint_32) CastDoubleToSizeT((100.0*image->resolution.y+0.5)/2.54);
         }
 
       else if (image->units == PixelsPerCentimeterResolution)
         {
           ping_pHYs_unit_type=PNG_RESOLUTION_METER;
-          ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);
-          ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);
+          ping_pHYs_x_resolution=(png_uint_32) CastDoubleToSizeT(100.0*image->resolution.x+0.5);
+          ping_pHYs_y_resolution=(png_uint_32) CastDoubleToSizeT(100.0*image->resolution.y+0.5);
         }
 
       else
         {
           ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;
-          ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;
-          ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;
+          ping_pHYs_x_resolution=(png_uint_32) CastDoubleToSizeT(image->resolution.x);
+          ping_pHYs_y_resolution=(png_uint_32) CastDoubleToSizeT(image->resolution.y);
         }
 
       if (logging != MagickFalse)
diff --git a/coders/tiff.c b/coders/tiff.c
index 68a6d5b09..a0bdd6313 100644
--- a/coders/tiff.c
+++ b/coders/tiff.c
@@ -1506,9 +1506,9 @@ static Image *ReadTIFFImage(const ImageInfo *image_info,
     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))
       {
-        image->page.x=CastDoubleToLong(ceil(x_position*
+        image->page.x=CastDoubleToSSizeT(ceil(x_position*
           image->resolution.x-0.5));
-        image->page.y=CastDoubleToLong(ceil(y_position*
+        image->page.y=CastDoubleToSSizeT(ceil(y_position*
           image->resolution.y-0.5));
       }
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)
diff --git a/coders/txt.c b/coders/txt.c
index f8312a4fd..91323583d 100644
--- a/coders/txt.c
+++ b/coders/txt.c
@@ -273,7 +273,7 @@ static Image *ReadTEXTImage(const ImageInfo *image_info,
       draw_info=DestroyDrawInfo(draw_info);
       ThrowReaderException(TypeError,"UnableToGetTypeMetrics");
     }
-  page.y=CastDoubleToLong(ceil((double) page.y+metrics.ascent-0.5));
+  page.y=CastDoubleToSSizeT(ceil((double) page.y+metrics.ascent-0.5));
   (void) FormatLocaleString(geometry,MagickPathExtent,"%gx%g%+g%+g",(double)
     image->columns,(double) image->rows,(double) page.x,(double) page.y);
   (void) CloneString(&draw_info->geometry,geometry);
@@ -574,7 +574,7 @@ static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
           black),range);
         pixel.alpha=(MagickRealType) ScaleAnyToQuantum(CastDoubleToQuantumAny(
           alpha),range);
-        q=GetAuthenticPixels(image,CastDoubleToLong(x_offset),CastDoubleToLong(
+        q=GetAuthenticPixels(image,CastDoubleToSSizeT(x_offset),CastDoubleToSSizeT(
           y_offset),1,1,exception);
         if (q == (Quantum *) NULL)
           {
-- 
2.34.1

