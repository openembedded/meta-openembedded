From 92781533fc4afab67447e8e6d47a649383179c44 Mon Sep 17 00:00:00 2001
From: rakshasa <sundell.software@gmail.com>
Date: Sun, 20 Jun 2021 18:10:52 +0900
Subject: [PATCH] Detect ip address.

---
 src/net/local_addr.cc                   |   6 +-
 src/torrent/Makefile.am                 |   5 +-
 src/torrent/net/fd.cc                   |   3 +
 src/torrent/net/fd.h                    |  14 ++--
 src/torrent/net/socket_address.cc       |   2 +-
 src/torrent/net/socket_address.h        |   2 +-
 src/torrent/net/utils.cc                | 104 ++++++++++++++++++++++++
 src/torrent/net/utils.h                 |   9 ++
 src/tracker/tracker_http.cc             | 104 ++++++++----------------
 test/helpers/network.h                  |   2 +
 test/torrent/net/test_fd.cc             |   9 ++
 test/torrent/net/test_socket_address.cc |   2 +-
 12 files changed, 181 insertions(+), 81 deletions(-)
 create mode 100755 src/torrent/net/utils.cc
 create mode 100755 src/torrent/net/utils.h

diff --git a/src/net/local_addr.cc b/src/net/local_addr.cc
index 24413265..0c7116cb 100644
--- a/src/net/local_addr.cc
+++ b/src/net/local_addr.cc
@@ -34,6 +34,8 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
+// TODO: Remove.
+
 #include "config.h"
 
 #include <stdio.h>
@@ -241,7 +243,7 @@ bool get_local_address(sa_family_t family, rak::socket_address *address) {
       int plen = IFA_PAYLOAD(nlmsg);
       for (const rtattr *rta = IFA_RTA(ifa);
            RTA_OK(rta, plen);
-	   rta = RTA_NEXT(rta, plen)) {
+           rta = RTA_NEXT(rta, plen)) {
         if (rta->rta_type != IFA_LOCAL &&
             rta->rta_type != IFA_ADDRESS) {
           continue;
@@ -303,7 +305,7 @@ get_local_address(sa_family_t family, rak::socket_address *address) {
     dummy_dest.set_address_c_str("4.0.0.0"); 
     break;
   case rak::socket_address::af_inet6:
-    dummy_dest.set_address_c_str("2001:700::"); 
+    dummy_dest.set_address_c_str("2001:1::");
     break;
   default:
     throw internal_error("Unknown address family");
diff --git a/src/torrent/Makefile.am b/src/torrent/Makefile.am
index 30157b95..5de7e8ae 100644
--- a/src/torrent/Makefile.am
+++ b/src/torrent/Makefile.am
@@ -46,6 +46,8 @@ libtorrent_torrent_la_SOURCES = \
 	net/socket_event.cc \
 	net/socket_event.h \
 	net/types.h \
+	net/utils.cc \
+	net/utils.h \
 \
 	peer/choke_status.h \
 	peer/client_info.cc \
@@ -167,7 +169,8 @@ libtorrent_torrent_net_include_HEADERS = \
 	net/socket_address.h \
 	net/socket_address_key.h \
 	net/socket_event.h \
-	net/types.h
+	net/types.h \
+	net/utils.h
 
 libtorrent_torrent_peer_includedir = $(includedir)/torrent/peer
 libtorrent_torrent_peer_include_HEADERS = \
diff --git a/src/torrent/net/fd.cc b/src/torrent/net/fd.cc
index 07c91779..6d228181 100644
--- a/src/torrent/net/fd.cc
+++ b/src/torrent/net/fd.cc
@@ -64,6 +64,9 @@ fd_open(fd_flags flags) {
   if ((flags & fd_flag_stream)) {
     domain = SOCK_STREAM;
     protocol = IPPROTO_TCP;
+  } else if ((flags & fd_flag_datagram)) {
+    domain = SOCK_DGRAM;
+    protocol = IPPROTO_UDP;
   } else {
     LT_LOG_FLAG("fd_open missing socket type");
     errno = EINVAL;
diff --git a/src/torrent/net/fd.h b/src/torrent/net/fd.h
index a7094646..6ab3302d 100644
--- a/src/torrent/net/fd.h
+++ b/src/torrent/net/fd.h
@@ -9,11 +9,12 @@ namespace torrent {
 
 enum fd_flags : int {
   fd_flag_stream = 0x1,
-  fd_flag_nonblock = 0x10,
-  fd_flag_reuse_address = 0x20,
-  fd_flag_v4only = 0x40,
-  fd_flag_v6only = 0x80,
-  fd_flag_all = 0xff,
+  fd_flag_datagram = 0x10,
+  fd_flag_nonblock = 0x20,
+  fd_flag_reuse_address = 0x40,
+  fd_flag_v4only = 0x80,
+  fd_flag_v6only = 0x100,
+  fd_flag_all = 0x1ff,
 };
 
 constexpr bool fd_valid_flags(fd_flags flags);
@@ -53,7 +54,8 @@ operator |=(fd_flags& lhs, fd_flags rhs) {
 constexpr bool
 fd_valid_flags(fd_flags flags) {
   return
-    (flags & fd_flag_stream) &&
+    ((flags & fd_flag_stream) || (flags & fd_flag_datagram)) &&
+    !((flags & fd_flag_stream) && (flags & fd_flag_datagram)) &&
     !((flags & fd_flag_v4only) && (flags & fd_flag_v6only)) &&
     !(flags & ~(fd_flag_all));
 }
diff --git a/src/torrent/net/socket_address.cc b/src/torrent/net/socket_address.cc
index c36ba0ae..078bee25 100644
--- a/src/torrent/net/socket_address.cc
+++ b/src/torrent/net/socket_address.cc
@@ -135,7 +135,7 @@ sa_unique_ptr
 sa_make_unspec() {
   sa_unique_ptr sa(new sockaddr);
 
-  std::memset(sa.get(), 0, sizeof(sa));
+  std::memset(sa.get(), 0, sizeof(sockaddr));
   sa.get()->sa_family = AF_UNSPEC;
 
   return sa;
diff --git a/src/torrent/net/socket_address.h b/src/torrent/net/socket_address.h
index f64aee68..b9586ca1 100644
--- a/src/torrent/net/socket_address.h
+++ b/src/torrent/net/socket_address.h
@@ -102,8 +102,8 @@ bool fd_sap_equal(const fd_sap_tuple& lhs, const fd_sap_tuple& rhs) LIBTORRENT_E
 
 inline bool sap_is_unspec(const sa_unique_ptr& sap) { return sa_is_unspec(sap.get()); }
 inline bool sap_is_unspec(const c_sa_unique_ptr& sap) { return sa_is_unspec(sap.get()); }
-inline bool sap_is_inet(const c_sa_unique_ptr& sap) { return sa_is_inet(sap.get()); }
 inline bool sap_is_inet(const sa_unique_ptr& sap) { return sa_is_inet(sap.get()); }
+inline bool sap_is_inet(const c_sa_unique_ptr& sap) { return sa_is_inet(sap.get()); }
 inline bool sap_is_inet6(const sa_unique_ptr& sap) { return sa_is_inet6(sap.get()); }
 inline bool sap_is_inet6(const c_sa_unique_ptr& sap) { return sa_is_inet6(sap.get()); }
 inline bool sap_is_inet_inet6(const sa_unique_ptr& sap) { return sa_is_inet_inet6(sap.get()); }
diff --git a/src/torrent/net/utils.cc b/src/torrent/net/utils.cc
new file mode 100755
index 00000000..4cb85924
--- /dev/null
+++ b/src/torrent/net/utils.cc
@@ -0,0 +1,104 @@
+#import <torrent/net/utils.h>
+
+#import <cerrno>
+#import <cstring>
+#import <torrent/net/fd.h>
+#import <torrent/net/socket_address.h>
+#import <torrent/utils/log.h>
+
+#define LT_LOG_ERROR(log_fmt)                                           \
+  lt_log_print(LOG_CONNECTION_FD, "fd: " log_fmt " (errno:%i message:'%s')", \
+               errno, std::strerror(errno));
+#define LT_LOG_FD(log_fmt)                                              \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt, fd);
+#define LT_LOG_FD_ERROR(log_fmt)                                        \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (errno:%i message:'%s')", \
+               fd, errno, std::strerror(errno));
+#define LT_LOG_FD_SIN(log_fmt)                                        \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (address:%s)", \
+               fd, sin_pretty_str(sa.get()).c_str());
+#define LT_LOG_FD_SIN6(log_fmt)                                       \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (address:%s)", \
+               fd, sin6_pretty_str(sa.get()).c_str());
+
+namespace torrent {
+
+auto detect_local_sin_addr() -> sin_unique_ptr {
+  int fd = fd_open(fd_flag_v4only | fd_flag_datagram);
+  if (fd == -1) {
+    LT_LOG_ERROR("detect_local_sin_addr: open failed");
+    return sin_unique_ptr();
+  }
+
+  // TODO: Check if unique_ptr works.
+  std::shared_ptr<void> _fd(nullptr, [fd](...){ fd_close(fd); });
+
+  auto connectAddress = sin_make();
+  connectAddress.get()->sin_addr.s_addr = htonl(0x04000001);
+  connectAddress.get()->sin_port = 80;
+
+  if (!fd_connect(fd, reinterpret_cast<sockaddr*>(connectAddress.get())) && errno != EINPROGRESS) {
+    LT_LOG_FD_ERROR("detect_local_sin_addr: connect failed");
+    return sin_unique_ptr();
+  }
+
+  // TODO: Make sa function.
+  socklen_t socklen = sizeof(sockaddr_in);
+
+  auto sa = sin_make();
+
+  if (::getsockname(fd, reinterpret_cast<sockaddr*>(sa.get()), &socklen) != 0) {
+    LT_LOG_FD_ERROR("detect_local_sin_addr: getsockname failed");
+    return sin_unique_ptr();
+  }
+  if (socklen != sizeof(sockaddr_in)) {
+    LT_LOG_FD("detect_local_sin_addr: getsockname failed, invalid socklen");
+    return sin_unique_ptr();
+  }
+
+  LT_LOG_FD_SIN("detect_local_sin_addr: success");
+
+  return sa;
+}
+
+auto detect_local_sin6_addr() -> sin6_unique_ptr {
+  int fd = fd_open(fd_flag_v6only | fd_flag_datagram);
+  if (fd == -1) {
+    LT_LOG_ERROR("detect_local_sin6_addr: open failed");
+    return sin6_unique_ptr();
+  }
+
+  // TODO: Check if unique_ptr works.
+  std::shared_ptr<void> _fd(nullptr, [fd](...){ fd_close(fd); });
+
+  auto connectAddress = sin6_make();
+  connectAddress.get()->sin6_addr.s6_addr[0] = 0x20;
+  connectAddress.get()->sin6_addr.s6_addr[1] = 0x01;
+  connectAddress.get()->sin6_addr.s6_addr[15] = 0x01;
+  connectAddress.get()->sin6_port = 80;
+
+  if (!fd_connect(fd, reinterpret_cast<sockaddr*>(connectAddress.get())) && errno != EINPROGRESS) {
+    LT_LOG_FD_ERROR("detect_local_sin6_addr: connect failed");
+    return sin6_unique_ptr();
+  }
+
+  // TODO: Make sa function.
+  socklen_t socklen = sizeof(sockaddr_in6);
+
+  auto sa = sin6_make();
+
+  if (::getsockname(fd, reinterpret_cast<sockaddr*>(sa.get()), &socklen) != 0) {
+    LT_LOG_FD_ERROR("detect_local_sin6_addr: getsockname failed");
+    return sin6_unique_ptr();
+  }
+  if (socklen != sizeof(sockaddr_in6)) {
+    LT_LOG_FD("detect_local_sin6_addr: getsockname failed, invalid socklen");
+    return sin6_unique_ptr();
+  }
+
+  LT_LOG_FD_SIN6("detect_local_sin6_addr: success");
+
+  return sa;
+}
+
+}
diff --git a/src/torrent/net/utils.h b/src/torrent/net/utils.h
new file mode 100755
index 00000000..1d550c51
--- /dev/null
+++ b/src/torrent/net/utils.h
@@ -0,0 +1,9 @@
+#import <torrent/common.h>
+#import <torrent/net/socket_address.h>
+
+namespace torrent {
+
+auto detect_local_sin_addr() -> sin_unique_ptr;
+auto detect_local_sin6_addr() -> sin6_unique_ptr;
+
+}
diff --git a/src/tracker/tracker_http.cc b/src/tracker/tracker_http.cc
index 1bf94107..de3a39ab 100644
--- a/src/tracker/tracker_http.cc
+++ b/src/tracker/tracker_http.cc
@@ -1,63 +1,29 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
-#include "config.h"
+#import "config.h"
 
 #define __STDC_FORMAT_MACROS
 
-#include <iomanip>
-#include <sstream>
-#include <rak/functional.h>
-#include <rak/string_manip.h>
-
-#include "net/address_list.h"
-#include "net/local_addr.h"
-#include "torrent/connection_manager.h"
-#include "torrent/download_info.h"
-#include "torrent/exceptions.h"
-#include "torrent/http.h"
-#include "torrent/object_stream.h"
-#include "torrent/tracker_list.h"
-#include "torrent/utils/log.h"
-#include "torrent/utils/option_strings.h"
-
-#include "tracker_http.h"
-
-#include "globals.h"
-#include "manager.h"
+#import <iomanip>
+#import <sstream>
+#import <rak/functional.h>
+#import <rak/string_manip.h>
+
+#import "net/address_list.h"
+#import "net/local_addr.h"
+#import "torrent/connection_manager.h"
+#import "torrent/download_info.h"
+#import "torrent/exceptions.h"
+#import "torrent/http.h"
+#import "torrent/net/utils.h"
+#import "torrent/net/socket_address.h"
+#import "torrent/object_stream.h"
+#import "torrent/tracker_list.h"
+#import "torrent/utils/log.h"
+#import "torrent/utils/option_strings.h"
+
+#import "tracker_http.h"
+
+#import "globals.h"
+#import "manager.h"
 
 #define LT_LOG_TRACKER(log_level, log_fmt, ...)                         \
   lt_log_print_info(LOG_TRACKER_##log_level, m_parent->info(), "tracker", "[%u] " log_fmt, group(), __VA_ARGS__);
@@ -142,19 +108,19 @@ TrackerHttp::send_state(int state) {
 
   const rak::socket_address* localAddress = rak::socket_address::cast_from(manager->connection_manager()->local_address());
 
-  if (!localAddress->is_address_any())
-    s << "&ip=" << localAddress->address_str();
-  
-  if (localAddress->is_address_any() && localAddress->family() == rak::socket_address::pf_inet) {
-    rak::socket_address local_v6;
-    if (get_local_address(rak::socket_address::af_inet6, &local_v6))
-      s << "&ipv6=" << rak::copy_escape_html(local_v6.address_str());
-  }
+  if (localAddress->is_address_any()) {
+    auto ipv4_address = detect_local_sin_addr();
+    auto ipv6_address = detect_local_sin6_addr();
 
-  if (localAddress->is_address_any() && localAddress->family() == rak::socket_address::pf_inet6) {
-    rak::socket_address local_v4;
-    if (get_local_address(rak::socket_address::af_inet, &local_v4))
-      s << "&ipv4=" << local_v4.address_str();
+    if (ipv4_address != nullptr) {
+      s << "&ipv4=" << sin_addr_str(ipv4_address.get());
+    }
+    if (ipv6_address != nullptr) {
+      s << "&ipv6=" << sin6_addr_str(ipv6_address.get());
+    }
+
+  } else {
+    s << "&ip=" << localAddress->address_str();
   }
 
   if (info->is_compact())
diff --git a/test/helpers/network.h b/test/helpers/network.h
index 6cf2f870..eb188426 100644
--- a/test/helpers/network.h
+++ b/test/helpers/network.h
@@ -112,6 +112,7 @@ wrap_ai_get_first_sa(const char* nodename, const char* servname = nullptr, const
 
   CPPUNIT_ASSERT_MESSAGE(("wrap_ai_get_first_sa: nodename:'" + std::string(nodename) + "'").c_str(),
                         sa != nullptr);
+
   return sa;
 }
 
@@ -121,6 +122,7 @@ wrap_ai_get_first_c_sa(const char* nodename, const char* servname = nullptr, con
 
   CPPUNIT_ASSERT_MESSAGE(("wrap_ai_get_first_sa: nodename:'" + std::string(nodename) + "'").c_str(),
                         sa != nullptr);
+
   return torrent::c_sa_unique_ptr(sa.release());
 }
 
diff --git a/test/torrent/net/test_fd.cc b/test/torrent/net/test_fd.cc
index 5e56f0f3..0a00ccd4 100644
--- a/test/torrent/net/test_fd.cc
+++ b/test/torrent/net/test_fd.cc
@@ -9,13 +9,22 @@ CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(test_fd, "torrent/net");
 void
 test_fd::test_valid_flags() {
   CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream));
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_datagram));
+  CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_datagram));
+
   CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_nonblock));
   CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_reuse_address));
   CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_v4only));
   CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_v6only));
 
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_datagram | torrent::fd_flag_nonblock));
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_datagram | torrent::fd_flag_reuse_address));
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_datagram | torrent::fd_flag_v4only));
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_datagram | torrent::fd_flag_v6only));
+
   CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flag_v4only | torrent::fd_flag_v6only));
   CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_v4only | torrent::fd_flag_v6only));
+  CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flag_datagram | torrent::fd_flag_v4only | torrent::fd_flag_v6only));
 
   CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flags()));
   CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flags(~torrent::fd_flag_all)));
diff --git a/test/torrent/net/test_socket_address.cc b/test/torrent/net/test_socket_address.cc
index 8a1b0c8a..a27b38bc 100644
--- a/test/torrent/net/test_socket_address.cc
+++ b/test/torrent/net/test_socket_address.cc
@@ -83,7 +83,7 @@ test_socket_address::test_make() {
   CPPUNIT_ASSERT(sin6_inet6->sin6_family == AF_INET6);
   CPPUNIT_ASSERT(sin6_inet6->sin6_port == 0);
   CPPUNIT_ASSERT(sin6_inet6->sin6_flowinfo == 0);
-  CPPUNIT_ASSERT(compare_sin6_addr(sin6_inet6->sin6_addr, in6_addr{0}));
+  CPPUNIT_ASSERT(compare_sin6_addr(sin6_inet6->sin6_addr, (in6_addr{0})));
   CPPUNIT_ASSERT(sin6_inet6->sin6_scope_id == 0);
 
   torrent::sa_unique_ptr sa_unix = torrent::sa_make_unix("");
