From b0f945e11d6afe43c917b58291c6fbcf5468a908 Mon Sep 17 00:00:00 2001
From: Jari Sundell <sundell.software@gmail.com>
Date: Fri, 23 Aug 2019 23:23:48 +0900
Subject: [PATCH] Backport changes from feature-bind. (#200)

---
 .dir-locals.el                                |   7 +
 Makefile.am                                   |   1 +
 configure.ac                                  |  40 +-
 extra/corrupt_file.cc                         |   2 +-
 rak/file_stat.h                               |   2 +-
 rak/fs_stat.h                                 |   2 +-
 rak/partial_queue.h                           |   2 +-
 rak/path.h                                    |   2 +-
 rak/priority_queue_default.h                  |   2 +-
 rak/socket_address.h                          |  49 +-
 rak/timer.h                                   |   2 +-
 scripts/checks.m4                             |   4 +-
 scripts/rak_cxx.m4                            |  47 --
 scripts/ssl.m4                                |  38 ++
 src/data/chunk_list.cc                        |   2 -
 src/data/chunk_list.h                         |   2 +-
 src/data/chunk_list_node.h                    |   2 +-
 src/data/hash_check_queue.h                   |   2 +-
 src/data/hash_queue.cc                        |   2 -
 src/data/hash_queue.h                         |   2 +-
 src/data/hash_queue_node.h                    |   4 +-
 src/data/hash_torrent.cc                      |   2 -
 src/data/hash_torrent.h                       |   4 +-
 src/data/memory_chunk.h                       |   2 +-
 src/data/socket_file.h                        |   2 +-
 src/dht/dht_hash_map.h                        |  57 +-
 src/download/chunk_selector.h                 |   2 +-
 src/download/chunk_statistics.h               |   2 +-
 src/download/delegator.cc                     |   2 +-
 src/download/delegator.h                      |   2 +-
 src/download/download_constructor.h           |   2 +-
 src/globals.cc                                |  15 +-
 src/globals.h                                 |  36 --
 src/manager.cc                                |  36 --
 src/net/Makefile.am                           |   2 +
 src/net/data_buffer.h                         |   2 +-
 src/net/listen.cc                             |  40 +-
 src/net/listen.h                              |   4 +-
 src/net/protocol_buffer.h                     |   2 +-
 src/net/socket_base.h                         |   2 +-
 src/net/socket_fd.cc                          |  10 +
 src/net/socket_fd.h                           |   6 +
 src/net/socket_listen.cc                      | 137 +++++
 src/net/socket_listen.h                       |  46 ++
 src/net/socket_set.h                          |   2 +-
 src/net/throttle_node.h                       |   2 +-
 src/protocol/handshake.cc                     |  13 +-
 src/protocol/handshake_manager.cc             |  56 +-
 src/protocol/handshake_manager.h              |  40 +-
 src/protocol/peer_connection_base.cc          |   2 -
 src/protocol/request_list.cc                  |  38 +-
 src/torrent/Makefile.am                       |   1 +
 src/torrent/common.h                          |   5 +-
 src/torrent/connection_manager.h              |   2 +-
 src/torrent/data/download_data.h              |   2 +-
 src/torrent/data/file_list.cc                 |   2 -
 src/torrent/data/transfer_list.h              |   3 +-
 src/torrent/download.cc                       |   4 +-
 src/torrent/download/choke_group.cc           |   2 +-
 src/torrent/download/choke_group.h            |   2 +-
 src/torrent/download/choke_queue.cc           |   3 +-
 src/torrent/download/choke_queue.h            |   5 +-
 src/torrent/download/group_entry.h            |   3 +-
 src/torrent/download/resource_manager.cc      |   1 -
 src/torrent/download/resource_manager.h       |   2 +-
 src/torrent/download_info.h                   |   4 +-
 src/torrent/error.cc                          |   6 +-
 src/torrent/error.h                           |   7 +-
 src/torrent/event.cc                          |  19 +
 src/torrent/event.h                           |  82 ++-
 src/torrent/http.h                            |   2 +-
 src/torrent/net/Makefile.am                   |  18 +-
 src/torrent/net/address_info.cc               |  43 ++
 src/torrent/net/address_info.h                |  69 +++
 src/torrent/net/fd.cc                         | 209 +++++++
 src/torrent/net/fd.h                          |  63 ++
 src/torrent/net/socket_address.cc             | 559 ++++++++++++++++++
 src/torrent/net/socket_address.h              | 229 +++++++
 src/torrent/net/socket_address_key.h          |   2 +-
 src/torrent/net/socket_event.cc               |  29 +
 src/torrent/net/socket_event.h                |  31 +
 src/torrent/net/types.h                       |  33 ++
 src/torrent/object.h                          |  21 +-
 src/torrent/peer/client_list.cc               |   2 +-
 src/torrent/peer/connection_list.h            |   3 +-
 src/torrent/peer/peer_list.cc                 |   7 +-
 src/torrent/poll.h                            |   3 +-
 src/torrent/torrent.cc                        |  42 +-
 src/torrent/torrent.h                         |  11 +-
 src/torrent/tracker.h                         |   2 +-
 src/torrent/tracker_controller.h              |   3 +-
 src/torrent/tracker_list.h                    |   2 +-
 src/torrent/utils/Makefile.am                 |   5 +-
 src/torrent/utils/directory_events.h          |   3 +-
 src/torrent/utils/log.cc                      |  66 +--
 src/torrent/utils/log.h                       |  98 ++-
 src/torrent/utils/log_buffer.cc               |  55 +-
 src/torrent/utils/log_buffer.h                |  52 +-
 src/torrent/utils/net.cc                      |  72 ---
 src/torrent/utils/net.h                       |  56 --
 src/torrent/utils/option_strings.cc           |  63 +-
 src/torrent/utils/option_strings.h            |   7 +-
 src/torrent/utils/random.cc                   |  29 +
 src/torrent/utils/random.h                    |  15 +
 src/torrent/utils/ranges.h                    |   1 -
 src/torrent/utils/resume.cc                   |   2 -
 src/torrent/utils/signal_bitfield.h           |   3 +-
 src/torrent/utils/thread_base.h               |   3 +-
 src/utils/instrumentation.cc                  |   2 -
 src/utils/instrumentation.h                   |   3 +-
 src/utils/queue_buckets.h                     |   4 +-
 src/utils/sha_fast.h                          |   2 +-
 test/Makefile.am                              |  29 +-
 test/data/hash_check_queue_test.cc            |   2 +-
 test/data/hash_queue_test.cc                  |   2 +-
 test/helpers/expect_fd.h                      | 107 ++++
 test/helpers/expect_utils.h                   |  13 +
 test/helpers/mock_compare.h                   |  96 +++
 test/helpers/mock_function.cc                 | 170 ++++++
 test/helpers/mock_function.h                  | 133 +++++
 test/helpers/network.h                        | 182 ++++++
 test/helpers/progress_listener.cc             |  63 ++
 test/helpers/progress_listener.h              |  47 ++
 test/helpers/test_fixture.cc                  |  18 +
 test/helpers/test_fixture.h                   |  14 +
 test/helpers/utils.h                          |  60 ++
 test/main.cc                                  |  82 ++-
 test/net/test_socket_listen.cc                | 398 +++++++++++++
 test/net/test_socket_listen.h                 |  44 ++
 test/torrent/net/test_address_info.cc         |  62 ++
 test/torrent/net/test_address_info.h          |  19 +
 test/torrent/net/test_fd.cc                   |  24 +
 test/torrent/net/test_fd.h                    |  12 +
 test/torrent/net/test_socket_address.cc       | 383 ++++++++++++
 test/torrent/net/test_socket_address.h        |  43 ++
 test/torrent/net/test_socket_address_key.cc   |  87 ---
 test/torrent/object_stream_test.cc            |   4 +-
 test/torrent/tracker_controller_features.cc   |   2 +-
 test/torrent/tracker_controller_requesting.cc |   2 +-
 test/torrent/tracker_controller_test.cc       |   2 +-
 test/torrent/tracker_list_features_test.cc    |   2 +-
 test/torrent/utils/directory_events_test.cc   |   4 +-
 test/torrent/utils/log_buffer_test.h          |  17 -
 test/torrent/utils/log_test.cc                |   4 +-
 test/torrent/utils/net_test.cc                |  32 -
 test/torrent/utils/net_test.h                 |  15 -
 test/torrent/utils/option_strings_test.cc     |   3 +-
 test/torrent/utils/test_extents.cc            |   2 +-
 ...{log_buffer_test.cc => test_log_buffer.cc} |  14 +-
 test/torrent/utils/test_log_buffer.h          |  17 +
 test/torrent/utils/test_uri_parser.cc         |   2 +-
 test/torrent/utils/thread_base_test.cc        |   3 +-
 152 files changed, 3968 insertions(+), 1110 deletions(-)
 create mode 100644 .dir-locals.el
 create mode 100644 scripts/ssl.m4
 create mode 100644 src/net/socket_listen.cc
 create mode 100644 src/net/socket_listen.h
 create mode 100644 src/torrent/event.cc
 create mode 100644 src/torrent/net/address_info.cc
 create mode 100644 src/torrent/net/address_info.h
 create mode 100644 src/torrent/net/fd.cc
 create mode 100644 src/torrent/net/fd.h
 create mode 100644 src/torrent/net/socket_address.cc
 create mode 100644 src/torrent/net/socket_address.h
 create mode 100644 src/torrent/net/socket_event.cc
 create mode 100644 src/torrent/net/socket_event.h
 create mode 100644 src/torrent/net/types.h
 delete mode 100644 src/torrent/utils/net.cc
 delete mode 100644 src/torrent/utils/net.h
 create mode 100644 src/torrent/utils/random.cc
 create mode 100644 src/torrent/utils/random.h
 create mode 100644 test/helpers/expect_fd.h
 create mode 100644 test/helpers/expect_utils.h
 create mode 100644 test/helpers/mock_compare.h
 create mode 100644 test/helpers/mock_function.cc
 create mode 100644 test/helpers/mock_function.h
 create mode 100644 test/helpers/network.h
 create mode 100644 test/helpers/progress_listener.cc
 create mode 100644 test/helpers/progress_listener.h
 create mode 100644 test/helpers/test_fixture.cc
 create mode 100644 test/helpers/test_fixture.h
 create mode 100644 test/helpers/utils.h
 create mode 100644 test/net/test_socket_listen.cc
 create mode 100644 test/net/test_socket_listen.h
 create mode 100644 test/torrent/net/test_address_info.cc
 create mode 100644 test/torrent/net/test_address_info.h
 create mode 100644 test/torrent/net/test_fd.cc
 create mode 100644 test/torrent/net/test_fd.h
 create mode 100644 test/torrent/net/test_socket_address.cc
 create mode 100644 test/torrent/net/test_socket_address.h
 delete mode 100644 test/torrent/net/test_socket_address_key.cc
 delete mode 100644 test/torrent/utils/log_buffer_test.h
 delete mode 100644 test/torrent/utils/net_test.cc
 delete mode 100644 test/torrent/utils/net_test.h
 rename test/torrent/utils/{log_buffer_test.cc => test_log_buffer.cc} (86%)
 create mode 100644 test/torrent/utils/test_log_buffer.h

diff --git a/.dir-locals.el b/.dir-locals.el
new file mode 100644
index 00000000..af1189f2
--- /dev/null
+++ b/.dir-locals.el
@@ -0,0 +1,7 @@
+;;; Directory Local Variables
+;;; For more information see (info "(emacs) Directory Variables")
+
+((c++-mode
+  (flycheck-clang-language-standard . "c++11")
+  (flycheck-gcc-language-standard . "c++11")))
+
diff --git a/Makefile.am b/Makefile.am
index f175e634..9507b9ea 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -8,6 +8,7 @@ EXTRA_DIST= \
 	scripts/checks.m4 \
 	scripts/common.m4 \
 	scripts/attributes.m4 \
+	scripts/ssl.m4 \
 	doc/main.xml \
 	doc/http.xml \
 	doc/torrent.xml \
diff --git a/configure.ac b/configure.ac
index 4ed08124..620ca552 100644
--- a/configure.ac
+++ b/configure.ac
@@ -17,7 +17,7 @@ AC_SUBST(LIBTORRENT_CURRENT)
 AC_SUBST(LIBTORRENT_INTERFACE_VERSION_INFO)
 AC_SUBST(LIBTORRENT_INTERFACE_VERSION_NO)
 
-AM_INIT_AUTOMAKE
+AM_INIT_AUTOMAKE([serial-tests])
 AC_CONFIG_HEADERS(config.h)
 
 AC_PROG_CXX
@@ -35,7 +35,6 @@ RAK_ENABLE_EXTRA_DEBUG
 RAK_ENABLE_WERROR
 
 RAK_CHECK_CXX11
-RAK_CHECK_TR1_LIB
 
 AC_SYS_LARGEFILE
 
@@ -67,41 +66,8 @@ CFLAGS="$PTHREAD_CFLAGS $CPPUNIT_CFLAGS $CFLAGS"
 CXXFLAGS="$PTHREAD_CFLAGS $CPPUNIT_CFLAGS $CXXFLAGS"
 LIBS="$PTHREAD_LIBS $CPPUNIT_LIBS $LIBS"
 
-AC_ARG_ENABLE(openssl,
-  [  --disable-openssl       Don't use OpenSSL's SHA1 implementation.],
-  [
-    if test "$enableval" = "yes"; then
-dnl move to scripts.
-      PKG_CHECK_MODULES(OPENSSL, libcrypto,
-        CXXFLAGS="$CXXFLAGS $OPENSSL_CFLAGS";
-        LIBS="$LIBS $OPENSSL_LIBS")
-
-      AC_DEFINE(USE_OPENSSL, 1, Using OpenSSL.)
-      AC_DEFINE(USE_OPENSSL_SHA, 1, Using OpenSSL's SHA1 implementation.)
-      AC_CHECK_LIB([crypto], [DH_set0_pqg], [AC_DEFINE(USE_OPENSSL_1_1, 1, Using OpenSSL 1.1.)])
-
-    else
-      AC_DEFINE(USE_NSS_SHA, 1, Using Mozilla's SHA1 implementation.)
-    fi
-  ],[
-    PKG_CHECK_MODULES(OPENSSL, libcrypto,
-      CXXFLAGS="$CXXFLAGS $OPENSSL_CFLAGS";
-      LIBS="$LIBS $OPENSSL_LIBS")
-
-    AC_DEFINE(USE_OPENSSL, 1, Using OpenSSL.)
-    AC_DEFINE(USE_OPENSSL_SHA, 1, Using OpenSSL's SHA1 implementation.)
-    AC_CHECK_LIB([crypto], [DH_set0_pqg], [AC_DEFINE(USE_OPENSSL_1_1, 1, Using OpenSSL 1.1.)])
-  ]
-)
-
-AC_ARG_ENABLE(cyrus-rc4,
-  [  --enable-cyrus-rc4=PFX  Use Cyrus RC4 implementation.],
-  [
-    CXXFLAGS="$CXXFLAGS -I${enableval}/include";
-    LIBS="$LIBS -lrc4 -L${enableval}/lib"
-    AC_DEFINE(USE_CYRUS_RC4, 1, Using Cyrus RC4 implementation.)
-  ]
-)
+TORRENT_ARG_OPENSSL
+TORRENT_ARG_CYRUS_RC4
 
 AC_CHECK_FUNCS(posix_memalign)
 
diff --git a/extra/corrupt_file.cc b/extra/corrupt_file.cc
index 2a818cc7..7ae906e6 100644
--- a/extra/corrupt_file.cc
+++ b/extra/corrupt_file.cc
@@ -1,6 +1,6 @@
 #include <iostream>
 #include <stdexcept>
-#include <inttypes.h>
+#include <cinttypes>
 #include <stdio.h>
 #include <stdlib.h>
 #include <fcntl.h>
diff --git a/rak/file_stat.h b/rak/file_stat.h
index 5ad45e8f..f1ad8c2b 100644
--- a/rak/file_stat.h
+++ b/rak/file_stat.h
@@ -38,7 +38,7 @@
 #define RAK_FILE_STAT_H
 
 #include <string>
-#include <inttypes.h>
+#include <cinttypes>
 #include <sys/stat.h>
 
 namespace rak {
diff --git a/rak/fs_stat.h b/rak/fs_stat.h
index 5e844277..2d73ff1b 100644
--- a/rak/fs_stat.h
+++ b/rak/fs_stat.h
@@ -38,7 +38,7 @@
 #define RAK_FS_STAT_H
 
 #include <string>
-#include <inttypes.h>
+#include <cinttypes>
 
 #include <rak/error_number.h>
 
diff --git a/rak/partial_queue.h b/rak/partial_queue.h
index 6650a633..1abfdddf 100644
--- a/rak/partial_queue.h
+++ b/rak/partial_queue.h
@@ -39,7 +39,7 @@
 
 #include <cstring>
 #include <stdexcept>
-#include <inttypes.h>
+#include <cinttypes>
 
 namespace rak {
 
diff --git a/rak/path.h b/rak/path.h
index bfe8ccc1..64daf355 100644
--- a/rak/path.h
+++ b/rak/path.h
@@ -99,7 +99,7 @@ path_expand(const char* src, char* first, char* last) {
     src++;
   }
 
-  return std::max(first + strlcpy(first, src, std::distance(first, last)), last);
+  return std::min(first + strlcpy(first, src, std::distance(first, last)), last);
 }
 
 }
diff --git a/rak/priority_queue_default.h b/rak/priority_queue_default.h
index 01a0070e..a7bba0ce 100644
--- a/rak/priority_queue_default.h
+++ b/rak/priority_queue_default.h
@@ -37,7 +37,7 @@
 #ifndef RAK_PRIORITY_QUEUE_DEFAULT_H
 #define RAK_PRIORITY_QUEUE_DEFAULT_H
 
-#include lt_tr1_functional
+#include <functional>
 #include <rak/allocators.h>
 #include <rak/priority_queue.h>
 #include <rak/timer.h>
diff --git a/rak/socket_address.h b/rak/socket_address.h
index 961c53b2..8eb60116 100644
--- a/rak/socket_address.h
+++ b/rak/socket_address.h
@@ -47,9 +47,12 @@
 #ifndef RAK_SOCKET_ADDRESS_H
 #define RAK_SOCKET_ADDRESS_H
 
+#include <cinttypes>
+#include <cstdint>
 #include <cstring>
-#include <string>
 #include <stdexcept>
+#include <string>
+
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <sys/types.h>
@@ -84,7 +87,6 @@ public:
 
   bool                is_valid_inet_class() const             { return family() == af_inet || family() == af_inet6; }
 
-  // Should we need to set AF_UNSPEC?
   void                clear()                                 { std::memset(this, 0, sizeof(socket_address)); set_family(); }
 
   sa_family_t         family() const                          { return m_sockaddr.sa_family; }
@@ -124,6 +126,7 @@ public:
   // extranous bytes and ensure it does not go beyond the size of this
   // struct.
   void                copy(const socket_address& src, size_t length);
+  void                copy_sockaddr(const sockaddr* src);
 
   static socket_address*       cast_from(sockaddr* sa)        { return reinterpret_cast<socket_address*>(sa); }
   static const socket_address* cast_from(const sockaddr* sa)  { return reinterpret_cast<const socket_address*>(sa); }
@@ -220,6 +223,8 @@ public:
 
   void                set_address_any()                       { set_port(0); set_address(in6addr_any); }
 
+  std::string         pretty_address_str() const;
+
   sa_family_t         family() const                          { return m_sockaddr.sin6_family; }
   void                set_family()                            { m_sockaddr.sin6_family = AF_INET6; }
 
@@ -340,7 +345,7 @@ socket_address::pretty_address_str() const {
   case af_inet:
     return sa_inet()->address_str();
   case af_inet6:
-    return sa_inet6()->address_str();
+    return sa_inet6()->pretty_address_str();
   case af_unspec:
     return std::string("unspec");
   default:
@@ -380,13 +385,16 @@ socket_address::length() const {
 inline void
 socket_address::copy(const socket_address& src, size_t length) {
   length = std::min(length, sizeof(socket_address));
-  
-  // Does this get properly optimized?
+
   std::memset(this, 0, sizeof(socket_address));
   std::memcpy(this, &src, length);
 }
 
-// Should we be able to compare af_unspec?
+inline void
+socket_address::copy_sockaddr(const sockaddr* src) {
+  std::memset(this, 0, sizeof(socket_address));
+  std::memcpy(this, src, socket_address::cast_from(src)->length());
+}
 
 inline bool
 socket_address::operator == (const socket_address& rhs) const {
@@ -488,6 +496,35 @@ socket_address_inet6::set_address_c_str(const char* a) {
   return inet_pton(AF_INET6, a, &m_sockaddr.sin6_addr);
 }
 
+inline std::string
+socket_address_inet6::pretty_address_str() const {
+  char buf[INET6_ADDRSTRLEN + 2 + 6];
+
+  if (inet_ntop(family(), &m_sockaddr.sin6_addr, buf + 1, INET6_ADDRSTRLEN) == NULL)
+    return std::string();
+
+  buf[0] = '[';
+
+  char* last_char = (char*)std::memchr(buf + 1, 0, INET6_ADDRSTRLEN);
+
+  // TODO: Throw exception here.
+
+  if (last_char == NULL || last_char >= buf + 1 + INET6_ADDRSTRLEN)
+    throw std::logic_error("inet_ntop for inet6 returned bad buffer");
+
+  *(last_char++) = ']';
+
+  if (!is_port_any()) {
+    if (snprintf(last_char, 7, ":%" PRIu16, port()) == -1)
+      return std::string("error"); // TODO: Throw here.
+
+  } else {
+    *last_char = '\0';
+  }
+
+  return std::string(buf);
+}
+
 inline socket_address
 socket_address_inet6::normalize_address() const {
   const uint32_t *addr32 = reinterpret_cast<const uint32_t *>(m_sockaddr.sin6_addr.s6_addr);
diff --git a/rak/timer.h b/rak/timer.h
index e25ad2e6..842a2e53 100644
--- a/rak/timer.h
+++ b/rak/timer.h
@@ -38,7 +38,7 @@
 #define RAK_TIMER_H
 
 #include <limits>
-#include <inttypes.h>
+#include <cinttypes>
 #include <sys/time.h>
 
 namespace rak {
diff --git a/scripts/checks.m4 b/scripts/checks.m4
index 83be8461..98ef17f8 100644
--- a/scripts/checks.m4
+++ b/scripts/checks.m4
@@ -88,6 +88,7 @@ AC_DEFUN([TORRENT_CHECK_KQUEUE], [
     [
       AC_DEFINE(USE_KQUEUE, 1, Use kqueue.)
       AC_MSG_RESULT(yes)
+      TORRENT_CHECK_KQUEUE_SOCKET_ONLY
     ], [
       AC_MSG_RESULT(no)
     ])
@@ -137,7 +138,6 @@ AC_DEFUN([TORRENT_WITH_KQUEUE], [
     [
         if test "$withval" = "yes"; then
           TORRENT_CHECK_KQUEUE
-          TORRENT_CHECK_KQUEUE_SOCKET_ONLY
         fi
     ])
 ])
@@ -149,11 +149,9 @@ AC_DEFUN([TORRENT_WITHOUT_KQUEUE], [
     [
       if test "$withval" = "yes"; then
         TORRENT_CHECK_KQUEUE
-        TORRENT_CHECK_KQUEUE_SOCKET_ONLY
       fi
     ], [
         TORRENT_CHECK_KQUEUE
-        TORRENT_CHECK_KQUEUE_SOCKET_ONLY
     ])
 ])
 
diff --git a/scripts/rak_cxx.m4 b/scripts/rak_cxx.m4
index 3660f3a7..0db61b83 100644
--- a/scripts/rak_cxx.m4
+++ b/scripts/rak_cxx.m4
@@ -12,50 +12,3 @@ AC_DEFUN([RAK_CHECK_CXX11], [
     ]
   )
 ])
-
-AC_DEFUN([RAK_CHECK_TR1_LIB], [
-  AC_LANG_PUSH(C++)
-  AC_MSG_CHECKING(should use TR1 headers)
-
-  AC_COMPILE_IFELSE([AC_LANG_SOURCE([
-      #include <unordered_map>
-      class Foo; typedef std::unordered_map<Foo*, int> Bar;
-      Bar b1;
-      ])
-  ], [
-      AC_MSG_RESULT(no)
-      AC_DEFINE(USE_TR1_LIB, 0, Define to 1 if you need to use TR1 containers.)
-
-      AC_DEFINE([lt_tr1_array], [<array>], [TR1 array])
-      AC_DEFINE([lt_tr1_functional], [<functional>], [TR1 functional])
-      AC_DEFINE([lt_tr1_memory], [<memory>], [TR1 memory])
-      AC_DEFINE([lt_tr1_unordered_map], [<unordered_map>], [TR1 unordered_map])
-
-  ], [
-    AC_COMPILE_IFELSE([AC_LANG_SOURCE([
-        #include <tr1/unordered_map>
-        class Foo; typedef std::tr1::unordered_map<Foo*, int> Bar;
-        Bar b1;
-        ])
-    ], [
-        AC_MSG_RESULT([yes])
-        AC_DEFINE(USE_TR1_LIB, 1, Define to 1 if you need to use TR1 containers.)
-
-        AC_DEFINE([lt_tr1_array], [<tr1/array>], [TR1 array])
-        AC_DEFINE([lt_tr1_functional], [<tr1/functional>], [TR1 functional])
-        AC_DEFINE([lt_tr1_memory], [<tr1/memory>], [TR1 memory])
-        AC_DEFINE([lt_tr1_unordered_map], [<tr1/unordered_map>], [TR1 unordered_map])
-
-    ], [
-        AC_MSG_ERROR([No support for C++11 standard library nor TR1 extensions found.])
-    ])
-  ])
-
-  AH_VERBATIM(lt_tr1_zzz, [
-#if USE_TR1_LIB == 1
-namespace std { namespace tr1 {} using namespace tr1; }
-#endif
-])
-
-  AC_LANG_POP(C++)
-])
diff --git a/scripts/ssl.m4 b/scripts/ssl.m4
new file mode 100644
index 00000000..f07349a1
--- /dev/null
+++ b/scripts/ssl.m4
@@ -0,0 +1,38 @@
+AC_DEFUN([TORRENT_CHECK_OPENSSL],
+  [
+    PKG_CHECK_MODULES(OPENSSL, libcrypto,
+      CXXFLAGS="$CXXFLAGS $OPENSSL_CFLAGS";
+      LIBS="$LIBS $OPENSSL_LIBS")
+
+    AC_DEFINE(USE_OPENSSL, 1, Using OpenSSL.)
+    AC_DEFINE(USE_OPENSSL_SHA, 1, Using OpenSSL's SHA1 implementation.)
+  ]
+)
+
+AC_DEFUN([TORRENT_ARG_OPENSSL],
+  [
+    AC_ARG_ENABLE(openssl,
+      [  --disable-openssl       Don't use OpenSSL's SHA1 implementation.],
+      [
+        if test "$enableval" = "yes"; then
+          TORRENT_CHECK_OPENSSL
+        else
+          AC_DEFINE(USE_NSS_SHA, 1, Using Mozilla's SHA1 implementation.)
+        fi
+      ],[
+        TORRENT_CHECK_OPENSSL
+      ])
+  ]
+)
+
+AC_DEFUN([TORRENT_ARG_CYRUS_RC4],
+  [
+    AC_ARG_ENABLE(cyrus-rc4,
+      [  --enable-cyrus-rc4=PFX  Use Cyrus RC4 implementation.],
+      [
+        CXXFLAGS="$CXXFLAGS -I${enableval}/include";
+        LIBS="$LIBS -lrc4 -L${enableval}/lib"
+        AC_DEFINE(USE_CYRUS_RC4, 1, Using Cyrus RC4 implementation.)
+      ])
+  ]
+)
diff --git a/src/data/chunk_list.cc b/src/data/chunk_list.cc
index 00abbc2a..7622b825 100644
--- a/src/data/chunk_list.cc
+++ b/src/data/chunk_list.cc
@@ -36,8 +36,6 @@
 
 #include "config.h"
 
-#define __STDC_FORMAT_MACROS
-
 #include <rak/error_number.h>
 #include <rak/functional.h>
 
diff --git a/src/data/chunk_list.h b/src/data/chunk_list.h
index b6ff4cdb..4b40dc42 100644
--- a/src/data/chunk_list.h
+++ b/src/data/chunk_list.h
@@ -37,9 +37,9 @@
 #ifndef LIBTORRENT_DATA_CHUNK_LIST_H
 #define LIBTORRENT_DATA_CHUNK_LIST_H
 
+#include <functional>
 #include <string>
 #include <vector>
-#include lt_tr1_functional
 
 #include "chunk.h"
 #include "chunk_handle.h"
diff --git a/src/data/chunk_list_node.h b/src/data/chunk_list_node.h
index 76de6671..95e4ed4f 100644
--- a/src/data/chunk_list_node.h
+++ b/src/data/chunk_list_node.h
@@ -37,7 +37,7 @@
 #ifndef LIBTORRENT_DATA_CHUNK_LIST_NODE_H
 #define LIBTORRENT_DATA_CHUNK_LIST_NODE_H
 
-#include <inttypes.h>
+#include <cinttypes>
 #include <rak/timer.h>
 
 namespace torrent {
diff --git a/src/data/hash_check_queue.h b/src/data/hash_check_queue.h
index b933f137..9f28c118 100644
--- a/src/data/hash_check_queue.h
+++ b/src/data/hash_check_queue.h
@@ -38,8 +38,8 @@
 #define LIBTORRENT_DATA_HASH_CHECK_QUEUE_H
 
 #include <deque>
+#include <functional>
 #include <pthread.h>
-#include lt_tr1_functional
 
 #include "rak/allocators.h"
 
diff --git a/src/data/hash_queue.cc b/src/data/hash_queue.cc
index 7dffaee4..3f54892b 100644
--- a/src/data/hash_queue.cc
+++ b/src/data/hash_queue.cc
@@ -36,8 +36,6 @@
 
 #include "config.h"
 
-#define __STDC_FORMAT_MACROS
-
 #include <functional>
 #include <rak/functional.h>
 #include <unistd.h>
diff --git a/src/data/hash_queue.h b/src/data/hash_queue.h
index 6885a383..3a841967 100644
--- a/src/data/hash_queue.h
+++ b/src/data/hash_queue.h
@@ -38,9 +38,9 @@
 #define LIBTORRENT_DATA_HASH_QUEUE_H
 
 #include <deque>
+#include <functional>
 #include <map>
 #include <pthread.h>
-#include lt_tr1_functional
 
 #include "torrent/hash_string.h"
 #include "hash_queue_node.h"
diff --git a/src/data/hash_queue_node.h b/src/data/hash_queue_node.h
index aa59a062..c8367b7c 100644
--- a/src/data/hash_queue_node.h
+++ b/src/data/hash_queue_node.h
@@ -37,9 +37,9 @@
 #ifndef LIBTORRENT_DATA_HASH_QUEUE_NODE_H
 #define LIBTORRENT_DATA_HASH_QUEUE_NODE_H
 
+#include <cinttypes>
+#include <functional>
 #include <string>
-#include lt_tr1_functional
-#include <inttypes.h>
 
 #include "chunk_handle.h"
 #include "hash_chunk.h"
diff --git a/src/data/hash_torrent.cc b/src/data/hash_torrent.cc
index 758a10fa..e803f1cb 100644
--- a/src/data/hash_torrent.cc
+++ b/src/data/hash_torrent.cc
@@ -36,8 +36,6 @@
 
 #include "config.h"
 
-#define __STDC_FORMAT_MACROS
-
 #include "data/chunk_list.h"
 #include "torrent/exceptions.h"
 #include "torrent/data/download_data.h"
diff --git a/src/data/hash_torrent.h b/src/data/hash_torrent.h
index 6af643f2..9ce2f100 100644
--- a/src/data/hash_torrent.h
+++ b/src/data/hash_torrent.h
@@ -37,9 +37,9 @@
 #ifndef LIBTORRENT_DATA_HASH_TORRENT_H
 #define LIBTORRENT_DATA_HASH_TORRENT_H
 
+#include <cinttypes>
+#include <functional>
 #include <string>
-#include <inttypes.h>
-#include lt_tr1_functional
 #include <rak/priority_queue_default.h>
 
 #include "data/chunk_handle.h"
diff --git a/src/data/memory_chunk.h b/src/data/memory_chunk.h
index cc32eff1..d2b5565d 100644
--- a/src/data/memory_chunk.h
+++ b/src/data/memory_chunk.h
@@ -38,7 +38,7 @@
 #define LIBTORRENT_DATA_MEMORY_CHUNK_H
 
 #include <algorithm>
-#include <inttypes.h>
+#include <cinttypes>
 #include <sys/mman.h>
 #include <cstddef>
 
diff --git a/src/data/socket_file.h b/src/data/socket_file.h
index 7b27af8c..d25c4a44 100644
--- a/src/data/socket_file.h
+++ b/src/data/socket_file.h
@@ -38,7 +38,7 @@
 #define LIBTORRENT_SOCKET_FILE_H
 
 #include <string>
-#include <inttypes.h>
+#include <cinttypes>
 #include <fcntl.h>
 #include <sys/types.h>
 
diff --git a/src/dht/dht_hash_map.h b/src/dht/dht_hash_map.h
index 140f070b..1506db56 100644
--- a/src/dht/dht_hash_map.h
+++ b/src/dht/dht_hash_map.h
@@ -39,20 +39,14 @@
 
 #include "config.h"
 
-#if HAVE_TR1
-#include <lt_tr1_unordered_map>
-#else
-#include <map>
-#endif
-
-#include "torrent/hash_string.h"
+#include <unordered_map>
 
 #include "dht_node.h"
 #include "dht_tracker.h"
+#include "torrent/hash_string.h"
 
 namespace torrent {
 
-#if HAVE_TR1
 // Hash functions for HashString keys, and dereferencing HashString pointers.
 
 // Since the first few bits are very similar if not identical (since the IDs
@@ -142,53 +136,6 @@ public:
 
 };
 
-#else
-
-// Compare HashString pointers by dereferencing them.
-struct hashstring_ptr_less : public std::binary_function<const HashString*, const HashString*, bool> {
-  size_t operator () (const HashString* one, const HashString* two) const 
-  { return *one < *two; }
-};
-
-class DhtNodeList : public std::map<const HashString*, DhtNode*, hashstring_ptr_less> {
-public:
-  typedef std::map<const HashString*, DhtNode*, hashstring_ptr_less> base_type;
-
-  // Define accessor iterator with more convenient access to the key and
-  // element values.  Allows changing the map definition more easily if needed.
-  template<typename T>
-  struct accessor_wrapper : public T {
-    accessor_wrapper(const T& itr) : T(itr) { }
-
-    const HashString&    id() const    { return *(**this).first; }
-    DhtNode*             node() const  { return (**this).second; }
-  };
-
-  typedef accessor_wrapper<const_iterator>  const_accessor;
-  typedef accessor_wrapper<iterator>        accessor;
-
-  DhtNode*            add_node(DhtNode* n);
-
-};
-
-class DhtTrackerList : public std::map<HashString, DhtTracker*> {
-public:
-  typedef std::map<HashString, DhtTracker*> base_type;
-
-  template<typename T>
-  struct accessor_wrapper : public T {
-    accessor_wrapper(const T& itr) : T(itr) { }
-
-    const HashString&    id() const       { return (**this).first; }
-    DhtTracker*          tracker() const  { return (**this).second; }
-  };
-
-  typedef accessor_wrapper<const_iterator>  const_accessor;
-  typedef accessor_wrapper<iterator>        accessor;
-
-};
-#endif // HAVE_TR1
-
 inline
 DhtNode* DhtNodeList::add_node(DhtNode* n) {
   insert(std::make_pair((const HashString*)n, (DhtNode*)n));
diff --git a/src/download/chunk_selector.h b/src/download/chunk_selector.h
index 52c31fd5..ab1b8c17 100644
--- a/src/download/chunk_selector.h
+++ b/src/download/chunk_selector.h
@@ -37,7 +37,7 @@
 #ifndef LIBTORRENT_DOWNLOAD_CHUNK_SELECTOR_H
 #define LIBTORRENT_DOWNLOAD_CHUNK_SELECTOR_H
 
-#include <inttypes.h>
+#include <cinttypes>
 #include <rak/partial_queue.h>
 
 #include "torrent/bitfield.h"
diff --git a/src/download/chunk_statistics.h b/src/download/chunk_statistics.h
index 816ec6c9..62f76c5a 100644
--- a/src/download/chunk_statistics.h
+++ b/src/download/chunk_statistics.h
@@ -37,7 +37,7 @@
 #ifndef LIBTORRENT_DOWNLOAD_CHUNK_STATISTICS_H
 #define LIBTORRENT_DOWNLOAD_CHUNK_STATISTICS_H
 
-#include <inttypes.h>
+#include <cinttypes>
 #include <vector>
 
 namespace torrent {
diff --git a/src/download/delegator.cc b/src/download/delegator.cc
index 711cd461..27ae42ec 100644
--- a/src/download/delegator.cc
+++ b/src/download/delegator.cc
@@ -39,7 +39,7 @@
 #include "config.h"
 
 #include <algorithm>
-#include <inttypes.h>
+#include <cinttypes>
 
 #include "torrent/exceptions.h"
 #include "torrent/bitfield.h"
diff --git a/src/download/delegator.h b/src/download/delegator.h
index 3b997b81..b75d4c2a 100644
--- a/src/download/delegator.h
+++ b/src/download/delegator.h
@@ -37,9 +37,9 @@
 #ifndef LIBTORRENT_DELEGATOR_H
 #define LIBTORRENT_DELEGATOR_H
 
+#include <functional>
 #include <string>
 #include <vector>
-#include lt_tr1_functional
 
 #include "torrent/data/transfer_list.h"
 
diff --git a/src/download/download_constructor.h b/src/download/download_constructor.h
index 7d43aba3..6a09b7f1 100644
--- a/src/download/download_constructor.h
+++ b/src/download/download_constructor.h
@@ -39,7 +39,7 @@
 
 #include <list>
 #include <string>
-#include <inttypes.h>
+#include <cinttypes>
 
 namespace torrent {
 
diff --git a/src/globals.cc b/src/globals.cc
index 88130c19..20644fbd 100644
--- a/src/globals.cc
+++ b/src/globals.cc
@@ -37,11 +37,24 @@
 #include "config.h"
 
 #include "globals.h"
-#include "torrent/common.h"
+#include "manager.h"
+#include "torrent/connection_manager.h"
+#include "torrent/event.h"
+#include "torrent/poll.h"
 
 namespace torrent {
 
 LIBTORRENT_EXPORT rak::priority_queue_default taskScheduler;
 LIBTORRENT_EXPORT rak::timer                  cachedTime;
 
+void poll_event_open(Event* event) { manager->poll()->open(event); manager->connection_manager()->inc_socket_count(); }
+void poll_event_close(Event* event) { manager->poll()->close(event); manager->connection_manager()->dec_socket_count(); }
+void poll_event_closed(Event* event) { manager->poll()->closed(event); manager->connection_manager()->dec_socket_count(); }
+void poll_event_insert_read(Event* event) { manager->poll()->insert_read(event); }
+void poll_event_insert_write(Event* event) { manager->poll()->insert_write(event); }
+void poll_event_insert_error(Event* event) { manager->poll()->insert_error(event); }
+void poll_event_remove_read(Event* event) { manager->poll()->remove_read(event); }
+void poll_event_remove_write(Event* event) { manager->poll()->remove_write(event); }
+void poll_event_remove_error(Event* event) { manager->poll()->remove_error(event); }
+
 }
diff --git a/src/globals.h b/src/globals.h
index 564ac86d..e9fe1177 100644
--- a/src/globals.h
+++ b/src/globals.h
@@ -1,39 +1,3 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #ifndef LIBTORRENT_GLOBALS_H
 #define LIBTORRENT_GLOBALS_H
 
diff --git a/src/manager.cc b/src/manager.cc
index c503974d..11ef4b0f 100644
--- a/src/manager.cc
+++ b/src/manager.cc
@@ -1,39 +1,3 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #include "config.h"
 
 #include "torrent/exceptions.h"
diff --git a/src/net/Makefile.am b/src/net/Makefile.am
index fb4da4f3..e3a8c7e1 100644
--- a/src/net/Makefile.am
+++ b/src/net/Makefile.am
@@ -15,6 +15,8 @@ libsub_net_la_SOURCES = \
 	socket_datagram.h \
 	socket_fd.cc \
 	socket_fd.h \
+	socket_listen.cc \
+	socket_listen.h \
 	socket_set.cc \
 	socket_set.h \
 	socket_stream.cc \
diff --git a/src/net/data_buffer.h b/src/net/data_buffer.h
index d35cdc48..5dd0cb30 100644
--- a/src/net/data_buffer.h
+++ b/src/net/data_buffer.h
@@ -38,7 +38,7 @@
 #define LIBTORRENT_NET_DATA_BUFFER_H
 
 #include <memory>
-#include <inttypes.h>
+#include <cinttypes>
 
 namespace torrent {
 
diff --git a/src/net/listen.cc b/src/net/listen.cc
index d424e94c..61fedbf8 100644
--- a/src/net/listen.cc
+++ b/src/net/listen.cc
@@ -1,39 +1,3 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #include "config.h"
 
 #define __STDC_FORMAT_MACROS
@@ -95,7 +59,7 @@ Listen::open(uint16_t first, uint16_t last, int backlog, const rak::socket_addre
       manager->poll()->insert_read(this);
       manager->poll()->insert_error(this);
 
-      lt_log_print(LOG_CONNECTION_INFO, "listen port %" PRIu16 " opened with backlog set to %i",
+      lt_log_print(LOG_CONNECTION_LISTEN, "listen port %" PRIu16 " opened with backlog set to %i",
                    m_port, backlog);
 
       return true;
@@ -107,7 +71,7 @@ Listen::open(uint16_t first, uint16_t last, int backlog, const rak::socket_addre
   get_fd().close();
   get_fd().clear();
 
-  lt_log_print(LOG_CONNECTION_INFO, "failed to open listen port");
+  lt_log_print(LOG_CONNECTION_LISTEN, "failed to open listen port");
 
   return false;
 }
diff --git a/src/net/listen.h b/src/net/listen.h
index b3c845aa..58c06c7e 100644
--- a/src/net/listen.h
+++ b/src/net/listen.h
@@ -37,8 +37,8 @@
 #ifndef LIBTORRENT_LISTEN_H
 #define LIBTORRENT_LISTEN_H
 
-#include <inttypes.h>
-#include lt_tr1_functional
+#include <cinttypes>
+#include <functional>
 #include <rak/socket_address.h>
 
 #include "socket_base.h"
diff --git a/src/net/protocol_buffer.h b/src/net/protocol_buffer.h
index b64d47ea..f9711ded 100644
--- a/src/net/protocol_buffer.h
+++ b/src/net/protocol_buffer.h
@@ -38,7 +38,7 @@
 #define LIBTORRENT_NET_PROTOCOL_BUFFER_H
 
 #include <memory>
-#include <inttypes.h>
+#include <cinttypes>
 #include <netinet/in.h>
 
 #include "torrent/exceptions.h"
diff --git a/src/net/socket_base.h b/src/net/socket_base.h
index 02c9497d..20ae1d9f 100644
--- a/src/net/socket_base.h
+++ b/src/net/socket_base.h
@@ -38,7 +38,7 @@
 #define LIBTORRENT_NET_SOCKET_BASE_H
 
 #include <list>
-#include <inttypes.h>
+#include <cinttypes>
 
 #include "torrent/event.h"
 #include "socket_fd.h"
diff --git a/src/net/socket_fd.cc b/src/net/socket_fd.cc
index f04059f6..c36ff4b9 100644
--- a/src/net/socket_fd.cc
+++ b/src/net/socket_fd.cc
@@ -210,6 +210,11 @@ SocketFd::bind(const rak::socket_address& sa, unsigned int length) {
   return !::bind(m_fd, sa.c_sockaddr(), length);
 }
 
+bool
+SocketFd::bind_sa(const sockaddr* sa) {
+  return bind(*rak::socket_address::cast_from(sa));
+}
+
 bool
 SocketFd::connect(const rak::socket_address& sa) {
   check_valid();
@@ -222,6 +227,11 @@ SocketFd::connect(const rak::socket_address& sa) {
   return !::connect(m_fd, sa.c_sockaddr(), sa.length()) || errno == EINPROGRESS;
 }
 
+bool
+SocketFd::connect_sa(const sockaddr* sa) {
+  return connect(*rak::socket_address::cast_from(sa));
+}
+
 bool
 SocketFd::getsockname(rak::socket_address *sa) {
   check_valid();
diff --git a/src/net/socket_fd.h b/src/net/socket_fd.h
index 2329b4e9..4db0087b 100644
--- a/src/net/socket_fd.h
+++ b/src/net/socket_fd.h
@@ -39,6 +39,8 @@
 
 #include <unistd.h>
 
+struct sockaddr;
+
 namespace rak {
   class socket_address;
 }
@@ -80,7 +82,11 @@ public:
 
   bool                bind(const rak::socket_address& sa);
   bool                bind(const rak::socket_address& sa, unsigned int length);
+  bool                bind_sa(const sockaddr* sa);
+
   bool                connect(const rak::socket_address& sa);
+  bool                connect_sa(const sockaddr* sa);
+
   bool                getsockname(rak::socket_address* sa);
 
   bool                listen(int size);
diff --git a/src/net/socket_listen.cc b/src/net/socket_listen.cc
new file mode 100644
index 00000000..97f006e0
--- /dev/null
+++ b/src/net/socket_listen.cc
@@ -0,0 +1,137 @@
+#include "config.h"
+
+#include "socket_listen.h"
+
+#include <algorithm>
+
+#include "torrent/connection_manager.h"
+#include "torrent/exceptions.h"
+#include "torrent/utils/log.h"
+#include "torrent/utils/random.h"
+
+#define LT_LOG_SAP(log_fmt, sap, ...)                                   \
+  lt_log_print(LOG_CONNECTION_LISTEN, "listen->%s: " log_fmt, sap_pretty_str(sap).c_str(), __VA_ARGS__);
+
+namespace torrent {
+
+socket_listen::socket_listen() : m_backlog(SOMAXCONN) {
+}
+
+void
+socket_listen::set_backlog(int backlog) {
+  if (backlog < 0 || backlog > SOMAXCONN)
+    throw internal_error("Could not set socket_listen backlog, out-of-range value.");
+
+  m_backlog = backlog;
+}
+
+bool
+socket_listen::open(sa_unique_ptr&& sap, uint16_t first_port, uint16_t last_port, uint16_t start_port, fd_flags open_flags) {
+  if (is_open())
+    throw internal_error("socket_listen::open: already open");
+
+  if (!(sap_is_inet(sap) || sap_is_inet6(sap)) || sap_is_v4mapped(sap) || !sap_is_port_any(sap) || sap_is_broadcast(sap))
+    throw internal_error("socket_listen::open: socket address must be inet/inet6 with no port, and not v4mapped nor broadcast: " + sap_pretty_str(sap));
+
+  if (sap_is_inet(sap) && !(open_flags & fd_flag_v4only))
+    throw internal_error("socket_listen::open: socket address is inet without v4only flag");
+
+  if (first_port == 0 || last_port == 0 || start_port == 0 ||
+      !(first_port <= last_port && first_port <= start_port && start_port <= last_port))
+    throw internal_error("socket_listen::open: port range not valid");
+
+  int fd = fd_open(open_flags);
+
+  if (fd == -1) {
+    LT_LOG_SAP("open failed (flags:0x%x errno:%i message:'%s')", sap, open_flags, errno, std::strerror(errno));
+    return false;
+  }
+
+  uint16_t p = start_port;
+
+  do {
+    if (m_open_port(fd, sap, p))
+      return is_open();
+
+    if (p == last_port)
+      p = first_port;
+    else
+      p++;
+  } while (p != start_port);
+
+  LT_LOG_SAP("listen ports exhausted (fd:%i first_port:%" PRIu16 " last_port:%" PRIu16 ")",
+             sap, fd, first_port, last_port);
+  fd_close(fd);
+  return false;
+}
+
+bool
+socket_listen::open_randomize(sa_unique_ptr&& sap, uint16_t first_port, uint16_t last_port, fd_flags open_flags) {
+  if (last_port < first_port)
+    throw internal_error("socket_listen::open_randomize: port range not valid");
+
+  return open(std::move(sap), first_port, last_port, random_uniform_uint16(first_port, last_port), open_flags);
+}
+
+bool
+socket_listen::open_sequential(sa_unique_ptr&& sap, uint16_t first_port, uint16_t last_port, fd_flags open_flags) {
+  return open(std::move(sap), first_port, last_port, first_port, open_flags);
+}
+
+void
+socket_listen::close() {
+  if (!is_open())
+    return;
+
+  torrent::poll_event_closed(this);
+
+  fd_close(file_descriptor());
+  set_file_descriptor(-1);
+  m_socket_address.reset();
+}
+
+void
+socket_listen::event_read() {
+}
+
+void
+socket_listen::event_error() {
+}
+
+// Returns true if open is successful or if we cannot bind to the
+// address, returns false if other ports can be used.
+bool
+socket_listen::m_open_port(int fd, sa_unique_ptr& sap, uint16_t port) {
+  sap_set_port(sap, port);
+
+  if (!fd_bind(fd, sap.get())) {
+    if (errno == EADDRNOTAVAIL || errno == EAFNOSUPPORT) {
+      LT_LOG_SAP("listen address not usable (fd:%i errno:%i message:'%s')",
+                 sap, fd, errno, std::strerror(errno));
+      fd_close(fd);
+      return true;
+    }
+
+    return false;
+  }
+
+  if (!fd_listen(fd, m_backlog)) {
+    LT_LOG_SAP("call to listen failed (fd:%i backlog:%i errno:%i message:'%s')",
+               sap, fd, m_backlog, errno, std::strerror(errno));
+    fd_close(fd);
+    return true;
+  }
+
+  LT_LOG_SAP("open listen port success (fd:%i backlog:%i)", sap, fd, m_backlog);
+
+  m_fileDesc = fd;
+  m_socket_address.swap(sap);
+
+  torrent::poll_event_open(this);
+  torrent::poll_event_insert_read(this);
+  torrent::poll_event_insert_error(this);
+
+  return true;
+}
+
+}
diff --git a/src/net/socket_listen.h b/src/net/socket_listen.h
new file mode 100644
index 00000000..817d5fa5
--- /dev/null
+++ b/src/net/socket_listen.h
@@ -0,0 +1,46 @@
+#ifndef LIBTORRENT_SOCKET_LISTEN_H
+#define LIBTORRENT_SOCKET_LISTEN_H
+
+#include <cinttypes>
+#include <functional>
+
+#include "torrent/net/fd.h"
+#include "torrent/net/socket_address.h"
+#include "torrent/net/socket_event.h"
+
+namespace torrent {
+
+class socket_listen : public socket_event {
+public:
+  typedef std::function<void (int, sa_unique_ptr)> accepted_ftor;
+
+  socket_listen();
+
+  int  backlog() const;
+
+  void set_backlog(int backlog);
+  void set_slot_accepted(accepted_ftor&& ftor);
+
+  bool open(sa_unique_ptr&& sap, uint16_t first_port, uint16_t last_port, uint16_t start_port, fd_flags open_flags);
+  bool open_randomize(sa_unique_ptr&& sap, uint16_t first_port, uint16_t last_port, fd_flags open_flags);
+  bool open_sequential(sa_unique_ptr&& sap, uint16_t first_port, uint16_t last_port, fd_flags open_flags);
+  void close();
+
+  void event_read() override;
+  void event_error() override;
+
+  const char* type_name() const override { return "socket_listen"; }
+
+private:
+  bool m_open_port(int fd, sa_unique_ptr& sap, uint16_t port);
+
+  int           m_backlog;
+  accepted_ftor m_slot_accepted;
+};
+
+inline int  socket_listen::backlog() const { return m_backlog; }
+inline void socket_listen::set_slot_accepted(accepted_ftor&& ftor) { m_slot_accepted = ftor; }
+
+}
+
+#endif
diff --git a/src/net/socket_set.h b/src/net/socket_set.h
index 9264edf7..78443c88 100644
--- a/src/net/socket_set.h
+++ b/src/net/socket_set.h
@@ -39,7 +39,7 @@
 
 #include <list>
 #include <vector>
-#include <inttypes.h>
+#include <cinttypes>
 #include <rak/allocators.h>
 
 #include "torrent/exceptions.h"
diff --git a/src/net/throttle_node.h b/src/net/throttle_node.h
index 77cb6cc7..5af27a22 100644
--- a/src/net/throttle_node.h
+++ b/src/net/throttle_node.h
@@ -37,7 +37,7 @@
 #ifndef LIBTORRENT_NET_THROTTLE_NODE_H
 #define LIBTORRENT_NET_THROTTLE_NODE_H
 
-#include lt_tr1_functional
+#include <functional>
 
 #include "torrent/rate.h"
 
diff --git a/src/protocol/handshake.cc b/src/protocol/handshake.cc
index 6b41bbe3..1b877c7a 100644
--- a/src/protocol/handshake.cc
+++ b/src/protocol/handshake.cc
@@ -46,6 +46,7 @@
 #include "torrent/error.h"
 #include "torrent/poll.h"
 #include "torrent/throttle.h"
+#include "torrent/utils/log.h"
 #include "utils/diffie_hellman.h"
 
 #include "globals.h"
@@ -55,6 +56,10 @@
 #include "handshake.h"
 #include "handshake_manager.h"
 
+#define LT_LOG(log_fmt, ...)                                            \
+  lt_log_print(LOG_CONNECTION_HANDSHAKE, "handshake->%s: " log_fmt,     \
+               m_address.pretty_address_str().c_str(), __VA_ARGS__);
+
 namespace torrent {
 
 const char* Handshake::m_protocol = "BitTorrent protocol";
@@ -862,7 +867,7 @@ restart:
     m_manager->receive_failed(this, e.type(), e.error());
 
   } catch (network_error& e) {
-    m_manager->receive_failed(this, ConnectionManager::handshake_failed, e_handshake_network_error);
+    m_manager->receive_failed(this, ConnectionManager::handshake_failed, e_handshake_network_read_error);
   }
 }
 
@@ -969,7 +974,7 @@ Handshake::event_write() {
     m_manager->receive_failed(this, e.type(), e.error());
 
   } catch (network_error& e) {
-    m_manager->receive_failed(this, ConnectionManager::handshake_failed, e_handshake_network_error);
+    m_manager->receive_failed(this, ConnectionManager::handshake_failed, e_handshake_network_write_error);
   }
 }
 
@@ -1070,7 +1075,7 @@ Handshake::prepare_peer_info() {
     m_peerInfo = m_download->peer_list()->connected(m_address.c_sockaddr(), PeerList::connect_incoming);
 
     if (m_peerInfo == NULL)
-      throw handshake_error(ConnectionManager::handshake_failed, e_handshake_network_error);
+      throw handshake_error(ConnectionManager::handshake_failed, e_handshake_no_peer_info);
 
     if (m_peerInfo->failed_counter() > m_manager->max_failed)
       throw handshake_error(ConnectionManager::handshake_dropped, e_handshake_toomanyfailed);
@@ -1221,7 +1226,7 @@ Handshake::event_error() {
   if (m_state == INACTIVE)
     throw internal_error("Handshake::event_error() called on an inactive handshake.");
 
-  m_manager->receive_failed(this, ConnectionManager::handshake_failed, e_handshake_network_error);
+  m_manager->receive_failed(this, ConnectionManager::handshake_failed, e_handshake_network_socket_error);
 }
 
 }
diff --git a/src/protocol/handshake_manager.cc b/src/protocol/handshake_manager.cc
index b52c8d4e..99592ba8 100644
--- a/src/protocol/handshake_manager.cc
+++ b/src/protocol/handshake_manager.cc
@@ -1,39 +1,3 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #include "config.h"
 
 #include <rak/socket_address.h>
@@ -54,10 +18,10 @@
 
 #include "manager.h"
 
-#define LT_LOG_SA(log_level, sa, log_fmt, ...)                          \
-  lt_log_print(LOG_CONNECTION_##log_level, "handshake_manager->%s: " log_fmt, (sa)->address_str().c_str(), __VA_ARGS__);
-#define LT_LOG_SA_C(log_level, sa, log_fmt, ...)                        \
-  lt_log_print(LOG_CONNECTION_##log_level, "handshake_manager->%s: " log_fmt, \
+#define LT_LOG_SA(sa, log_fmt, ...)                                     \
+  lt_log_print(LOG_CONNECTION_HANDSHAKE, "handshake_manager->%s: " log_fmt, (sa)->address_str().c_str(), __VA_ARGS__);
+#define LT_LOG_SA_C(sa, log_fmt, ...)                                   \
+  lt_log_print(LOG_CONNECTION_HANDSHAKE, "handshake_manager->%s: " log_fmt, \
                reinterpret_cast<const rak::socket_address*>(sa)->address_str().c_str(), __VA_ARGS__);
 
 namespace torrent {
@@ -122,7 +86,7 @@ HandshakeManager::add_incoming(SocketFd fd, const rak::socket_address& sa) {
     return;
   }
 
-  LT_LOG_SA(INFO, &sa, "Adding incoming connection: fd:%i.", fd.get_fd());
+  LT_LOG_SA(&sa, "Adding incoming connection: fd:%i.", fd.get_fd());
 
   manager->connection_manager()->inc_socket_count();
 
@@ -183,7 +147,7 @@ HandshakeManager::create_outgoing(const rak::socket_address& sa, DownloadMain* d
   else
     message = ConnectionManager::handshake_outgoing;
 
-  LT_LOG_SA(INFO, &sa, "Adding outcoming connection: encryption:%x message:%x.", encryptionOptions, message);
+  LT_LOG_SA(&sa, "Adding outcoming connection: encryption:%x message:%x.", encryptionOptions, message);
   manager->connection_manager()->inc_socket_count();
 
   Handshake* handshake = new Handshake(fd, this, encryptionOptions);
@@ -213,7 +177,7 @@ HandshakeManager::receive_succeeded(Handshake* handshake) {
                                                  handshake->extensions())) != NULL) {
     
     manager->client_list()->retrieve_id(&handshake->peer_info()->mutable_client_info(), handshake->peer_info()->id());
-    LT_LOG_SA_C(INFO, handshake->peer_info()->socket_address(), "Handshake success.", 0);
+    LT_LOG_SA_C(handshake->peer_info()->socket_address(), "Handshake success.", 0);
 
     pcb->peer_chunks()->set_have_timer(handshake->initialized_time());
 
@@ -237,7 +201,7 @@ HandshakeManager::receive_succeeded(Handshake* handshake) {
     else
       reason = e_handshake_duplicate;
 
-    LT_LOG_SA_C(INFO, handshake->peer_info()->socket_address(), "Handshake dropped: %s.", strerror(reason));
+    LT_LOG_SA_C(handshake->peer_info()->socket_address(), "Handshake dropped: %s.", strerror(reason));
     handshake->destroy_connection();
   }
 
@@ -255,13 +219,13 @@ HandshakeManager::receive_failed(Handshake* handshake, int message, int error) {
   handshake->deactivate_connection();
   handshake->destroy_connection();
 
-  LT_LOG_SA(INFO, sa, "Received error: message:%x %s.", message, strerror(error));
+  LT_LOG_SA(sa, "Received error: message:%x %s.", message, strerror(error));
 
   if (handshake->encryption()->should_retry()) {
     int retry_options = handshake->retry_options() | ConnectionManager::encryption_retrying;
     DownloadMain* download = handshake->download();
 
-    LT_LOG_SA(INFO, sa, "Retrying %s.",
+    LT_LOG_SA(sa, "Retrying %s.",
               retry_options & ConnectionManager::encryption_try_outgoing ? "encrypted" : "plaintext");
 
     create_outgoing(*sa, download, retry_options);
diff --git a/src/protocol/handshake_manager.h b/src/protocol/handshake_manager.h
index cfd52aa0..dc398e3e 100644
--- a/src/protocol/handshake_manager.h
+++ b/src/protocol/handshake_manager.h
@@ -1,45 +1,9 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #ifndef LIBTORRENT_NET_HANDSHAKE_MANAGER_H
 #define LIBTORRENT_NET_HANDSHAKE_MANAGER_H
 
-#include <string>
+#include <functional>
 #include <inttypes.h>
-#include lt_tr1_functional
+#include <string>
 #include <rak/functional.h>
 #include <rak/unordered_vector.h>
 #include <rak/socket_address.h>
diff --git a/src/protocol/peer_connection_base.cc b/src/protocol/peer_connection_base.cc
index c02998fb..bd870425 100644
--- a/src/protocol/peer_connection_base.cc
+++ b/src/protocol/peer_connection_base.cc
@@ -36,8 +36,6 @@
 
 #include "config.h"
 
-#define __STDC_FORMAT_MACROS
-
 #include <cstdio>
 #include <fcntl.h>
 #include <rak/error_number.h>
diff --git a/src/protocol/request_list.cc b/src/protocol/request_list.cc
index a4338bcb..ea5d388a 100644
--- a/src/protocol/request_list.cc
+++ b/src/protocol/request_list.cc
@@ -1,44 +1,8 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #include "config.h"
 
 #include <algorithm>
 #include <functional>
-#include <inttypes.h>
+#include <cinttypes>
 #include <rak/functional.h>
 
 #include "torrent/data/block.h"
diff --git a/src/torrent/Makefile.am b/src/torrent/Makefile.am
index 1bdfde3d..8cd26ce7 100644
--- a/src/torrent/Makefile.am
+++ b/src/torrent/Makefile.am
@@ -22,6 +22,7 @@ libsub_torrent_la_SOURCES = \
 	download_info.h \
 	error.cc \
 	error.h \
+	event.cc \
 	event.h \
 	exceptions.cc \
 	exceptions.h \
diff --git a/src/torrent/common.h b/src/torrent/common.h
index 3363143d..42cc3246 100644
--- a/src/torrent/common.h
+++ b/src/torrent/common.h
@@ -37,10 +37,13 @@
 #ifndef LIBTORRENT_COMMON_H
 #define LIBTORRENT_COMMON_H
 
-#include <inttypes.h>
+#include <cinttypes>
 #include <cstddef>
 
 struct sockaddr;
+struct sockaddr_in;
+struct sockaddr_in6;
+struct sockaddr_un;
 
 namespace torrent {
 
diff --git a/src/torrent/connection_manager.h b/src/torrent/connection_manager.h
index 2dcf2b37..cf43b0bf 100644
--- a/src/torrent/connection_manager.h
+++ b/src/torrent/connection_manager.h
@@ -39,13 +39,13 @@
 #ifndef LIBTORRENT_CONNECTION_MANAGER_H
 #define LIBTORRENT_CONNECTION_MANAGER_H
 
+#include <functional>
 #include <list>
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <sys/socket.h>
-#include lt_tr1_functional
 #include <torrent/common.h>
 
 namespace torrent {
diff --git a/src/torrent/data/download_data.h b/src/torrent/data/download_data.h
index 2b9c9412..fc212047 100644
--- a/src/torrent/data/download_data.h
+++ b/src/torrent/data/download_data.h
@@ -37,7 +37,7 @@
 #ifndef LIBTORRENT_DATA_DOWNLOAD_DATA_H
 #define LIBTORRENT_DATA_DOWNLOAD_DATA_H
 
-#include lt_tr1_functional
+#include <functional>
 
 #include <torrent/common.h>
 #include <torrent/bitfield.h>
diff --git a/src/torrent/data/file_list.cc b/src/torrent/data/file_list.cc
index 4721bdbd..2e334fa8 100644
--- a/src/torrent/data/file_list.cc
+++ b/src/torrent/data/file_list.cc
@@ -36,8 +36,6 @@
 
 #include "config.h"
 
-#define __STDC_FORMAT_MACROS
-
 #include <algorithm>
 #include <cstring>
 #include <functional>
diff --git a/src/torrent/data/transfer_list.h b/src/torrent/data/transfer_list.h
index 0a359b5e..9813af12 100644
--- a/src/torrent/data/transfer_list.h
+++ b/src/torrent/data/transfer_list.h
@@ -37,9 +37,10 @@
 #ifndef LIBTORRENT_TRANSFER_LIST_H
 #define LIBTORRENT_TRANSFER_LIST_H
 
+#include <functional>
 #include <vector>
+
 #include <torrent/common.h>
-#include lt_tr1_functional
 
 namespace torrent {
 
diff --git a/src/torrent/download.cc b/src/torrent/download.cc
index edddedfb..f72c9351 100644
--- a/src/torrent/download.cc
+++ b/src/torrent/download.cc
@@ -36,9 +36,7 @@
 
 #include "config.h"
 
-#define __STDC_FORMAT_MACROS
-
-#include <inttypes.h>
+#include <cinttypes>
 
 #include "data/block.h"
 #include "data/block_list.h"
diff --git a/src/torrent/download/choke_group.cc b/src/torrent/download/choke_group.cc
index a1540fc1..d9b25a9c 100644
--- a/src/torrent/download/choke_group.cc
+++ b/src/torrent/download/choke_group.cc
@@ -37,7 +37,7 @@
 #include "config.h"
 
 #include <algorithm>
-#include lt_tr1_functional
+#include <functional>
 
 #include "choke_group.h"
 #include "choke_queue.h"
diff --git a/src/torrent/download/choke_group.h b/src/torrent/download/choke_group.h
index 93fd1d02..50804b3e 100644
--- a/src/torrent/download/choke_group.h
+++ b/src/torrent/download/choke_group.h
@@ -39,7 +39,7 @@
 
 #include <string>
 #include <vector>
-#include <inttypes.h>
+#include <cinttypes>
 #include <torrent/common.h>
 #include <torrent/download/choke_queue.h>
 
diff --git a/src/torrent/download/choke_queue.cc b/src/torrent/download/choke_queue.cc
index 3827e25e..7c00b686 100644
--- a/src/torrent/download/choke_queue.cc
+++ b/src/torrent/download/choke_queue.cc
@@ -37,10 +37,9 @@
 #include "config.h"
 
 #include <algorithm>
+#include <cstdlib>
 #include <functional>
 #include <numeric>
-#include <cstdlib>
-#include lt_tr1_functional
 #include <rak/functional.h>
 
 #include "protocol/peer_connection_base.h"
diff --git a/src/torrent/download/choke_queue.h b/src/torrent/download/choke_queue.h
index 973f6522..5e274a99 100644
--- a/src/torrent/download/choke_queue.h
+++ b/src/torrent/download/choke_queue.h
@@ -39,10 +39,11 @@
 
 #include <torrent/common.h>
 
+#include <cinttypes>
+#include <functional>
 #include <list>
 #include <vector>
-#include <inttypes.h>
-#include lt_tr1_functional
+
 #include <torrent/download/group_entry.h>
 
 namespace torrent {
diff --git a/src/torrent/download/group_entry.h b/src/torrent/download/group_entry.h
index e167ecbb..a7c9e429 100644
--- a/src/torrent/download/group_entry.h
+++ b/src/torrent/download/group_entry.h
@@ -38,8 +38,9 @@
 #define LIBTORRENT_DOWNLOAD_GROUP_ENTRY_H
 
 #include <algorithm>
+#include <functional>
 #include <vector>
-#include lt_tr1_functional
+
 #include <torrent/common.h>
 #include <torrent/exceptions.h>
 
diff --git a/src/torrent/download/resource_manager.cc b/src/torrent/download/resource_manager.cc
index bc6374d2..51434c91 100644
--- a/src/torrent/download/resource_manager.cc
+++ b/src/torrent/download/resource_manager.cc
@@ -38,7 +38,6 @@
 
 #include <algorithm>
 #include <functional>
-#include lt_tr1_functional
 #include <limits>
 #include <numeric>
 #include <rak/functional.h>
diff --git a/src/torrent/download/resource_manager.h b/src/torrent/download/resource_manager.h
index b2f861af..ba61b45f 100644
--- a/src/torrent/download/resource_manager.h
+++ b/src/torrent/download/resource_manager.h
@@ -39,7 +39,7 @@
 
 #include <string>
 #include <vector>
-#include <inttypes.h>
+#include <cinttypes>
 #include <torrent/common.h>
 
 namespace torrent {
diff --git a/src/torrent/download_info.h b/src/torrent/download_info.h
index 341e4c25..2c4dbaf2 100644
--- a/src/torrent/download_info.h
+++ b/src/torrent/download_info.h
@@ -37,10 +37,10 @@
 #ifndef LIBTORRENT_DOWNLOAD_INFO_H
 #define LIBTORRENT_DOWNLOAD_INFO_H
 
+#include <cinttypes>
+#include <functional>
 #include <list>
 #include <string>
-#include <inttypes.h>
-#include lt_tr1_functional
 
 #include <torrent/rate.h>
 #include <torrent/hash_string.h>
diff --git a/src/torrent/error.cc b/src/torrent/error.cc
index 5010c803..eea9bb83 100644
--- a/src/torrent/error.cc
+++ b/src/torrent/error.cc
@@ -54,11 +54,15 @@ static const char* errorStrings[e_last + 1] = {
   "unencrypted connection rejected",    // eh_unencrypted_rejected
   "invalid encryption method",          // eh_invalid_encryption
   "encryption sync failed",             // eh_encryption_sync_failed
-  "network error",                      // eh_network_error
+  "<deprecated>",                       // eh_
   "network unreachable",                // eh_network_unreachable
   "network timeout",                    // eh_network_timeout
   "invalid message order",              // eh_invalid_order
   "too many failed chunks",             // eh_toomanyfailed
+  "no peer info",                       // eh_no_peer_info
+  "network socket error",               // eh_network_socket_error
+  "network read error",                 // eh_network_read_error
+  "network write error",                // eh_network_write_error
 
 //   "", // e_handshake_incoming
 //   "", // e_handshake_outgoing
diff --git a/src/torrent/error.h b/src/torrent/error.h
index f3fac463..295a595b 100644
--- a/src/torrent/error.h
+++ b/src/torrent/error.h
@@ -55,11 +55,14 @@ const int e_handshake_invalid_value             = 8;
 const int e_handshake_unencrypted_rejected      = 9;
 const int e_handshake_invalid_encryption        = 10;
 const int e_handshake_encryption_sync_failed    = 11;
-const int e_handshake_network_error             = 12;
 const int e_handshake_network_unreachable       = 13;
 const int e_handshake_network_timeout           = 14;
 const int e_handshake_invalid_order             = 15;
 const int e_handshake_toomanyfailed             = 16;
+const int e_handshake_no_peer_info              = 17;
+const int e_handshake_network_socket_error      = 18;
+const int e_handshake_network_read_error        = 19;
+const int e_handshake_network_write_error       = 20;
 
 // const int e_handshake_incoming                  = 13;
 // const int e_handshake_outgoing                  = 14;
@@ -69,7 +72,7 @@ const int e_handshake_toomanyfailed             = 16;
 // const int e_handshake_retry_plaintext           = 18;
 // const int e_handshake_retry_encrypted           = 19;
 
-const int e_last                                = 16;
+const int e_last                                = 20;
 
 const char* strerror(int err) LIBTORRENT_EXPORT;
 
diff --git a/src/torrent/event.cc b/src/torrent/event.cc
new file mode 100644
index 00000000..e68974ea
--- /dev/null
+++ b/src/torrent/event.cc
@@ -0,0 +1,19 @@
+#include "config.h"
+
+#include "event.h"
+
+#include "torrent/exceptions.h"
+#include "torrent/net/fd.h"
+
+namespace torrent {
+
+void
+Event::close_file_descriptor() {
+  if (!is_open())
+    throw internal_error("Tried to close already closed file descriptor on event type " + std::string(type_name()));
+
+  fd_close(m_fileDesc);
+  m_fileDesc = -1;
+}
+
+}
diff --git a/src/torrent/event.h b/src/torrent/event.h
index f3549762..73f87e46 100644
--- a/src/torrent/event.h
+++ b/src/torrent/event.h
@@ -1,39 +1,3 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #ifndef LIBTORRENT_TORRENT_EVENT_H
 #define LIBTORRENT_TORRENT_EVENT_H
 
@@ -43,26 +7,48 @@ namespace torrent {
 
 class LIBTORRENT_EXPORT Event {
 public:
-  virtual ~Event() {}
+  Event();
+  virtual ~Event();
 
-  // These are not virtual as the fd is heavily used in select based
-  // polling, thus fast access is critical to performance.
-  int                 file_descriptor() const { return m_fileDesc; }
+  // TODO: Disable override.
+  bool is_open() const;
 
-  virtual void        event_read() = 0;
-  virtual void        event_write() = 0;
-  virtual void        event_error() = 0;
+  int file_descriptor() const;
 
-  // Require all event types to define this function.
-  virtual const char* type_name() const { return "default"; }
+  virtual void event_read() = 0;
+  virtual void event_write() = 0;
+  virtual void event_error() = 0;
 
-  // Event closed?
+  // TODO: Require all to define their ownh typename.
+  virtual const char* type_name() const { return "default"; }
 
 protected:
-  int                 m_fileDesc;
-  bool                m_ipv6_socket;
+  void close_file_descriptor();
+  void set_file_descriptor(int fd);
+
+  int  m_fileDesc;
+
+  // TODO: Deprecate.
+  bool m_ipv6_socket;
 };
 
+inline Event::Event() : m_fileDesc(-1), m_ipv6_socket(false) {}
+inline Event::~Event() {}
+inline bool Event::is_open() const { return file_descriptor() != -1; }
+inline int  Event::file_descriptor() const { return m_fileDesc; }
+inline void Event::set_file_descriptor(int fd) { m_fileDesc = fd; }
+
+// Defined in 'src/globals.cc'.
+[[gnu::weak]] void poll_event_open(Event* event) LIBTORRENT_EXPORT;
+[[gnu::weak]] void poll_event_close(Event* event) LIBTORRENT_EXPORT;
+[[gnu::weak]] void poll_event_closed(Event* event) LIBTORRENT_EXPORT;
+[[gnu::weak]] void poll_event_insert_read(Event* event) LIBTORRENT_EXPORT;
+[[gnu::weak]] void poll_event_insert_write(Event* event) LIBTORRENT_EXPORT;
+[[gnu::weak]] void poll_event_insert_error(Event* event) LIBTORRENT_EXPORT;
+[[gnu::weak]] void poll_event_remove_read(Event* event) LIBTORRENT_EXPORT;
+[[gnu::weak]] void poll_event_remove_write(Event* event) LIBTORRENT_EXPORT;
+[[gnu::weak]] void poll_event_remove_error(Event* event) LIBTORRENT_EXPORT;
+
 }
 
 #endif
diff --git a/src/torrent/http.h b/src/torrent/http.h
index c68d3933..c605afa5 100644
--- a/src/torrent/http.h
+++ b/src/torrent/http.h
@@ -38,9 +38,9 @@
 #define LIBTORRENT_HTTP_H
 
 #include <string>
+#include <functional>
 #include <iosfwd>
 #include <list>
-#include lt_tr1_functional
 #include <torrent/common.h>
 
 namespace torrent {
diff --git a/src/torrent/net/Makefile.am b/src/torrent/net/Makefile.am
index 51999d19..35dd4774 100644
--- a/src/torrent/net/Makefile.am
+++ b/src/torrent/net/Makefile.am
@@ -1,11 +1,25 @@
 noinst_LTLIBRARIES = libsub_torrentnet.la
 
 libsub_torrentnet_la_SOURCES = \
+	address_info.cc \
+	address_info.h \
+	fd.cc \
+	fd.h \
+	socket_address.cc \
+	socket_address.h \
 	socket_address_key.cc \
-	socket_address_key.h
+	socket_address_key.h \
+	socket_event.cc \
+	socket_event.h \
+	types.h
 
 AM_CPPFLAGS = -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../.. -I$(top_srcdir)
 
 libtorrentincludedir = $(includedir)/torrent/net
 libtorrentinclude_HEADERS = \
-	socket_address_key.h
+	address_info.h \
+	fd.h \
+	socket_address.h \
+	socket_address_key.h \
+	socket_event.h \
+	types.h
diff --git a/src/torrent/net/address_info.cc b/src/torrent/net/address_info.cc
new file mode 100644
index 00000000..25a51ebd
--- /dev/null
+++ b/src/torrent/net/address_info.cc
@@ -0,0 +1,43 @@
+#include "config.h"
+
+#include "address_info.h"
+
+namespace torrent {
+
+int
+ai_get_addrinfo(const char* nodename, const char* servname, const addrinfo* hints, ai_unique_ptr& res) {
+  addrinfo* ai;
+  int err = ::getaddrinfo(nodename, servname, hints, &ai);
+
+  if (err != 0)
+    return err;
+
+  res.reset(ai);
+  return 0;
+}
+
+sa_unique_ptr
+ai_get_first_sa(const char* nodename, const char* servname, const addrinfo* hints) {
+  ai_unique_ptr aip;
+
+  if (ai_get_addrinfo(nodename, servname, hints, aip) != 0)
+    return nullptr;
+
+  return sa_copy(aip->ai_addr);
+}
+
+int
+ai_each_inet_inet6_first(const char* nodename, ai_sockaddr_func lambda) {
+  int err;
+  ai_unique_ptr ai;
+
+  // TODO: Change to a single call using hints with both inet/inet6.
+  if ((err = ai_get_addrinfo(nodename, NULL, ai_make_hint(0, PF_INET, SOCK_STREAM).get(), ai)) != 0 &&
+      (err = ai_get_addrinfo(nodename, NULL, ai_make_hint(0, PF_INET6, SOCK_STREAM).get(), ai)) != 0)
+    return err;
+
+  lambda(ai->ai_addr);
+  return 0;
+}
+
+}
diff --git a/src/torrent/net/address_info.h b/src/torrent/net/address_info.h
new file mode 100644
index 00000000..c0b1c082
--- /dev/null
+++ b/src/torrent/net/address_info.h
@@ -0,0 +1,69 @@
+#ifndef LIBTORRENT_NET_ADDRESS_INFO_H
+#define LIBTORRENT_NET_ADDRESS_INFO_H
+
+#include <cstring>
+#include <functional>
+#include <memory>
+#include <string>
+#include <netdb.h>
+#include <torrent/common.h>
+#include <torrent/net/socket_address.h>
+
+namespace torrent {
+
+struct ai_deleter {
+  void operator()(addrinfo* ai) const { freeaddrinfo(ai); }
+};
+
+typedef std::unique_ptr<addrinfo, ai_deleter> ai_unique_ptr;
+typedef std::unique_ptr<const addrinfo, ai_deleter> c_ai_unique_ptr;
+typedef std::function<void (const sockaddr*)> ai_sockaddr_func;
+
+inline void          ai_clear(addrinfo* ai);
+inline ai_unique_ptr ai_make_hint(int flags, int family, int socktype);
+
+int ai_get_addrinfo(const char* nodename, const char* servname, const addrinfo* hints, ai_unique_ptr& res) LIBTORRENT_EXPORT;
+
+// Helper functions:
+
+// TODO: Consider servname "0".
+// TODO: ai_get_first_sa_err that returns a tuple?
+sa_unique_ptr ai_get_first_sa(const char* nodename, const char* servname = nullptr, const addrinfo* hints = nullptr) LIBTORRENT_EXPORT;
+
+int ai_each_inet_inet6_first(const char* nodename, ai_sockaddr_func lambda) LIBTORRENT_EXPORT;
+
+// Get all addrinfo's, iterate, etc.
+
+//
+// Safe conversion from unique_ptr arguments:
+//
+
+inline void aip_clear(ai_unique_ptr& aip) { return ai_clear(aip.get()); }
+
+inline int aip_get_addrinfo(const char* nodename, const char* servname, const ai_unique_ptr& hints, ai_unique_ptr& res) { return ai_get_addrinfo(nodename, servname, hints.get(), res); }
+inline int aip_get_addrinfo(const char* nodename, const char* servname, const c_ai_unique_ptr& hints, ai_unique_ptr& res) { return ai_get_addrinfo(nodename, servname, hints.get(), res); }
+
+//
+// Implementations:
+//
+
+inline void
+ai_clear(addrinfo* ai) {
+  std::memset(ai, 0, sizeof(addrinfo));  
+}
+
+inline ai_unique_ptr
+ai_make_hint(int flags, int family, int socktype) {
+  ai_unique_ptr aip(new addrinfo);
+
+  aip_clear(aip);
+  aip->ai_flags = flags;
+  aip->ai_family = family;
+  aip->ai_socktype = socktype;
+
+  return aip;
+}
+
+}
+
+#endif
diff --git a/src/torrent/net/fd.cc b/src/torrent/net/fd.cc
new file mode 100644
index 00000000..07c91779
--- /dev/null
+++ b/src/torrent/net/fd.cc
@@ -0,0 +1,209 @@
+#include "config.h"
+
+#include "fd.h"
+
+#include <cerrno>
+#include <fcntl.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+
+#include "torrent/exceptions.h"
+#include "torrent/net/socket_address.h"
+#include "torrent/utils/log.h"
+
+#define LT_LOG(log_fmt, ...)                                    \
+  lt_log_print(LOG_CONNECTION_FD, "fd: " log_fmt, __VA_ARGS__);
+#define LT_LOG_FLAG(log_fmt)                                            \
+  lt_log_print(LOG_CONNECTION_FD, "fd: " log_fmt " (flags:0x%x)", flags);
+#define LT_LOG_FLAG_ERROR(log_fmt)                                      \
+  lt_log_print(LOG_CONNECTION_FD, "fd: " log_fmt " (flags:0x%x errno:%i message:'%s')", \
+               flags, errno, std::strerror(errno));
+#define LT_LOG_FD(log_fmt)                                      \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt, fd);
+#define LT_LOG_FD_ERROR(log_fmt)                                        \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (errno:%i message:'%s')", \
+               fd, errno, std::strerror(errno));
+#define LT_LOG_FD_SOCKADDR(log_fmt)                                   \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (address:%s)", \
+               fd, sa_pretty_str(sa).c_str());
+#define LT_LOG_FD_SOCKADDR_ERROR(log_fmt)                               \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (address:%s errno:%i message:'%s')", \
+               fd, sa_pretty_str(sa).c_str(), errno, std::strerror(errno));
+#define LT_LOG_FD_FLAG(log_fmt)                                         \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (flags:0x%x)", fd, flags);
+#define LT_LOG_FD_FLAG_ERROR(log_fmt)                                   \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (flags:0x%x errno:%i message:'%s')", \
+               fd, flags, errno, std::strerror(errno));
+#define LT_LOG_FD_VALUE(log_fmt, value)                                 \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (value:%i)", fd, (int)value);
+#define LT_LOG_FD_VALUE_ERROR(log_fmt, value)                           \
+  lt_log_print(LOG_CONNECTION_FD, "fd->%i: " log_fmt " (value:%i errno:%i message:'%s')", \
+               fd, (int)value, errno, std::strerror(errno));
+
+namespace torrent {
+
+int fd__accept(int socket, sockaddr *address, socklen_t *address_len) { return ::accept(socket, address, address_len); }
+int fd__bind(int socket, const sockaddr *address, socklen_t address_len) { return ::bind(socket, address, address_len); }
+int fd__close(int fildes) { return ::close(fildes); }
+int fd__connect(int socket, const sockaddr *address, socklen_t address_len) { return ::connect(socket, address, address_len); }
+int fd__fcntl_int(int fildes, int cmd, int arg) { return ::fcntl(fildes, cmd, arg); }
+int fd__listen(int socket, int backlog) { return ::listen(socket, backlog); }
+int fd__setsockopt_int(int socket, int level, int option_name, int option_value) { return ::setsockopt(socket, level, option_name, &option_value, sizeof(int)); }
+int fd__socket(int domain, int type, int protocol) { return ::socket(domain, type, protocol); }
+
+int
+fd_open(fd_flags flags) {
+  int domain;
+  int protocol;
+
+  if (!fd_valid_flags(flags))
+    throw internal_error("torrent::fd_open failed: invalid fd_flags");
+
+  if ((flags & fd_flag_stream)) {
+    domain = SOCK_STREAM;
+    protocol = IPPROTO_TCP;
+  } else {
+    LT_LOG_FLAG("fd_open missing socket type");
+    errno = EINVAL;
+    return -1;
+  }
+
+  int fd = -1;
+
+  if (fd == -1 && !(flags & fd_flag_v4only)) {
+    LT_LOG_FLAG("fd_open opening ipv6 socket");
+    fd = fd__socket(PF_INET6, domain, protocol);
+  }
+
+  if (fd == -1 && !(flags & fd_flag_v6only)) {
+    LT_LOG_FLAG("fd_open opening ipv4 socket");
+    fd = fd__socket(PF_INET, domain, protocol);
+  }
+
+  if (fd == -1) {
+    LT_LOG_FLAG_ERROR("fd_open failed to open socket");
+    return -1;
+  }
+
+  if ((flags & fd_flag_v6only) && !fd_set_v6only(fd, true)) {
+    LT_LOG_FD_FLAG_ERROR("fd_open failed to set v6only");
+    fd_close(fd);
+    return -1;
+  }
+
+  if ((flags & fd_flag_nonblock) && !fd_set_nonblock(fd)) {
+    LT_LOG_FD_FLAG_ERROR("fd_open failed to set nonblock");
+    fd_close(fd);
+    return -1;
+  }
+
+  if ((flags & fd_flag_reuse_address) && !fd_set_reuse_address(fd, true)) {
+    LT_LOG_FD_FLAG_ERROR("fd_open failed to set reuse_address");
+    fd_close(fd);
+    return -1;
+  }
+
+  LT_LOG_FD_FLAG("fd_open succeeded");
+  return fd;
+}
+
+void
+fd_close(int fd) {
+  if (fd == STDIN_FILENO || fd == STDOUT_FILENO || fd == STDERR_FILENO)
+    throw internal_error("torrent::fd_close: tried to close stdin/out/err");
+
+  if (fd__close(fd) == -1)
+    throw internal_error("torrent::fd_close: " + std::string(strerror(errno)));
+
+  LT_LOG_FD("fd_close succeeded");
+}
+
+fd_sap_tuple
+fd_accept(int fd) {
+  sa_unique_ptr sap = sa_make_inet6();
+  socklen_t socklen = sap_length(sap);
+
+  int accept_fd = fd__accept(fd, sap.get(), &socklen);
+
+  if (accept_fd == -1) {
+    LT_LOG_FD_ERROR("fd_accept failed");
+    return fd_sap_tuple{-1, nullptr};
+  }
+
+  return fd_sap_tuple{accept_fd, std::move(sap)};
+}
+
+bool
+fd_bind(int fd, const sockaddr* sa) {
+  if (fd__bind(fd, sa, sa_length(sa)) == -1) {
+    LT_LOG_FD_SOCKADDR_ERROR("fd_bind failed");
+    return false;
+  }
+
+  LT_LOG_FD_SOCKADDR("fd_bind succeeded");
+  return true;
+}
+
+bool
+fd_connect(int fd, const sockaddr* sa) {
+  if (fd__connect(fd, sa, sa_length(sa)) == 0) {
+    LT_LOG_FD_SOCKADDR("fd_connect succeeded");
+    return true;
+  }
+
+  if (errno == EINPROGRESS) {
+    LT_LOG_FD_SOCKADDR("fd_connect succeeded and in progress");
+    return true;
+  }
+
+  LT_LOG_FD_SOCKADDR_ERROR("fd_connect failed");
+  return false;
+}
+
+bool
+fd_listen(int fd, int backlog) {
+  if (fd__listen(fd, backlog) == -1) {
+    LT_LOG_FD_VALUE_ERROR("fd_listen failed", backlog);
+    return false;
+  }
+
+  LT_LOG_FD_VALUE("fd_listen succeeded", backlog);
+  return true;
+}
+
+bool
+fd_set_nonblock(int fd) {
+  if (fd__fcntl_int(fd, F_SETFL, O_NONBLOCK) == -1) {
+    LT_LOG_FD_ERROR("fd_set_nonblock failed");
+    return false;
+  }
+
+  LT_LOG_FD("fd_set_nonblock succeeded");
+  return true;
+}
+
+bool
+fd_set_reuse_address(int fd, bool state) {
+  if (fd__setsockopt_int(fd, SOL_SOCKET, SO_REUSEADDR, state) == -1) {
+    LT_LOG_FD_VALUE_ERROR("fd_set_reuse_address failed", state);
+    return false;
+  }
+
+  LT_LOG_FD_VALUE("fd_set_reuse_address succeeded", state);
+  return true;
+}
+
+bool
+fd_set_v6only(int fd, bool state) {
+  if (fd__setsockopt_int(fd, IPPROTO_IPV6, IPV6_V6ONLY, state) == -1) {
+    LT_LOG_FD_VALUE_ERROR("fd_set_v6only failed", state);
+    return false;
+  }
+
+  LT_LOG_FD_VALUE("fd_set_v6only succeeded", state);
+  return true;
+}
+
+}
diff --git a/src/torrent/net/fd.h b/src/torrent/net/fd.h
new file mode 100644
index 00000000..a7094646
--- /dev/null
+++ b/src/torrent/net/fd.h
@@ -0,0 +1,63 @@
+#ifndef LIBTORRENT_NET_FD_H
+#define LIBTORRENT_NET_FD_H
+
+#include <string>
+#include <torrent/common.h>
+#include <torrent/net/types.h>
+
+namespace torrent {
+
+enum fd_flags : int {
+  fd_flag_stream = 0x1,
+  fd_flag_nonblock = 0x10,
+  fd_flag_reuse_address = 0x20,
+  fd_flag_v4only = 0x40,
+  fd_flag_v6only = 0x80,
+  fd_flag_all = 0xff,
+};
+
+constexpr bool fd_valid_flags(fd_flags flags);
+
+int  fd_open(fd_flags flags) LIBTORRENT_EXPORT;
+void fd_close(int fd) LIBTORRENT_EXPORT;
+
+fd_sap_tuple fd_accept(int fd) LIBTORRENT_EXPORT;
+
+bool fd_bind(int fd, const sockaddr* sa) LIBTORRENT_EXPORT;
+bool fd_connect(int fd, const sockaddr* sa) LIBTORRENT_EXPORT;
+bool fd_listen(int fd, int backlog) LIBTORRENT_EXPORT;
+
+bool fd_set_nonblock(int fd) LIBTORRENT_EXPORT;
+bool fd_set_reuse_address(int fd, bool state) LIBTORRENT_EXPORT;
+bool fd_set_v6only(int fd, bool state) LIBTORRENT_EXPORT;
+
+[[gnu::weak]] int fd__accept(int socket, sockaddr *address, socklen_t *address_len) LIBTORRENT_EXPORT;
+[[gnu::weak]] int fd__bind(int socket, const sockaddr *address, socklen_t address_len) LIBTORRENT_EXPORT;
+[[gnu::weak]] int fd__close(int fildes) LIBTORRENT_EXPORT;
+[[gnu::weak]] int fd__connect(int socket, const sockaddr *address, socklen_t address_len) LIBTORRENT_EXPORT;
+[[gnu::weak]] int fd__fcntl_int(int fildes, int cmd, int arg) LIBTORRENT_EXPORT;
+[[gnu::weak]] int fd__listen(int socket, int backlog) LIBTORRENT_EXPORT;
+[[gnu::weak]] int fd__setsockopt_int(int socket, int level, int option_name, int option_value) LIBTORRENT_EXPORT;
+[[gnu::weak]] int fd__socket(int domain, int type, int protocol) LIBTORRENT_EXPORT;
+
+constexpr fd_flags
+operator |(fd_flags lhs, fd_flags rhs) {
+  return static_cast<fd_flags>(static_cast<int>(lhs) | static_cast<int>(rhs));
+}
+
+inline fd_flags&
+operator |=(fd_flags& lhs, fd_flags rhs) {
+  return (lhs = lhs | rhs);
+}
+
+constexpr bool
+fd_valid_flags(fd_flags flags) {
+  return
+    (flags & fd_flag_stream) &&
+    !((flags & fd_flag_v4only) && (flags & fd_flag_v6only)) &&
+    !(flags & ~(fd_flag_all));
+}
+
+}
+
+#endif
diff --git a/src/torrent/net/socket_address.cc b/src/torrent/net/socket_address.cc
new file mode 100644
index 00000000..c36ba0ae
--- /dev/null
+++ b/src/torrent/net/socket_address.cc
@@ -0,0 +1,559 @@
+#include "config.h"
+
+#include "socket_address.h"
+
+#include <cstring>
+#include <arpa/inet.h>
+#include <sys/un.h>
+
+// TODO: Deprecate.
+#include "rak/socket_address.h"
+
+#include "torrent/exceptions.h"
+
+namespace torrent {
+
+constexpr uint32_t
+sin6_addr32_index(const sockaddr_in6* sa, unsigned int index) {
+  return
+    (sa->sin6_addr.s6_addr[index * 4 + 0] << 24) +
+    (sa->sin6_addr.s6_addr[index * 4 + 1] << 16) +
+    (sa->sin6_addr.s6_addr[index * 4 + 2] << 8) +
+    (sa->sin6_addr.s6_addr[index * 4 + 3] << 0);
+}
+
+inline void
+sin6_addr32_set(sockaddr_in6* sa, unsigned int index, uint32_t value) {
+  sa->sin6_addr.s6_addr[index * 4 + 0] = (value >> 24);
+  sa->sin6_addr.s6_addr[index * 4 + 1] = (value >> 16);
+  sa->sin6_addr.s6_addr[index * 4 + 2] = (value >> 8);
+  sa->sin6_addr.s6_addr[index * 4 + 3] = (value >> 0);
+}
+
+inline in6_addr
+sin6_make_addr32(uint32_t addr0, uint32_t addr1, uint32_t addr2, uint32_t addr3) {
+  uint32_t addr32[4];
+  addr32[0] = htonl(addr0);
+  addr32[1] = htonl(addr1);
+  addr32[2] = htonl(addr2);
+  addr32[3] = htonl(addr3);
+
+  return *reinterpret_cast<in6_addr*>(addr32);
+}
+
+bool
+sa_is_unspec(const sockaddr* sa) {
+  return sa != NULL && sa->sa_family == AF_UNSPEC;
+}
+
+bool
+sa_is_inet(const sockaddr* sa) {
+  return sa != NULL && sa->sa_family == AF_INET;
+}
+
+bool
+sa_is_inet6(const sockaddr* sa) {
+  return sa != NULL && sa->sa_family == AF_INET6;
+}
+
+bool
+sa_is_inet_inet6(const sockaddr* sa) {
+  return sa != NULL && (sa->sa_family == AF_INET || sa->sa_family == AF_INET6);
+}
+
+bool
+sa_is_any(const sockaddr* sa) {
+  switch (sa->sa_family) {
+  case AF_INET:
+    return sin_is_any(reinterpret_cast<const sockaddr_in*>(sa));
+  case AF_INET6:
+    if (sa_is_v4mapped(sa))
+      return sin6_addr32_index(reinterpret_cast<const sockaddr_in6*>(sa), 3) == htonl(INADDR_ANY);
+    return sin6_is_any(reinterpret_cast<const sockaddr_in6*>(sa));
+  default:
+    return true;
+  }
+}
+
+bool
+sin_is_any(const sockaddr_in* sa) {
+  return sa->sin_addr.s_addr == htonl(INADDR_ANY);
+}
+
+bool
+sin6_is_any(const sockaddr_in6* sa) {
+  return std::memcmp(&sa->sin6_addr, &in6addr_any, sizeof(in6_addr)) == 0;
+}
+
+bool
+sa_is_broadcast(const sockaddr* sa) {
+  switch (sa->sa_family) {
+  case AF_INET:
+    return sin_is_broadcast(reinterpret_cast<const sockaddr_in*>(sa));
+  case AF_INET6:
+    if (sa_is_v4mapped(sa))
+      return sin6_addr32_index(reinterpret_cast<const sockaddr_in6*>(sa), 3) == htonl(INADDR_BROADCAST);
+    return false;
+  default:
+    return false;
+  }
+}
+
+bool
+sin_is_broadcast(const sockaddr_in* sa) {
+  return sa->sin_addr.s_addr == htonl(INADDR_BROADCAST);
+}
+
+bool
+sa_is_v4mapped(const sockaddr* sa) {
+  return sa != NULL && sa->sa_family == AF_INET6 && sin6_is_v4mapped(reinterpret_cast<const sockaddr_in6*>(sa));
+}
+
+bool
+sin6_is_v4mapped(const sockaddr_in6* sa) {
+  return sa != NULL && IN6_IS_ADDR_V4MAPPED(&sa->sin6_addr);
+}
+
+bool
+sa_is_port_any(const sockaddr* sa) {
+  return sa_port(sa) == 0;
+}
+
+size_t
+sa_length(const sockaddr* sa) {
+  switch(sa->sa_family) {
+  case AF_INET:
+    return sizeof(sockaddr_in);
+  case AF_INET6:
+    return sizeof(sockaddr_in6);
+  default:
+    return sizeof(sa);
+  }
+}
+
+sa_unique_ptr
+sa_make_unspec() {
+  sa_unique_ptr sa(new sockaddr);
+
+  std::memset(sa.get(), 0, sizeof(sa));
+  sa.get()->sa_family = AF_UNSPEC;
+
+  return sa;
+}
+
+sa_unique_ptr
+sa_make_inet() {
+  return sa_unique_ptr(reinterpret_cast<sockaddr*>(sin_make().release()));
+}
+
+sa_unique_ptr
+sa_make_inet6() {
+  return sa_unique_ptr(reinterpret_cast<sockaddr*>(sin6_make().release()));
+}
+
+sa_unique_ptr
+sa_make_unix(const std::string& pathname) {
+  if (!pathname.empty())
+    throw internal_error("torrent::sa_make_unix: function not implemented");
+
+  sun_unique_ptr sunp(new sockaddr_un);
+
+  std::memset(sunp.get(), 0, sizeof(sockaddr_un));
+  sunp->sun_family = AF_UNIX;
+  // TODO: verify length, copy pathname
+
+  return sa_unique_ptr(reinterpret_cast<sockaddr*>(sunp.release()));
+}
+
+sa_unique_ptr
+sa_convert(const sockaddr* sa) {
+  if (sa == NULL)
+    return sa_make_unspec();
+
+  switch(sa->sa_family) {
+  case AF_INET:
+    return sa_copy_in(reinterpret_cast<const sockaddr_in*>(sa));
+  case AF_INET6:
+    if (sin6_is_v4mapped(reinterpret_cast<const sockaddr_in6*>(sa)))
+      return sa_from_v4mapped_in6(reinterpret_cast<const sockaddr_in6*>(sa));
+
+    return sa_copy_in6(reinterpret_cast<const sockaddr_in6*>(sa));
+  case AF_UNSPEC:
+    return sa_make_unspec();
+  default:
+    throw internal_error("torrent::sa_convert: sockaddr is not a valid family");
+  }
+}
+
+sa_unique_ptr
+sa_copy(const sockaddr* sa) {
+  if (sa == nullptr)
+    throw internal_error("torrent::sa_copy: sockaddr is a nullptr");
+
+  switch(sa->sa_family) {
+  case AF_INET:
+    return sa_copy_in(reinterpret_cast<const sockaddr_in*>(sa));
+  case AF_INET6:
+    return sa_copy_in6(reinterpret_cast<const sockaddr_in6*>(sa));
+  case AF_UNSPEC:
+    return sa_make_unspec();
+  default:
+    throw internal_error("torrent::sa_copy: sockaddr is not a valid family");
+  }
+}
+
+sa_unique_ptr
+sa_copy_in(const sockaddr_in* sa) {
+  sa_unique_ptr result(reinterpret_cast<sockaddr*>(new sockaddr_in));
+  std::memcpy(result.get(), sa, sizeof(sockaddr_in));
+  return result;
+}
+
+sa_unique_ptr
+sa_copy_in6(const sockaddr_in6* sa) {
+  sa_unique_ptr result(reinterpret_cast<sockaddr*>(new sockaddr_in6));
+  std::memcpy(result.get(), sa, sizeof(sockaddr_in6));
+  return result;
+}
+
+sa_unique_ptr
+sa_copy_addr(const sockaddr* sa, uint16_t port) {
+  if (sa == nullptr)
+    throw internal_error("torrent::sa_copy_addr: sockaddr is a nullptr");
+
+  switch(sa->sa_family) {
+  case AF_INET:
+    return sa_copy_addr_in(reinterpret_cast<const sockaddr_in*>(sa), port);
+  case AF_INET6:
+    return sa_copy_addr_in6(reinterpret_cast<const sockaddr_in6*>(sa), port);
+  case AF_UNSPEC:
+    return sa_make_unspec();
+  default:
+    throw internal_error("torrent::sa_copy_addr: sockaddr is not a valid family");
+  }
+}
+
+sa_unique_ptr
+sa_copy_addr_in(const sockaddr_in* sa, uint16_t port) {
+  sa_unique_ptr result(reinterpret_cast<sockaddr*>(new sockaddr_in));
+  std::memset(result.get(), 0, sizeof(sockaddr_in));
+  reinterpret_cast<sockaddr_in*>(result.get())->sin_family = AF_INET;
+  reinterpret_cast<sockaddr_in*>(result.get())->sin_addr = sa->sin_addr;
+  reinterpret_cast<sockaddr_in*>(result.get())->sin_port = htons(port);
+  return result;
+}
+
+sa_unique_ptr
+sa_copy_addr_in6(const sockaddr_in6* sa, uint16_t port) {
+  sa_unique_ptr result(reinterpret_cast<sockaddr*>(new sockaddr_in6));
+  std::memset(result.get(), 0, sizeof(sockaddr_in6));
+  reinterpret_cast<sockaddr_in6*>(result.get())->sin6_family = AF_INET6;
+  std::memcpy(&reinterpret_cast<sockaddr_in6*>(result.get())->sin6_addr, &sa->sin6_addr, sizeof(in6_addr));
+  reinterpret_cast<sockaddr_in6*>(result.get())->sin6_port = htons(port);
+  return result;
+}
+
+sin_unique_ptr
+sin_copy(const sockaddr_in* sa) {
+  sin_unique_ptr result(new sockaddr_in);
+  std::memcpy(result.get(), sa, sizeof(sockaddr_in));
+  return result;
+}
+
+sin6_unique_ptr
+sin6_copy(const sockaddr_in6* sa) {
+  sin6_unique_ptr result(new sockaddr_in6);
+  std::memcpy(result.get(), sa, sizeof(sockaddr_in6));
+  return result;
+}
+
+sin_unique_ptr
+sin_make() {
+  sin_unique_ptr sa(new sockaddr_in);
+  std::memset(sa.get(), 0, sizeof(sockaddr_in));
+  sa.get()->sin_family = AF_INET;
+
+  return sa;
+}
+
+sin6_unique_ptr
+sin6_make() {
+  sin6_unique_ptr sa(new sockaddr_in6);
+  std::memset(sa.get(), 0, sizeof(sockaddr_in6));
+  sa.get()->sin6_family = AF_INET6;
+
+  return sa;
+}
+
+sa_unique_ptr
+sa_from_v4mapped(const sockaddr* sa) {
+  if (!sa_is_inet6(sa))
+    throw internal_error("torrent::sa_from_v4mapped: sockaddr is not inet6");
+
+  return sa_from_in(sin_from_v4mapped_in6(reinterpret_cast<const sockaddr_in6*>(sa)));
+}
+
+sa_unique_ptr
+sa_to_v4mapped(const sockaddr* sa) {
+  if (!sa_is_inet(sa))
+    throw internal_error("torrent::sa_to_v4mapped: sockaddr is not inet");
+
+  return sa_from_in6(sin6_to_v4mapped_in(reinterpret_cast<const sockaddr_in*>(sa)));
+}
+
+sin_unique_ptr
+sin_from_v4mapped_in6(const sockaddr_in6* sin6) {
+  if (!sin6_is_v4mapped(sin6))
+    throw internal_error("torrent::sin6_is_v4mapped: sockaddr_in6 is not v4mapped");
+
+  sin_unique_ptr result = sin_make();
+  result.get()->sin_addr.s_addr = reinterpret_cast<in_addr_t>(htonl(sin6_addr32_index(sin6, 3)));
+  result.get()->sin_port = sin6->sin6_port;
+
+  return result;
+}
+
+sin6_unique_ptr
+sin6_to_v4mapped_in(const sockaddr_in* sin) {
+  sin6_unique_ptr result = sin6_make();
+
+  result.get()->sin6_addr = sin6_make_addr32(0, 0, 0xffff, ntohl(sin->sin_addr.s_addr));
+  result.get()->sin6_port = sin->sin_port;
+
+  return result;
+}
+
+sin_unique_ptr
+sin_from_sa(sa_unique_ptr&& sap) {
+  if (!sap_is_inet(sap))
+    throw internal_error("torrent::sin_from_sa: sockaddr is nullptr or not inet");
+
+  return sin_unique_ptr(reinterpret_cast<sockaddr_in*>(sap.release()));
+}
+
+sin6_unique_ptr
+sin6_from_sa(sa_unique_ptr&& sap) {
+  if (!sap_is_inet6(sap))
+    throw internal_error("torrent::sin6_from_sa: sockaddr is nullptr or not inet6");
+
+  return sin6_unique_ptr(reinterpret_cast<sockaddr_in6*>(sap.release()));
+}
+
+c_sin_unique_ptr
+sin_from_c_sa(c_sa_unique_ptr&& sap) {
+  if (!sap_is_inet(sap))
+    throw internal_error("torrent::sin_from_c_sa: sockaddr is nullptr or not inet");
+
+  return c_sin_unique_ptr(reinterpret_cast<const sockaddr_in*>(sap.release()));
+}
+
+c_sin6_unique_ptr
+sin6_from_c_sa(sa_unique_ptr&& sap) {
+  if (!sap_is_inet6(sap))
+    throw internal_error("torrent::sin6_from_c_sa: sockaddr is nullptr or not inet6");
+
+  return c_sin6_unique_ptr(reinterpret_cast<const sockaddr_in6*>(sap.release()));
+}
+
+void
+sa_clear_inet6(sockaddr_in6* sa) {
+  std::memset(sa, 0, sizeof(sockaddr_in6));
+  sa->sin6_family = AF_INET6;
+}
+
+uint16_t
+sa_port(const sockaddr* sa) {
+  if (sa == NULL)
+    return 0;
+
+  switch(sa->sa_family) {
+  case AF_INET:
+    return ntohs(reinterpret_cast<const sockaddr_in*>(sa)->sin_port);
+  case AF_INET6:
+    return ntohs(reinterpret_cast<const sockaddr_in6*>(sa)->sin6_port);
+  default:
+    return 0;
+  }
+}
+
+void
+sa_set_port(sockaddr* sa, uint16_t port) {
+  switch(sa->sa_family) {
+  case AF_INET:
+    reinterpret_cast<sockaddr_in*>(sa)->sin_port = htons(port);
+    return;
+  case AF_INET6:
+    reinterpret_cast<sockaddr_in6*>(sa)->sin6_port = htons(port);
+    return;
+  default:
+    throw internal_error("torrent::sa_set_port: invalid family type");
+  }
+}
+
+bool
+sa_equal(const sockaddr* lhs, const sockaddr* rhs) {
+  switch(rhs->sa_family) {
+  case AF_INET:
+  case AF_INET6:
+  case AF_UNSPEC:
+    break;
+  default:
+    throw internal_error("torrent::sa_equal: rhs sockaddr is not a valid family");
+  }
+
+  switch(lhs->sa_family) {
+  case AF_INET:
+    return lhs->sa_family == rhs->sa_family &&
+      sin_equal(reinterpret_cast<const sockaddr_in*>(lhs), reinterpret_cast<const sockaddr_in*>(rhs));
+  case AF_INET6:
+    return lhs->sa_family == rhs->sa_family &&
+      sin6_equal(reinterpret_cast<const sockaddr_in6*>(lhs), reinterpret_cast<const sockaddr_in6*>(rhs));
+  case AF_UNSPEC:
+    return lhs->sa_family == rhs->sa_family;
+  default:
+    throw internal_error("torrent::sa_equal: lhs sockaddr is not a valid family");
+  }
+}
+
+bool
+sin_equal(const sockaddr_in* lhs, const sockaddr_in* rhs) {
+  return lhs->sin_port == rhs->sin_port && lhs->sin_addr.s_addr == rhs->sin_addr.s_addr;
+}
+
+bool
+sin6_equal(const sockaddr_in6* lhs, const sockaddr_in6* rhs) {
+  return lhs->sin6_port == rhs->sin6_port && std::equal(lhs->sin6_addr.s6_addr, lhs->sin6_addr.s6_addr + 16, rhs->sin6_addr.s6_addr);
+}
+
+bool
+sa_equal_addr(const sockaddr* lhs, const sockaddr* rhs) {
+  switch(rhs->sa_family) {
+  case AF_INET:
+  case AF_INET6:
+  case AF_UNSPEC:
+    break;
+  default:
+    throw internal_error("torrent::sa_equal_addr: rhs sockaddr is not a valid family");
+  }
+
+  switch(lhs->sa_family) {
+  case AF_INET:
+    return lhs->sa_family == rhs->sa_family &&
+      sin_equal_addr(reinterpret_cast<const sockaddr_in*>(lhs), reinterpret_cast<const sockaddr_in*>(rhs));
+  case AF_INET6:
+    return lhs->sa_family == rhs->sa_family &&
+      sin6_equal_addr(reinterpret_cast<const sockaddr_in6*>(lhs), reinterpret_cast<const sockaddr_in6*>(rhs));
+  case AF_UNSPEC:
+    return lhs->sa_family == rhs->sa_family;
+  default:
+    throw internal_error("torrent::sa_equal_addr: lhs sockaddr is not a valid family");
+  }
+}
+
+bool
+sin_equal_addr(const sockaddr_in* lhs, const sockaddr_in* rhs) {
+  return lhs->sin_addr.s_addr == rhs->sin_addr.s_addr;
+}
+
+bool
+sin6_equal_addr(const sockaddr_in6* lhs, const sockaddr_in6* rhs) {
+  return std::equal(lhs->sin6_addr.s6_addr, lhs->sin6_addr.s6_addr + 16, rhs->sin6_addr.s6_addr);
+}
+
+std::string
+sa_addr_str(const sockaddr* sa) {
+  if (sa == NULL)
+    return "unspec";
+
+  switch (sa->sa_family) {
+  case AF_INET:
+    return sin_addr_str(reinterpret_cast<const sockaddr_in*>(sa));
+  case AF_INET6:
+    return sin6_addr_str(reinterpret_cast<const sockaddr_in6*>(sa));
+  case AF_UNSPEC:
+    return "unspec";
+  default:
+    return "invalid";
+  }
+}
+
+std::string
+sin_addr_str(const sockaddr_in* sa) {
+  char buffer[INET_ADDRSTRLEN];
+
+  if (inet_ntop(AF_INET, &sa->sin_addr, buffer, INET_ADDRSTRLEN) == NULL)
+    return "inet_error";
+
+  return buffer;
+}
+
+
+std::string
+sin6_addr_str(const sockaddr_in6* sa) {
+  char buffer[INET6_ADDRSTRLEN];
+
+  if (inet_ntop(AF_INET6, &sa->sin6_addr, buffer, INET6_ADDRSTRLEN) == NULL)
+    return "inet6_error";
+
+  return buffer;
+}
+
+std::string
+sa_pretty_str(const sockaddr* sa) {
+  if (sa == nullptr)
+    return "nullptr";
+
+  switch (sa->sa_family) {
+  case AF_INET:
+    return sin_pretty_str(reinterpret_cast<const sockaddr_in*>(sa));
+  case AF_INET6:
+    return sin6_pretty_str(reinterpret_cast<const sockaddr_in6*>(sa));
+  case AF_UNSPEC:
+    return "unspec";
+  default:
+    return "invalid";
+  }
+}
+
+std::string
+sin_pretty_str(const sockaddr_in* sa) {
+  auto result = sin_addr_str(sa);
+
+  if (sa->sin_port != 0)
+    result += ':' + std::to_string(ntohs(sa->sin_port));
+
+  return result;
+}
+
+std::string
+sin6_pretty_str(const sockaddr_in6* sa) {
+  auto result = "[" + sin6_addr_str(sa) + "]";
+
+  if (sa->sin6_port != 0)
+    result += ':' + std::to_string(ntohs(sa->sin6_port));
+
+  return result;
+}
+
+// Deprecated:
+
+void
+sa_inet_mapped_inet6(const sockaddr_in* sa, sockaddr_in6* mapped) {
+  uint32_t addr32[4];
+  addr32[0] = 0;
+  addr32[1] = 0;
+  addr32[2] = htonl(0xffff);
+  addr32[3] = sa->sin_addr.s_addr;
+
+  sa_clear_inet6(mapped);
+
+  mapped->sin6_addr = *reinterpret_cast<in6_addr*>(addr32);
+  mapped->sin6_port = sa->sin_port;
+}
+
+std::string
+sa_pretty_address_str(const sockaddr* sa) {
+  return sa_pretty_str(sa);
+}
+
+}
diff --git a/src/torrent/net/socket_address.h b/src/torrent/net/socket_address.h
new file mode 100644
index 00000000..f64aee68
--- /dev/null
+++ b/src/torrent/net/socket_address.h
@@ -0,0 +1,229 @@
+#ifndef LIBTORRENT_NET_SOCKET_ADDRESS_H
+#define LIBTORRENT_NET_SOCKET_ADDRESS_H
+
+#include <memory>
+#include <string>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <torrent/common.h>
+#include <torrent/net/types.h>
+
+namespace torrent {
+
+bool sa_is_unspec(const sockaddr* sa) LIBTORRENT_EXPORT;
+bool sa_is_inet(const sockaddr* sa) LIBTORRENT_EXPORT;
+bool sa_is_inet6(const sockaddr* sa) LIBTORRENT_EXPORT;
+bool sa_is_inet_inet6(const sockaddr* sa) LIBTORRENT_EXPORT;
+
+bool sa_is_any(const sockaddr* sa) LIBTORRENT_EXPORT;
+bool sin_is_any(const sockaddr_in* sa) LIBTORRENT_EXPORT;
+bool sin6_is_any(const sockaddr_in6* sa) LIBTORRENT_EXPORT;
+
+bool sa_is_broadcast(const sockaddr* sa) LIBTORRENT_EXPORT;
+bool sin_is_broadcast(const sockaddr_in* sa) LIBTORRENT_EXPORT;
+
+bool sa_is_v4mapped(const sockaddr* sa) LIBTORRENT_EXPORT;
+bool sin6_is_v4mapped(const sockaddr_in6* sa) LIBTORRENT_EXPORT;
+
+bool sa_is_port_any(const sockaddr* sa) LIBTORRENT_EXPORT;
+
+size_t sa_length(const sockaddr* sa) LIBTORRENT_EXPORT;
+
+sa_unique_ptr   sa_make_unspec() LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_make_inet() LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_make_inet6() LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_make_unix(const std::string& pathname) LIBTORRENT_EXPORT;
+
+sa_unique_ptr   sa_convert(const sockaddr* sa) LIBTORRENT_EXPORT;
+
+sa_unique_ptr   sa_copy(const sockaddr* sa) LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_copy_in(const sockaddr_in* sa) LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_copy_in6(const sockaddr_in6* sa) LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_copy_addr(const sockaddr* sa, uint16_t port = 0) LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_copy_addr_in(const sockaddr_in* sa, uint16_t port = 0) LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_copy_addr_in6(const sockaddr_in6* sa, uint16_t port = 0) LIBTORRENT_EXPORT;
+sin_unique_ptr  sin_copy(const sockaddr_in* sa) LIBTORRENT_EXPORT;
+sin6_unique_ptr sin6_copy(const sockaddr_in6* sa) LIBTORRENT_EXPORT;
+
+sin_unique_ptr  sin_make() LIBTORRENT_EXPORT;
+sin6_unique_ptr sin6_make() LIBTORRENT_EXPORT;
+
+sa_unique_ptr   sa_from_v4mapped(const sockaddr* sa) LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_to_v4mapped(const sockaddr* sa) LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_from_v4mapped_in6(const sockaddr_in6* sin6) LIBTORRENT_EXPORT;
+sa_unique_ptr   sa_to_v4mapped_in(const sockaddr_in* sin) LIBTORRENT_EXPORT;
+sin_unique_ptr  sin_from_v4mapped_in6(const sockaddr_in6* sin6) LIBTORRENT_EXPORT;
+sin6_unique_ptr sin6_to_v4mapped_in(const sockaddr_in* sin) LIBTORRENT_EXPORT;
+
+sa_unique_ptr     sa_from_in(sin_unique_ptr&& sinp) LIBTORRENT_EXPORT;
+c_sa_unique_ptr   sa_from_in(c_sin_unique_ptr&& sinp) LIBTORRENT_EXPORT;
+sa_unique_ptr     sa_from_in6(sin6_unique_ptr&& sin6p) LIBTORRENT_EXPORT;
+c_sa_unique_ptr   sa_from_in6(c_sin6_unique_ptr&& sin6p) LIBTORRENT_EXPORT;
+sin_unique_ptr    sin_from_sa(sa_unique_ptr&& sap) LIBTORRENT_EXPORT;
+sin6_unique_ptr   sin6_from_sa(sa_unique_ptr&& sap) LIBTORRENT_EXPORT;
+c_sin_unique_ptr  sin_from_c_sa(c_sa_unique_ptr&& sap) LIBTORRENT_EXPORT;
+c_sin6_unique_ptr sin6_from_c_sa(c_sa_unique_ptr&& sap) LIBTORRENT_EXPORT;
+
+void        sa_clear_inet6(sockaddr_in6* sa) LIBTORRENT_EXPORT;
+
+uint16_t    sa_port(const sockaddr* sa) LIBTORRENT_EXPORT;
+void        sa_set_port(sockaddr* sa, uint16_t port) LIBTORRENT_EXPORT;
+
+bool        sa_equal(const sockaddr* lhs, const sockaddr* rhs) LIBTORRENT_EXPORT;
+bool        sin_equal(const sockaddr_in* lhs, const sockaddr_in* rhs) LIBTORRENT_EXPORT;
+bool        sin6_equal(const sockaddr_in6* lhs, const sockaddr_in6* rhs) LIBTORRENT_EXPORT;
+
+bool        sa_equal_addr(const sockaddr* lhs, const sockaddr* rhs) LIBTORRENT_EXPORT;
+bool        sin_equal_addr(const sockaddr_in* lhs, const sockaddr_in* rhs) LIBTORRENT_EXPORT;
+bool        sin6_equal_addr(const sockaddr_in6* lhs, const sockaddr_in6* rhs) LIBTORRENT_EXPORT;
+
+std::string sa_addr_str(const sockaddr* sa) LIBTORRENT_EXPORT;
+std::string sin_addr_str(const sockaddr_in* sa) LIBTORRENT_EXPORT;
+std::string sin6_addr_str(const sockaddr_in6* sa) LIBTORRENT_EXPORT;
+
+std::string sa_pretty_str(const sockaddr* sa) LIBTORRENT_EXPORT;
+std::string sin_pretty_str(const sockaddr_in* sa) LIBTORRENT_EXPORT;
+std::string sin6_pretty_str(const sockaddr_in6* sa) LIBTORRENT_EXPORT;
+
+// Rename/replace:
+void sa_inet_mapped_inet6(const sockaddr_in* sa, sockaddr_in6* mapped) LIBTORRENT_EXPORT;
+
+std::string sa_pretty_address_str(const sockaddr* sa) LIBTORRENT_EXPORT;
+
+//
+// Tuples:
+//
+
+bool fd_sap_equal(const fd_sap_tuple& lhs, const fd_sap_tuple& rhs) LIBTORRENT_EXPORT;
+
+//
+// Safe conversion from unique_ptr arguments:
+//
+
+inline bool sap_is_unspec(const sa_unique_ptr& sap) { return sa_is_unspec(sap.get()); }
+inline bool sap_is_unspec(const c_sa_unique_ptr& sap) { return sa_is_unspec(sap.get()); }
+inline bool sap_is_inet(const c_sa_unique_ptr& sap) { return sa_is_inet(sap.get()); }
+inline bool sap_is_inet(const sa_unique_ptr& sap) { return sa_is_inet(sap.get()); }
+inline bool sap_is_inet6(const sa_unique_ptr& sap) { return sa_is_inet6(sap.get()); }
+inline bool sap_is_inet6(const c_sa_unique_ptr& sap) { return sa_is_inet6(sap.get()); }
+inline bool sap_is_inet_inet6(const sa_unique_ptr& sap) { return sa_is_inet_inet6(sap.get()); }
+inline bool sap_is_inet_inet6(const c_sa_unique_ptr& sap) { return sa_is_inet_inet6(sap.get()); }
+
+inline bool sap_is_any(const sa_unique_ptr& sap) { return sa_is_any(sap.get()); }
+inline bool sap_is_any(const c_sa_unique_ptr& sap) { return sa_is_any(sap.get()); }
+inline bool sinp_is_any(const sin_unique_ptr& sinp) { return sin_is_any(sinp.get()); }
+inline bool sinp_is_any(const c_sin_unique_ptr& sinp) { return sin_is_any(sinp.get()); }
+inline bool sinp6_is_any(const sin6_unique_ptr& sin6p) { return sin6_is_any(sin6p.get()); }
+inline bool sinp6_is_any(const c_sin6_unique_ptr& sin6p) { return sin6_is_any(sin6p.get()); }
+
+inline bool sap_is_broadcast(const sa_unique_ptr& sap) { return sa_is_broadcast(sap.get()); }
+inline bool sap_is_broadcast(const c_sa_unique_ptr& sap) { return sa_is_broadcast(sap.get()); }
+inline bool sinp_is_broadcast(const sin_unique_ptr& sap) { return sin_is_broadcast(sap.get()); }
+inline bool sinp_is_broadcast(const c_sin_unique_ptr& sap) { return sin_is_broadcast(sap.get()); }
+
+inline bool sap_is_v4mapped(const sa_unique_ptr& sap) { return sa_is_v4mapped(sap.get()); }
+inline bool sap_is_v4mapped(const c_sa_unique_ptr& sap) { return sa_is_v4mapped(sap.get()); }
+inline bool sinp6_is_v4mapped(const sin6_unique_ptr& sin6p) { return sin6_is_v4mapped(sin6p.get()); }
+inline bool sinp6_is_v4mapped(const c_sin6_unique_ptr& sin6p) { return sin6_is_v4mapped(sin6p.get()); }
+
+inline bool sap_is_port_any(const sa_unique_ptr& sap) { return sa_is_port_any(sap.get()); }
+inline bool sap_is_port_any(const c_sa_unique_ptr& sap) { return sa_is_port_any(sap.get()); }
+
+inline size_t sap_length(const sa_unique_ptr& sap) { return sa_length(sap.get()); }
+inline size_t sap_length(const c_sa_unique_ptr& sap) { return sa_length(sap.get()); }
+
+inline sa_unique_ptr sap_copy(const sa_unique_ptr& sap) { return sa_copy(sap.get()); }
+inline sa_unique_ptr sap_copy(const c_sa_unique_ptr& sap) { return sa_copy(sap.get()); }
+inline sa_unique_ptr sap_copy_addr(const sa_unique_ptr& sap, uint16_t port = 0) { return sa_copy_addr(sap.get(), port); }
+inline sa_unique_ptr sap_copy_addr(const c_sa_unique_ptr& sap, uint16_t port = 0) { return sa_copy_addr(sap.get(), port); }
+inline sa_unique_ptr sap_copy_in(const sin_unique_ptr& sinp) { return sa_copy_in(sinp.get()); }
+inline sa_unique_ptr sap_copy_in(const c_sin_unique_ptr& sinp) { return sa_copy_in(sinp.get()); }
+inline sa_unique_ptr sap_copy_in6(const sin6_unique_ptr& sin6p) { return sa_copy_in6(sin6p.get()); }
+inline sa_unique_ptr sap_copy_in6(const c_sin6_unique_ptr& sin6p) { return sa_copy_in6(sin6p.get()); }
+
+inline sa_unique_ptr   sap_from_v4mapped(const sa_unique_ptr& sap) { return sa_from_v4mapped(sap.get()); }
+inline sa_unique_ptr   sap_from_v4mapped(const c_sa_unique_ptr& sap) { return sa_from_v4mapped(sap.get()); }
+inline sa_unique_ptr   sap_to_v4mapped(const sa_unique_ptr& sap) { return sa_to_v4mapped(sap.get()); }
+inline sa_unique_ptr   sap_to_v4mapped(const c_sa_unique_ptr& sap) { return sa_to_v4mapped(sap.get()); }
+inline sin_unique_ptr  sinp_from_v4mapped_in6(const sin6_unique_ptr& sin6p) { return sin_from_v4mapped_in6(sin6p.get()); }
+inline sin_unique_ptr  sinp_from_v4mapped_in6(const c_sin6_unique_ptr& sin6p) { return sin_from_v4mapped_in6(sin6p.get()); }
+inline sin6_unique_ptr sin6p_to_v4mapped_in(const sin_unique_ptr& sinp) { return sin6_to_v4mapped_in(sinp.get()); }
+inline sin6_unique_ptr sin6p_to_v4mapped_in(const c_sin_unique_ptr& sinp) { return sin6_to_v4mapped_in(sinp.get()); }
+
+inline uint16_t sap_port(const sa_unique_ptr& sap) { return sa_port(sap.get()); }
+inline uint16_t sap_port(const c_sa_unique_ptr& sap) { return sa_port(sap.get()); }
+inline void sap_set_port(const sa_unique_ptr& sap, uint16_t port) { sa_set_port(sap.get(), port); }
+
+inline bool sap_equal(const sa_unique_ptr& lhs, const sa_unique_ptr& rhs) { return sa_equal(lhs.get(), rhs.get()); }
+inline bool sap_equal(const sa_unique_ptr& lhs, const c_sa_unique_ptr& rhs) { return sa_equal(lhs.get(), rhs.get()); }
+inline bool sap_equal(const c_sa_unique_ptr& lhs, const sa_unique_ptr& rhs) { return sa_equal(lhs.get(), rhs.get()); }
+inline bool sap_equal(const c_sa_unique_ptr& lhs, const c_sa_unique_ptr& rhs) { return sa_equal(lhs.get(), rhs.get()); }
+inline bool sinp_equal(const sin_unique_ptr& lhs, const sin_unique_ptr& rhs) { return sin_equal(lhs.get(), rhs.get()); }
+inline bool sinp_equal(const sin_unique_ptr& lhs, const c_sin_unique_ptr& rhs) { return sin_equal(lhs.get(), rhs.get()); }
+inline bool sinp_equal(const c_sin_unique_ptr& lhs, const sin_unique_ptr& rhs) { return sin_equal(lhs.get(), rhs.get()); }
+inline bool sinp_equal(const c_sin_unique_ptr& lhs, const c_sin_unique_ptr& rhs) { return sin_equal(lhs.get(), rhs.get()); }
+inline bool sin6p_equal(const sin6_unique_ptr& lhs, const sin6_unique_ptr& rhs) { return sin6_equal(lhs.get(), rhs.get()); }
+inline bool sin6p_equal(const sin6_unique_ptr& lhs, const c_sin6_unique_ptr& rhs) { return sin6_equal(lhs.get(), rhs.get()); }
+inline bool sin6p_equal(const c_sin6_unique_ptr& lhs, const sin6_unique_ptr& rhs) { return sin6_equal(lhs.get(), rhs.get()); }
+inline bool sin6p_equal(const c_sin6_unique_ptr& lhs, const c_sin6_unique_ptr& rhs) { return sin6_equal(lhs.get(), rhs.get()); }
+
+inline bool sap_equal_addr(const sa_unique_ptr& lhs, const sa_unique_ptr& rhs) { return sa_equal_addr(lhs.get(), rhs.get()); }
+inline bool sap_equal_addr(const sa_unique_ptr& lhs, const c_sa_unique_ptr& rhs) { return sa_equal_addr(lhs.get(), rhs.get()); }
+inline bool sap_equal_addr(const c_sa_unique_ptr& lhs, const sa_unique_ptr& rhs) { return sa_equal_addr(lhs.get(), rhs.get()); }
+inline bool sap_equal_addr(const c_sa_unique_ptr& lhs, const c_sa_unique_ptr& rhs) { return sa_equal_addr(lhs.get(), rhs.get()); }
+inline bool sinp_equal_addr(const sin_unique_ptr& lhs, const sin_unique_ptr& rhs) { return sin_equal_addr(lhs.get(), rhs.get()); }
+inline bool sinp_equal_addr(const sin_unique_ptr& lhs, const c_sin_unique_ptr& rhs) { return sin_equal_addr(lhs.get(), rhs.get()); }
+inline bool sinp_equal_addr(const c_sin_unique_ptr& lhs, const sin_unique_ptr& rhs) { return sin_equal_addr(lhs.get(), rhs.get()); }
+inline bool sinp_equal_addr(const c_sin_unique_ptr& lhs, const c_sin_unique_ptr& rhs) { return sin_equal_addr(lhs.get(), rhs.get()); }
+inline bool sin6p_equal_addr(const sin6_unique_ptr& lhs, const sin6_unique_ptr& rhs) { return sin6_equal_addr(lhs.get(), rhs.get()); }
+inline bool sin6p_equal_addr(const sin6_unique_ptr& lhs, const c_sin6_unique_ptr& rhs) { return sin6_equal_addr(lhs.get(), rhs.get()); }
+inline bool sin6p_equal_addr(const c_sin6_unique_ptr& lhs, const sin6_unique_ptr& rhs) { return sin6_equal_addr(lhs.get(), rhs.get()); }
+inline bool sin6p_equal_addr(const c_sin6_unique_ptr& lhs, const c_sin6_unique_ptr& rhs) { return sin6_equal_addr(lhs.get(), rhs.get()); }
+
+inline std::string sap_addr_str(const sa_unique_ptr& sap) { return sa_addr_str(sap.get()); }
+inline std::string sap_addr_str(const c_sa_unique_ptr& sap) { return sa_addr_str(sap.get()); }
+inline std::string sap_pretty_str(const sa_unique_ptr& sap) { return sa_pretty_str(sap.get()); }
+inline std::string sap_pretty_str(const c_sa_unique_ptr& sap) { return sa_pretty_str(sap.get()); }
+
+//
+// Implementations:
+//
+
+inline sa_unique_ptr
+sa_from_v4mapped_in6(const sockaddr_in6* sin6) {
+  return sa_from_in(sin_from_v4mapped_in6(sin6));
+}
+
+inline sa_unique_ptr
+sa_to_v4mapped_in(const sockaddr_in* sin) {
+  return sa_from_in6(sin6_to_v4mapped_in(sin));
+}
+
+inline sa_unique_ptr
+sa_from_in(sin_unique_ptr&& sinp) {
+  return sa_unique_ptr(reinterpret_cast<sockaddr*>(sinp.release()));
+}
+
+inline c_sa_unique_ptr
+sa_from_in(c_sin_unique_ptr&& sinp) {
+  return c_sa_unique_ptr(reinterpret_cast<const sockaddr*>(sinp.release()));
+}
+
+inline sa_unique_ptr
+sa_from_in6(sin6_unique_ptr&& sin6p) {
+  return sa_unique_ptr(reinterpret_cast<sockaddr*>(sin6p.release()));
+}
+
+inline c_sa_unique_ptr
+sa_from_in6(c_sin6_unique_ptr&& sin6p) {
+  return c_sa_unique_ptr(reinterpret_cast<const sockaddr*>(sin6p.release()));
+}
+
+inline bool
+fd_sap_equal(const fd_sap_tuple& lhs, const fd_sap_tuple& rhs) {
+  return std::get<0>(lhs) == std::get<0>(rhs) && sap_equal(std::get<1>(lhs), std::get<1>(rhs));
+}
+
+}
+
+#endif
diff --git a/src/torrent/net/socket_address_key.h b/src/torrent/net/socket_address_key.h
index 9d6e0c49..0fd0feb3 100644
--- a/src/torrent/net/socket_address_key.h
+++ b/src/torrent/net/socket_address_key.h
@@ -5,7 +5,7 @@
 #define LIBTORRENT_UTILS_SOCKET_ADDRESS_KEY_H
 
 #include <cstring>
-#include <inttypes.h>
+#include <cinttypes>
 #include <netinet/in.h>
 
 // Unique key for the socket address, excluding port numbers, etc.
diff --git a/src/torrent/net/socket_event.cc b/src/torrent/net/socket_event.cc
new file mode 100644
index 00000000..e6805290
--- /dev/null
+++ b/src/torrent/net/socket_event.cc
@@ -0,0 +1,29 @@
+#include "config.h"
+
+#include "socket_event.h"
+
+#include "torrent/exceptions.h"
+
+namespace torrent {
+
+socket_event::~socket_event() {
+  if (is_open())
+    throw internal_error("Called socket_event::~socket_event while still open on type " + std::string(type_name()));
+}
+
+void
+socket_event::event_read() {
+  throw internal_error("Called unsupported socket_event::event_read on type " + std::string(type_name()));
+}
+
+void
+socket_event::event_write() {
+  throw internal_error("Called unsupported socket_event::event_write on type " + std::string(type_name()));
+}
+
+void
+socket_event::event_error() {
+  throw internal_error("Called unsupported socket_event::event_error on type " + std::string(type_name()));
+}
+
+}
diff --git a/src/torrent/net/socket_event.h b/src/torrent/net/socket_event.h
new file mode 100644
index 00000000..d9904bd6
--- /dev/null
+++ b/src/torrent/net/socket_event.h
@@ -0,0 +1,31 @@
+#ifndef LIBTORRENT_SOCKET_EVENT_H
+#define LIBTORRENT_SOCKET_EVENT_H
+
+#include <cinttypes>
+
+#include "torrent/event.h"
+#include "torrent/net/socket_address.h"
+
+namespace torrent {
+
+class LIBTORRENT_EXPORT socket_event : public Event {
+public:
+  ~socket_event() override;
+
+  const sockaddr* socket_address() const;
+  uint16_t        socket_address_port() const;
+
+  void event_read() override;
+  void event_write() override;
+  void event_error() override;
+
+protected:
+  sa_unique_ptr m_socket_address;
+};
+
+inline const sockaddr* socket_event::socket_address() const { return m_socket_address.get(); }
+inline uint16_t        socket_event::socket_address_port() const { return sap_port(m_socket_address); }
+
+}
+
+#endif
diff --git a/src/torrent/net/types.h b/src/torrent/net/types.h
new file mode 100644
index 00000000..016e8b85
--- /dev/null
+++ b/src/torrent/net/types.h
@@ -0,0 +1,33 @@
+#ifndef LIBTORRENT_NET_TYPES_H
+#define LIBTORRENT_NET_TYPES_H
+
+#include <memory>
+#include <tuple>
+#include <sys/socket.h>
+
+struct sockaddr_in;
+struct sockaddr_in6;
+struct sockaddr_un;
+
+namespace torrent {
+
+typedef std::unique_ptr<sockaddr>     sa_unique_ptr;
+typedef std::unique_ptr<sockaddr_in>  sin_unique_ptr;
+typedef std::unique_ptr<sockaddr_in6> sin6_unique_ptr;
+typedef std::unique_ptr<sockaddr_un>  sun_unique_ptr;
+
+typedef std::unique_ptr<const sockaddr>     c_sa_unique_ptr;
+typedef std::unique_ptr<const sockaddr_in>  c_sin_unique_ptr;
+typedef std::unique_ptr<const sockaddr_in6> c_sin6_unique_ptr;
+typedef std::unique_ptr<const sockaddr_un>  c_sun_unique_ptr;
+
+typedef std::tuple<int, std::unique_ptr<sockaddr>> fd_sap_tuple;
+
+struct listen_result_type {
+  int fd;
+  sa_unique_ptr address;
+};
+
+}
+
+#endif
diff --git a/src/torrent/object.h b/src/torrent/object.h
index 3325a434..3f9fe7e4 100644
--- a/src/torrent/object.h
+++ b/src/torrent/object.h
@@ -37,8 +37,9 @@
 #ifndef LIBTORRENT_OBJECT_H
 #define LIBTORRENT_OBJECT_H
 
-#include <string>
+#include <limits>
 #include <map>
+#include <string>
 #include <vector>
 #include <torrent/common.h>
 #include <torrent/exceptions.h>
@@ -162,6 +163,7 @@ public:
   string_type&        as_string()                             { check_throw(TYPE_STRING); return _string(); }
   const string_type&  as_string() const                       { check_throw(TYPE_STRING); return _string(); }
   const string_type&  as_string_c() const                     { check_throw(TYPE_STRING); return _string(); }
+  const char*         as_c_str() const                        { check_throw(TYPE_STRING); return _string().c_str(); }
   list_type&          as_list()                               { check_throw(TYPE_LIST); return _list(); }
   const list_type&    as_list() const                         { check_throw(TYPE_LIST); return _list(); }
   map_type&           as_map()                                { check_throw(TYPE_MAP); return _map(); }
@@ -179,6 +181,8 @@ public:
   raw_map&            as_raw_map()                            { check_throw(TYPE_RAW_MAP); return _raw_map(); }
   const raw_map&      as_raw_map() const                      { check_throw(TYPE_RAW_MAP); return _raw_map(); }
 
+  template <typename T> T as_value_type(const char* err_msg) const { check_value_throw<T>(err_msg); return _value(); }
+
   bool                has_key(const key_type& k) const        { check_throw(TYPE_MAP); return _map().find(k) != _map().end(); }
   bool                has_key_value(const key_type& k) const  { check_throw(TYPE_MAP); return check(_map().find(k), TYPE_VALUE); }
   bool                has_key_string(const key_type& k) const { check_throw(TYPE_MAP); return check(_map().find(k), TYPE_STRING); }
@@ -246,6 +250,8 @@ public:
   inline bool         check(map_type::const_iterator itr, type_type t) const { return itr != _map().end() && itr->second.type() == t; }
   inline void         check_throw(type_type t) const                         { if (t != type()) throw bencode_error("Wrong object type."); }
 
+  template <typename T> void check_value_throw(const char* err_msg) const;
+
   uint32_t            m_flags;
 
 #ifndef HAVE_STDCXX_0X
@@ -484,6 +490,19 @@ object_equal(const Object& left, const Object& right) {
   }
 }
 
+template <typename T>
+inline void
+Object::check_value_throw(const char* err_msg) const {
+  if (!std::numeric_limits<T>::is_integer)
+    throw internal_error("Tried to check value with non-integer type.");
+
+  if (!is_value())
+    throw bencode_error(err_msg);
+
+  if (!(_value() >= std::numeric_limits<T>::min() && _value() <= std::numeric_limits<T>::max()))
+    throw bencode_error(err_msg);
+}
+
 }
 
 #endif
diff --git a/src/torrent/peer/client_list.cc b/src/torrent/peer/client_list.cc
index c857f62d..9c18aa50 100644
--- a/src/torrent/peer/client_list.cc
+++ b/src/torrent/peer/client_list.cc
@@ -37,8 +37,8 @@
 #include "config.h"
 
 #include <algorithm>
+#include <functional>
 #include <rak/string_manip.h>
-#include lt_tr1_functional
 
 #include "client_list.h"
 #include "exceptions.h"
diff --git a/src/torrent/peer/connection_list.h b/src/torrent/peer/connection_list.h
index ec26835f..eb058784 100644
--- a/src/torrent/peer/connection_list.h
+++ b/src/torrent/peer/connection_list.h
@@ -37,9 +37,10 @@
 #ifndef LIBTORRENT_PEER_CONNECTION_LIST_H
 #define LIBTORRENT_PEER_CONNECTION_LIST_H
 
+#include <functional>
 #include <list>
 #include <vector>
-#include lt_tr1_functional
+
 #include <torrent/common.h>
 #include <torrent/hash_string.h>
 
diff --git a/src/torrent/peer/peer_list.cc b/src/torrent/peer/peer_list.cc
index aa60939a..080a7f13 100644
--- a/src/torrent/peer/peer_list.cc
+++ b/src/torrent/peer/peer_list.cc
@@ -36,8 +36,6 @@
 
 #include "config.h"
 
-#define __STDC_FORMAT_MACROS
-
 #include <algorithm>
 #include <functional>
 #include <rak/functional.h>
@@ -56,6 +54,8 @@
 
 #define LT_LOG_EVENTS(log_fmt, ...)                                     \
   lt_log_print_info(LOG_PEER_LIST_EVENTS, m_info, "peer_list", log_fmt, __VA_ARGS__);
+#define LT_LOG_ADDRESS(log_fmt, ...)                                    \
+  lt_log_print_info(LOG_PEER_LIST_ADDRESS, m_info, "peer_list", log_fmt, __VA_ARGS__);
 #define LT_LOG_SA_FMT "'%s:%" PRIu16 "'"
 
 namespace torrent {
@@ -196,6 +196,7 @@ PeerList::insert_available(const void* al) {
   for (; itr != last; itr++) {
     if (!socket_address_key::is_comparable_sockaddr(itr->c_sockaddr()) || itr->port() == 0) {
       invalid++;
+      LT_LOG_ADDRESS("skipped invalid address " LT_LOG_SA_FMT, itr->address_str().c_str(), itr->port());
       continue;
     }
 
@@ -242,6 +243,8 @@ PeerList::insert_available(const void* al) {
 
     inserted++;
     m_available_list->push_back(&*itr);
+
+    LT_LOG_ADDRESS("added available address " LT_LOG_SA_FMT, itr->address_str().c_str(), itr->port());
   }
 
   LT_LOG_EVENTS("inserted peers"
diff --git a/src/torrent/poll.h b/src/torrent/poll.h
index b12c8ec2..15a73897 100644
--- a/src/torrent/poll.h
+++ b/src/torrent/poll.h
@@ -37,8 +37,7 @@
 #ifndef LIBTORRENT_TORRENT_POLL_H
 #define LIBTORRENT_TORRENT_POLL_H
 
-#include lt_tr1_functional
-
+#include <functional>
 #include <torrent/common.h>
 
 namespace torrent {
diff --git a/src/torrent/torrent.cc b/src/torrent/torrent.cc
index 339c2c4f..fb70d247 100644
--- a/src/torrent/torrent.cc
+++ b/src/torrent/torrent.cc
@@ -1,39 +1,3 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #include "config.h"
 
 #include <rak/address_info.h>
@@ -139,8 +103,8 @@ main_thread() {
 
 ChunkManager*      chunk_manager() { return manager->chunk_manager(); }
 ClientList*        client_list() { return manager->client_list(); }
-FileManager*       file_manager() { return manager->file_manager(); }
 ConnectionManager* connection_manager() { return manager->connection_manager(); }
+FileManager*       file_manager() { return manager->file_manager(); }
 DhtManager*        dht_manager() { return manager->dht_manager(); }
 ResourceManager*   resource_manager() { return manager->resource_manager(); }
 
@@ -189,8 +153,10 @@ download_add(Object* object) {
     download->main()->set_metadata_size(metadata_size);
   }
 
+  std::string local_id = PEER_NAME + rak::generate_random<std::string>(20 - std::string(PEER_NAME).size());
+
   download->set_hash_queue(manager->hash_queue());
-  download->initialize(infoHash, PEER_NAME + rak::generate_random<std::string>(20 - std::string(PEER_NAME).size()));
+  download->initialize(infoHash, local_id);
 
   // Add trackers, etc, after setting the info hash so that log
   // entries look sane.
diff --git a/src/torrent/torrent.h b/src/torrent/torrent.h
index 7bcf88fe..0cdfdaa7 100644
--- a/src/torrent/torrent.h
+++ b/src/torrent/torrent.h
@@ -44,6 +44,11 @@
 
 namespace torrent {
 
+class FileManager;
+class ResourceManager;
+
+class thread_base;
+
 // Make sure you seed srandom and srand48 if available.
 void                initialize() LIBTORRENT_EXPORT;
 
@@ -53,16 +58,12 @@ void                cleanup() LIBTORRENT_EXPORT;
 
 bool                is_inactive() LIBTORRENT_EXPORT;
 
-class FileManager;
-class ResourceManager;
-class thread_base;
-
 thread_base*        main_thread() LIBTORRENT_EXPORT;
 
 ChunkManager*       chunk_manager() LIBTORRENT_EXPORT;
 ClientList*         client_list() LIBTORRENT_EXPORT;
-FileManager*        file_manager() LIBTORRENT_EXPORT;
 ConnectionManager*  connection_manager() LIBTORRENT_EXPORT;
+FileManager*        file_manager() LIBTORRENT_EXPORT;
 DhtManager*         dht_manager() LIBTORRENT_EXPORT;
 ResourceManager*    resource_manager() LIBTORRENT_EXPORT;
 
diff --git a/src/torrent/tracker.h b/src/torrent/tracker.h
index a528ef6a..bd7546a9 100644
--- a/src/torrent/tracker.h
+++ b/src/torrent/tracker.h
@@ -2,7 +2,7 @@
 #define LIBTORRENT_TRACKER_H
 
 #include <string>
-#include <inttypes.h>
+#include <cinttypes>
 #include <torrent/common.h>
 
 namespace torrent {
diff --git a/src/torrent/tracker_controller.h b/src/torrent/tracker_controller.h
index 70d1b43f..9452be0f 100644
--- a/src/torrent/tracker_controller.h
+++ b/src/torrent/tracker_controller.h
@@ -37,8 +37,9 @@
 #ifndef LIBTORRENT_TRACKER_CONTROLLER_H
 #define LIBTORRENT_TRACKER_CONTROLLER_H
 
+#include <functional>
 #include <string>
-#include lt_tr1_functional
+
 #include <torrent/common.h>
 #include <torrent/tracker.h>
 
diff --git a/src/torrent/tracker_list.h b/src/torrent/tracker_list.h
index c6817b3a..bb06f8af 100644
--- a/src/torrent/tracker_list.h
+++ b/src/torrent/tracker_list.h
@@ -38,10 +38,10 @@
 #define LIBTORRENT_TRACKER_LIST_H
 
 #include <algorithm>
+#include <functional>
 #include <string>
 #include <vector>
 #include <torrent/common.h>
-#include lt_tr1_functional
 
 namespace torrent {
 
diff --git a/src/torrent/utils/Makefile.am b/src/torrent/utils/Makefile.am
index 51c9a026..a48786c6 100644
--- a/src/torrent/utils/Makefile.am
+++ b/src/torrent/utils/Makefile.am
@@ -8,10 +8,10 @@ libsub_torrentutils_la_SOURCES = \
 	log.h \
 	log_buffer.cc \
 	log_buffer.h \
-	net.cc \
-	net.h \
 	option_strings.cc \
 	option_strings.h \
+	random.cc \
+	random.h \
 	ranges.h \
 	resume.cc \
 	resume.h \
@@ -32,7 +32,6 @@ libtorrentinclude_HEADERS = \
 	extents.h \
 	log.h \
 	log_buffer.h \
-	net.h \
 	option_strings.h \
 	ranges.h \
 	resume.h \
diff --git a/src/torrent/utils/directory_events.h b/src/torrent/utils/directory_events.h
index 30fa0508..fd9246c5 100644
--- a/src/torrent/utils/directory_events.h
+++ b/src/torrent/utils/directory_events.h
@@ -37,9 +37,10 @@
 #ifndef LIBTORRENT_DIRECTORY_EVENTS_H
 #define LIBTORRENT_DIRECTORY_EVENTS_H
 
+#include <functional>
 #include <string>
 #include <vector>
-#include lt_tr1_functional
+
 #include <torrent/event.h>
 
 namespace torrent {
diff --git a/src/torrent/utils/log.cc b/src/torrent/utils/log.cc
index 6c605474..b855a2c6 100644
--- a/src/torrent/utils/log.cc
+++ b/src/torrent/utils/log.cc
@@ -1,45 +1,6 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #include "config.h"
 
-#define __STDC_FORMAT_MACROS
-
 #include "log.h"
-#include "log_buffer.h"
 
 #include "globals.h"
 #include "torrent/exceptions.h"
@@ -54,8 +15,6 @@
 #include <fstream>
 #include <functional>
 #include <memory>
-#include lt_tr1_functional
-#include lt_tr1_memory
 
 namespace torrent {
 
@@ -232,7 +191,6 @@ log_initialize() {
 
   LOG_CASCADE(LOG_CRITICAL);
 
-  LOG_CASCADE(LOG_CONNECTION_CRITICAL);
   LOG_CASCADE(LOG_PEER_CRITICAL);
   LOG_CASCADE(LOG_SOCKET_CRITICAL);
   LOG_CASCADE(LOG_STORAGE_CRITICAL);
@@ -240,7 +198,6 @@ log_initialize() {
   LOG_CASCADE(LOG_TRACKER_CRITICAL);
   LOG_CASCADE(LOG_TORRENT_CRITICAL);
 
-  LOG_CHILDREN_CASCADE(LOG_CRITICAL, LOG_CONNECTION_CRITICAL);
   LOG_CHILDREN_CASCADE(LOG_CRITICAL, LOG_PEER_CRITICAL);
   LOG_CHILDREN_CASCADE(LOG_CRITICAL, LOG_SOCKET_CRITICAL);
   LOG_CHILDREN_CASCADE(LOG_CRITICAL, LOG_STORAGE_CRITICAL);
@@ -248,6 +205,12 @@ log_initialize() {
   LOG_CHILDREN_CASCADE(LOG_CRITICAL, LOG_TRACKER_CRITICAL);
   LOG_CHILDREN_CASCADE(LOG_CRITICAL, LOG_TORRENT_CRITICAL);
 
+  LOG_LINK(LOG_CONNECTION, LOG_CONNECTION_BIND);
+  LOG_LINK(LOG_CONNECTION, LOG_CONNECTION_FD);
+  LOG_LINK(LOG_CONNECTION, LOG_CONNECTION_FILTER);
+  LOG_LINK(LOG_CONNECTION, LOG_CONNECTION_HANDSHAKE);
+  LOG_LINK(LOG_CONNECTION, LOG_CONNECTION_LISTEN);
+
   LOG_LINK(LOG_DHT_ALL, LOG_DHT_MANAGER);
   LOG_LINK(LOG_DHT_ALL, LOG_DHT_NODE);
   LOG_LINK(LOG_DHT_ALL, LOG_DHT_ROUTER);
@@ -447,21 +410,4 @@ log_open_gz_file_output(const char* name, const char* filename, bool append) {
                                   std::placeholders::_3));
 }
 
-log_buffer*
-log_open_log_buffer(const char* name) {
-  log_buffer* buffer = new log_buffer;
-
-  try {
-    log_open_output(name, std::bind(&log_buffer::lock_and_push_log, buffer,
-                                    std::placeholders::_1,
-                                    std::placeholders::_2,
-                                    std::placeholders::_3));
-    return buffer;
-
-  } catch (torrent::input_error& e) {
-    delete buffer;
-    throw;
-  }
-}
-
 }
diff --git a/src/torrent/utils/log.h b/src/torrent/utils/log.h
index 0dfdc86b..fe6127d6 100644
--- a/src/torrent/utils/log.h
+++ b/src/torrent/utils/log.h
@@ -1,47 +1,12 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #ifndef LIBTORRENT_UTILS_LOG_H
 #define LIBTORRENT_UTILS_LOG_H
 
+#include <array>
 #include <bitset>
+#include <functional>
 #include <string>
 #include <vector>
-#include lt_tr1_array
-#include lt_tr1_functional
+
 #include <torrent/common.h>
 
 namespace torrent {
@@ -55,13 +20,6 @@ enum {
   LOG_INFO,
   LOG_DEBUG,
 
-  LOG_CONNECTION_CRITICAL,
-  LOG_CONNECTION_ERROR,
-  LOG_CONNECTION_WARN,
-  LOG_CONNECTION_NOTICE,
-  LOG_CONNECTION_INFO,
-  LOG_CONNECTION_DEBUG,
-
   LOG_DHT_CRITICAL,
   LOG_DHT_ERROR,
   LOG_DHT_WARN,
@@ -113,6 +71,14 @@ enum {
 
   LOG_NON_CASCADING,
 
+  LOG_CONNECTION,
+  LOG_CONNECTION_BIND,
+  LOG_CONNECTION_FD,
+  LOG_CONNECTION_FILTER,
+  LOG_CONNECTION_HANDSHAKE,
+  LOG_CONNECTION_LISTEN,
+
+  // TODO: Rename dht_all to just dht.
   LOG_DHT_ALL,
   LOG_DHT_MANAGER,
   LOG_DHT_NODE,
@@ -125,7 +91,10 @@ enum {
   LOG_INSTRUMENTATION_POLLING,
   LOG_INSTRUMENTATION_TRANSFERS,
 
+  LOG_MOCK_CALLS,
+
   LOG_PEER_LIST_EVENTS,
+  LOG_PEER_LIST_ADDRESS,
 
   LOG_PROTOCOL_PIECE_EVENTS,
   LOG_PROTOCOL_METADATA_EVENTS,
@@ -137,6 +106,8 @@ enum {
   LOG_RPC_EVENTS,
   LOG_RPC_DUMP,
 
+  LOG_SYSTEM,
+
   LOG_UI_EVENTS,
 
   LOG_GROUP_MAX_SIZE
@@ -145,34 +116,32 @@ enum {
 #define lt_log_is_valid(log_group) (torrent::log_groups[log_group].valid())
 
 #define lt_log_print(log_group, ...)                                    \
-  if (torrent::log_groups[log_group].valid())                           \
-    torrent::log_groups[log_group].internal_print(NULL, NULL, NULL, 0, __VA_ARGS__);
+  { if (torrent::log_groups[log_group].valid())                         \
+      torrent::log_groups[log_group].internal_print(NULL, NULL, NULL, 0, __VA_ARGS__); }
 
 #define lt_log_print_info(log_group, log_info, log_subsystem, ...)      \
-  if (torrent::log_groups[log_group].valid())                           \
-    torrent::log_groups[log_group].internal_print(&log_info->hash(), log_subsystem, NULL, 0, __VA_ARGS__);
+  { if (torrent::log_groups[log_group].valid())                         \
+      torrent::log_groups[log_group].internal_print(&log_info->hash(), log_subsystem, NULL, 0, __VA_ARGS__); }
 
 #define lt_log_print_data(log_group, log_data, log_subsystem, ...)      \
-  if (torrent::log_groups[log_group].valid())                           \
-    torrent::log_groups[log_group].internal_print(&log_data->hash(), log_subsystem, NULL, 0, __VA_ARGS__);
+  { if (torrent::log_groups[log_group].valid())                         \
+      torrent::log_groups[log_group].internal_print(&log_data->hash(), log_subsystem, NULL, 0, __VA_ARGS__); }
 
 #define lt_log_print_dump(log_group, log_dump_data, log_dump_size, ...) \
-  if (torrent::log_groups[log_group].valid())                           \
-    torrent::log_groups[log_group].internal_print(NULL, NULL, log_dump_data, log_dump_size, __VA_ARGS__); \
+  { if (torrent::log_groups[log_group].valid())                         \
+      torrent::log_groups[log_group].internal_print(NULL, NULL, log_dump_data, log_dump_size, __VA_ARGS__); }
 
 #define lt_log_print_hash(log_group, log_hash, log_subsystem, ...)      \
-  if (torrent::log_groups[log_group].valid())                           \
-    torrent::log_groups[log_group].internal_print(&log_hash, log_subsystem, NULL, 0, __VA_ARGS__);
+  { if (torrent::log_groups[log_group].valid())                         \
+    torrent::log_groups[log_group].internal_print(&log_hash, log_subsystem, NULL, 0, __VA_ARGS__); }
 
 #define lt_log_print_info_dump(log_group, log_dump_data, log_dump_size, log_info, log_subsystem, ...) \
-  if (torrent::log_groups[log_group].valid())                           \
-    torrent::log_groups[log_group].internal_print(&log_info->hash(), log_subsystem, log_dump_data, log_dump_size, __VA_ARGS__); \
+  { if (torrent::log_groups[log_group].valid())                         \
+      torrent::log_groups[log_group].internal_print(&log_info->hash(), log_subsystem, log_dump_data, log_dump_size, __VA_ARGS__); }
 
 #define lt_log_print_subsystem(log_group, log_subsystem, ...)           \
-  if (torrent::log_groups[log_group].valid())                           \
-    torrent::log_groups[log_group].internal_print(NULL, log_subsystem, NULL, 0, __VA_ARGS__);
-
-class log_buffer;
+  { if (torrent::log_groups[log_group].valid())                         \
+      torrent::log_groups[log_group].internal_print(NULL, log_subsystem, NULL, 0, __VA_ARGS__); }
 
 typedef std::function<void (const char*, unsigned int, int)> log_slot;
 
@@ -222,7 +191,7 @@ private:
 
 typedef std::array<log_group, LOG_GROUP_MAX_SIZE> log_group_list;
 
-extern log_group_list  log_groups LIBTORRENT_EXPORT;
+extern log_group_list log_groups LIBTORRENT_EXPORT;
 
 void log_initialize() LIBTORRENT_EXPORT;
 void log_cleanup() LIBTORRENT_EXPORT;
@@ -237,9 +206,8 @@ void log_remove_group_output(int group, const char* name) LIBTORRENT_EXPORT;
 void log_add_child(int group, int child) LIBTORRENT_EXPORT;
 void log_remove_child(int group, int child) LIBTORRENT_EXPORT;
 
-void        log_open_file_output(const char* name, const char* filename, bool append = false) LIBTORRENT_EXPORT;
-void        log_open_gz_file_output(const char* name, const char* filename, bool append = false) LIBTORRENT_EXPORT;
-log_buffer* log_open_log_buffer(const char* name) LIBTORRENT_EXPORT;
+void log_open_file_output(const char* name, const char* filename, bool append = false) LIBTORRENT_EXPORT;
+void log_open_gz_file_output(const char* name, const char* filename, bool append = false) LIBTORRENT_EXPORT;
 
 //
 // Implementation:
diff --git a/src/torrent/utils/log_buffer.cc b/src/torrent/utils/log_buffer.cc
index f82d57e0..5bf159a4 100644
--- a/src/torrent/utils/log_buffer.cc
+++ b/src/torrent/utils/log_buffer.cc
@@ -1,46 +1,8 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
 #include "config.h"
 
 #include "log_buffer.h"
 
-#include <functional>
-#include lt_tr1_functional
-
+#include "log.h"
 #include "globals.h"
 
 namespace torrent {
@@ -72,4 +34,19 @@ log_buffer::lock_and_push_log(const char* data, size_t length, int group) {
   unlock();
 }
 
+static void
+log_buffer_deleter(log_buffer* lb) {
+  delete lb;
+}
+
+log_buffer_ptr
+log_open_log_buffer(const char* name) {
+  // TODO: Deregister when deleting.
+  auto buffer = log_buffer_ptr(new log_buffer, std::bind(&log_buffer_deleter, std::placeholders::_1));
+
+  log_open_output(name, std::bind(&log_buffer::lock_and_push_log, buffer.get(),
+                                  std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));
+  return buffer;
+}
+
 }
diff --git a/src/torrent/utils/log_buffer.h b/src/torrent/utils/log_buffer.h
index befd780b..259e5910 100644
--- a/src/torrent/utils/log_buffer.h
+++ b/src/torrent/utils/log_buffer.h
@@ -1,47 +1,11 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
-#ifndef LIBTORRENT_UTILS_LOG_BUFFER_H
-#define LIBTORRENT_UTILS_LOG_BUFFER_H
+#ifndef LIBTORRENT_TORRENT_UTILS_LOG_BUFFER_H
+#define LIBTORRENT_TORRENT_UTILS_LOG_BUFFER_H
 
 #include <string>
 #include <deque>
+#include <functional>
+#include <memory>
 #include <pthread.h>
-#include lt_tr1_functional
-#include <torrent/common.h>
 
 namespace torrent {
 
@@ -57,9 +21,9 @@ struct log_entry {
   std::string message;
 };
 
-class LIBTORRENT_EXPORT log_buffer : private std::deque<log_entry> {
+class [[gnu::visibility("default")]] log_buffer : private std::deque<log_entry> {
 public:
-  typedef std::deque<log_entry>       base_type;
+  typedef std::deque<log_entry>  base_type;
   typedef std::function<void ()> slot_void;
 
   using base_type::iterator;
@@ -97,6 +61,10 @@ private:
   slot_void           m_slot_update;
 };
 
+typedef std::unique_ptr<log_buffer, std::function<void (log_buffer*)>> log_buffer_ptr;
+
+[[gnu::visibility("default")]] log_buffer_ptr log_open_log_buffer(const char* name);
+
 }
 
 #endif
diff --git a/src/torrent/utils/net.cc b/src/torrent/utils/net.cc
deleted file mode 100644
index 83c9b506..00000000
--- a/src/torrent/utils/net.cc
+++ /dev/null
@@ -1,72 +0,0 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
-#include "config.h"
-
-#include "net.h"
-#include "exceptions.h"
-
-#include <cstring>
-
-namespace torrent {
-
-addrinfo*
-address_info_lookup(const char* hostname, int family, int socktype) {
-  addrinfo hints;
-  std::memset(&hints, 0, sizeof(addrinfo));
-  hints.ai_family = family;
-  hints.ai_socktype = socktype;
-  
-  addrinfo* res = NULL;
-  int err = ::getaddrinfo(hostname, NULL, &hints, &res);
-
-  if (err)
-    throw address_info_error(err);
-
-  return res;
-}
-
-bool
-address_info_call(addrinfo* ai, int flags, slot_ai_success slot_success) {
-  while (ai != NULL) {
-    slot_success(ai->ai_addr, ai->ai_addrlen);
-    return true;
-  }
-
-  return false;
-}
-
-}
diff --git a/src/torrent/utils/net.h b/src/torrent/utils/net.h
deleted file mode 100644
index f5af7cc0..00000000
--- a/src/torrent/utils/net.h
+++ /dev/null
@@ -1,56 +0,0 @@
-// libTorrent - BitTorrent library
-// Copyright (C) 2005-2011, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
-#ifndef LIBTORRENT_UTILS_NET_H
-#define LIBTORRENT_UTILS_NET_H
-
-#include <netdb.h>
-#include lt_tr1_functional
-
-namespace torrent {
-
-typedef std::function<void (sockaddr*, socklen_t)> slot_ai_success;
-//typedef std::function<void (const char*, int)>     slot_ai_failure;
-
-// Throws address_info_error on lookup failure.
-addrinfo*   address_info_lookup(const char* hostname, int family, int socktype);
-inline void address_info_free(addrinfo* ai) { ::freeaddrinfo(ai); }
-
-bool        address_info_call(addrinfo* ai, int flags, slot_ai_success slot_success);
-
-}
-
-#endif
diff --git a/src/torrent/utils/option_strings.cc b/src/torrent/utils/option_strings.cc
index 5992cf37..101e2688 100644
--- a/src/torrent/utils/option_strings.cc
+++ b/src/torrent/utils/option_strings.cc
@@ -62,7 +62,7 @@ struct option_pair {
   unsigned int value;
 };
 
-option_pair option_list_connection[] = {
+option_pair option_list_connection_type[] = {
   { "leech",        Download::CONNECTION_LEECH },
   { "seed",         Download::CONNECTION_SEED },
   { "initial_seed", Download::CONNECTION_INITIAL_SEED },
@@ -124,6 +124,19 @@ option_pair option_list_tracker_mode[] = {
   { NULL, 0 }
 };
 
+const char* option_list_handshake_connection[] = {
+  "none",
+  "incoming",
+  "outgoing_normal",
+  "outgoing_encrypted",
+  "outgoing_proxy",
+  "success",
+  "dropped",
+  "failed",
+  "retry_plaintext",
+  "retry_encrypted"
+};
+
 const char* option_list_log_group[] = {
   "critical",
   "error",
@@ -132,13 +145,6 @@ const char* option_list_log_group[] = {
   "info",
   "debug",
   
-  "connection_critical",
-  "connection_error",
-  "connection_warn",
-  "connection_notice",
-  "connection_info",
-  "connection_debug",
-  
   "dht_critical",
   "dht_error",
   "dht_warn",
@@ -190,6 +196,13 @@ const char* option_list_log_group[] = {
 
   "__non_cascading__",
 
+  "connection",
+  "connection_bind",
+  "connection_fd",
+  "connection_filter",
+  "connection_hanshake",
+  "connection_listen",
+
   "dht_all",
   "dht_manager",
   "dht_node",
@@ -202,7 +215,10 @@ const char* option_list_log_group[] = {
   "instrumentation_polling",
   "instrumentation_transfers",
 
+  "mock_calls",
+
   "peer_list_events",
+  "peer_list_address",
 
   "protocol_piece_events",
   "protocol_metadata_events",
@@ -214,6 +230,8 @@ const char* option_list_log_group[] = {
   "rpc_events",
   "rpc_dump",
 
+  "system",
+
   "ui_events",
 
   NULL
@@ -230,7 +248,7 @@ const char* option_list_tracker_event[] = {
 };
 
 option_pair* option_pair_lists[OPTION_START_COMPACT] = {
-  option_list_connection,
+  option_list_connection_type,
   option_list_heuristics,
   option_list_heuristics_download,
   option_list_heuristics_upload,
@@ -244,6 +262,7 @@ option_pair* option_pair_lists[OPTION_START_COMPACT] = {
   { sizeof(single_name) / sizeof(const char*) - 1, single_name }
 
 option_single option_single_lists[OPTION_SINGLE_SIZE] = {
+  OPTION_SINGLE_ENTRY(option_list_handshake_connection),
   OPTION_SINGLE_ENTRY(option_list_log_group),
   OPTION_SINGLE_ENTRY(option_list_tracker_event),
 };
@@ -267,11 +286,11 @@ option_find_string(option_enum opt_enum, const char* name) {
     } while (*++itr != NULL);
   }
 
-  throw input_error("Invalid option name.");  
+  throw input_error("Invalid option name.");
 }
 
 const char*
-option_as_string(option_enum opt_enum, unsigned int value) {
+option_to_string(option_enum opt_enum, unsigned int value, const char* not_found) {
   if (opt_enum < OPTION_START_COMPACT) {
     option_pair* itr = option_pair_lists[opt_enum];
   
@@ -285,7 +304,27 @@ option_as_string(option_enum opt_enum, unsigned int value) {
       return option_single_lists[opt_enum - OPTION_START_COMPACT].name[value];
   }
 
-  throw input_error("Invalid option value.");  
+  return not_found;
+}
+
+const char*
+option_to_string_or_throw(option_enum opt_enum, unsigned int value, const char* not_found) {
+  const char* result = option_to_string(opt_enum, value, NULL);
+
+  if (result == NULL)
+    throw input_error(not_found);
+  else
+    return result;
+}
+
+const char*
+option_as_string(option_enum opt_enum, unsigned int value) {
+  const char* result = option_to_string(opt_enum, value, NULL);
+
+  if (result == NULL)
+    throw input_error("Invalid option value.");
+  else
+    return result;
 }
 
 torrent::Object
diff --git a/src/torrent/utils/option_strings.h b/src/torrent/utils/option_strings.h
index 1b57efa8..f9e5ef77 100644
--- a/src/torrent/utils/option_strings.h
+++ b/src/torrent/utils/option_strings.h
@@ -54,17 +54,22 @@ enum option_enum {
   OPTION_IP_TOS,
   OPTION_TRACKER_MODE,
 
+  OPTION_HANDSHAKE_CONNECTION,
   OPTION_LOG_GROUP,
   OPTION_TRACKER_EVENT,
 
   OPTION_MAX_SIZE,
-  OPTION_START_COMPACT = OPTION_LOG_GROUP,
+  OPTION_START_COMPACT = OPTION_HANDSHAKE_CONNECTION,
   OPTION_SINGLE_SIZE = OPTION_MAX_SIZE - OPTION_START_COMPACT
 };
 
 int             option_find_string(option_enum opt_enum, const char* name) LIBTORRENT_EXPORT;
 inline int      option_find_string_str(option_enum opt_enum, const std::string& name) { return option_find_string(opt_enum, name.c_str()); }
 
+const char*     option_to_string(option_enum opt_enum, unsigned int value, const char* not_found = "invalid") LIBTORRENT_EXPORT;
+const char*     option_to_string_or_throw(option_enum opt_enum, unsigned int value, const char* not_found = "Invalid option value") LIBTORRENT_EXPORT;
+
+// TODO: Deprecated.
 const char*     option_as_string(option_enum opt_enum, unsigned int value) LIBTORRENT_EXPORT;
 
 torrent::Object option_list_strings(option_enum opt_enum) LIBTORRENT_EXPORT;
diff --git a/src/torrent/utils/random.cc b/src/torrent/utils/random.cc
new file mode 100644
index 00000000..6a045429
--- /dev/null
+++ b/src/torrent/utils/random.cc
@@ -0,0 +1,29 @@
+#include "config.h"
+
+#include "random.h"
+
+#include "torrent/exceptions.h"
+
+namespace torrent {
+
+// TODO: Replace with std and thread_local generator.
+
+template <typename T>
+T
+random_uniform_template(T min, T max) {
+  if (min > max)
+    throw internal_error("random_uniform: min > max");
+
+  if (min == max)
+    return min;
+
+  std::random_device rd;
+  std::mt19937 mt(rd());
+
+  return min + std::uniform_int_distribution<T>(min, max)(mt) % (max - min + 1);
+}  
+
+uint16_t random_uniform_uint16(uint16_t min, uint16_t max) { return random_uniform_template<uint16_t>(min, max); }
+uint32_t random_uniform_uint32(uint32_t min, uint32_t max) { return random_uniform_template<uint32_t>(min, max); }
+
+}
diff --git a/src/torrent/utils/random.h b/src/torrent/utils/random.h
new file mode 100644
index 00000000..d5992ab6
--- /dev/null
+++ b/src/torrent/utils/random.h
@@ -0,0 +1,15 @@
+#ifndef LIBTORRENT_TORRENT_UTILS_RANDOM_H
+#define LIBTORRENT_TORRENT_UTILS_RANDOM_H
+
+#include <cinttypes>
+#include <limits>
+#include <random>
+
+namespace torrent {
+
+[[gnu::weak]] [[gnu::visibility("default")]] uint16_t random_uniform_uint16(uint16_t min = std::numeric_limits<uint16_t>::min(), uint16_t max = std::numeric_limits<uint16_t>::max());
+[[gnu::weak]] [[gnu::visibility("default")]] uint32_t random_uniform_uint32(uint32_t min = std::numeric_limits<uint32_t>::min(), uint32_t max = std::numeric_limits<uint32_t>::max());
+
+}
+
+#endif
diff --git a/src/torrent/utils/ranges.h b/src/torrent/utils/ranges.h
index e784b084..7b1f8cb0 100644
--- a/src/torrent/utils/ranges.h
+++ b/src/torrent/utils/ranges.h
@@ -40,7 +40,6 @@
 #include <algorithm>
 #include <vector>
 
-// TODO: Use tr1 functional instead.
 #include <rak/functional.h>
 
 namespace torrent {
diff --git a/src/torrent/utils/resume.cc b/src/torrent/utils/resume.cc
index 3f528c14..f8467d54 100644
--- a/src/torrent/utils/resume.cc
+++ b/src/torrent/utils/resume.cc
@@ -34,8 +34,6 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
-#define __STDC_FORMAT_MACROS
-
 #include "config.h"
 
 #include <rak/file_stat.h>
diff --git a/src/torrent/utils/signal_bitfield.h b/src/torrent/utils/signal_bitfield.h
index b9f57a60..ffa336d2 100644
--- a/src/torrent/utils/signal_bitfield.h
+++ b/src/torrent/utils/signal_bitfield.h
@@ -37,7 +37,8 @@
 #ifndef LIBTORRENT_UTILS_SIGNAL_BITFIELD_H
 #define LIBTORRENT_UTILS_SIGNAL_BITFIELD_H
 
-#include lt_tr1_functional
+#include <functional>
+
 #include <torrent/common.h>
 
 namespace torrent {
diff --git a/src/torrent/utils/thread_base.h b/src/torrent/utils/thread_base.h
index bfd443ae..b92a98ba 100644
--- a/src/torrent/utils/thread_base.h
+++ b/src/torrent/utils/thread_base.h
@@ -37,11 +37,12 @@
 #ifndef LIBTORRENT_UTILS_THREAD_BASE_H
 #define LIBTORRENT_UTILS_THREAD_BASE_H
 
+#include <functional>
 #include <pthread.h>
 #include <sys/types.h>
+
 #include <torrent/common.h>
 #include <torrent/utils/signal_bitfield.h>
-#include lt_tr1_functional
 
 namespace torrent {
 
diff --git a/src/utils/instrumentation.cc b/src/utils/instrumentation.cc
index 729b20e2..178d6a19 100644
--- a/src/utils/instrumentation.cc
+++ b/src/utils/instrumentation.cc
@@ -36,8 +36,6 @@
 
 #include "config.h"
 
-#define __STDC_FORMAT_MACROS
-
 #include "instrumentation.h"
 
 namespace torrent {
diff --git a/src/utils/instrumentation.h b/src/utils/instrumentation.h
index 956429bf..11e77f6d 100644
--- a/src/utils/instrumentation.h
+++ b/src/utils/instrumentation.h
@@ -37,9 +37,8 @@
 #ifndef LIBTORRENT_UTILS_INSTRUMENTATION_H
 #define LIBTORRENT_UTILS_INSTRUMENTATION_H
 
-#include lt_tr1_array
-
 #include <algorithm>
+#include <array>
 
 #include "torrent/common.h"
 #include "torrent/utils/log.h"
diff --git a/src/utils/queue_buckets.h b/src/utils/queue_buckets.h
index de8584ff..b9174f27 100644
--- a/src/utils/queue_buckets.h
+++ b/src/utils/queue_buckets.h
@@ -38,9 +38,9 @@
 #define LIBTORRENT_QUEUE_BUCKETS_H
 
 #include <algorithm>
+#include <array>
 #include <deque>
-#include lt_tr1_functional
-#include lt_tr1_array
+#include <functional>
 
 namespace torrent {
 
diff --git a/src/utils/sha_fast.h b/src/utils/sha_fast.h
index f7ce3b87..eb357864 100644
--- a/src/utils/sha_fast.h
+++ b/src/utils/sha_fast.h
@@ -41,7 +41,7 @@
 #ifndef _SHA_FAST_H_
 #define _SHA_FAST_H_
 
-#include <inttypes.h>
+#include <cinttypes>
 
 namespace torrent {
 
diff --git a/test/Makefile.am b/test/Makefile.am
index d7a9d5b3..b60a86a6 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -18,6 +18,17 @@ LibTorrentTest_LDADD = \
 	../src/torrent/utils/libsub_torrentutils.la
 
 LibTorrentTest_SOURCES = \
+	helpers/expect_fd.h \
+	helpers/expect_utils.h \
+	helpers/mock_compare.h \
+	helpers/mock_function.cc \
+	helpers/mock_function.h \
+	helpers/network.h \
+	helpers/progress_listener.cc \
+	helpers/progress_listener.h \
+	helpers/test_fixture.cc \
+	helpers/test_fixture.h \
+	\
 	../src/thread_disk.cc \
 	../src/thread_disk.h \
 	\
@@ -31,22 +42,28 @@ LibTorrentTest_SOURCES = \
 	data/hash_check_queue_test.h \
 	data/hash_queue_test.cc \
 	data/hash_queue_test.h \
+	\
+	net/test_socket_listen.cc \
+	net/test_socket_listen.h \
+	\
 	protocol/test_request_list.cc \
 	protocol/test_request_list.h \
 	\
-	torrent/net/test_socket_address_key.cc \
-	torrent/net/test_socket_address_key.h \
+	torrent/net/test_address_info.cc \
+	torrent/net/test_address_info.h \
+	torrent/net/test_fd.cc \
+	torrent/net/test_fd.h \
+	torrent/net/test_socket_address.cc \
+	torrent/net/test_socket_address.h \
 	\
 	torrent/utils/log_test.cc \
 	torrent/utils/log_test.h \
-	torrent/utils/log_buffer_test.cc \
-	torrent/utils/log_buffer_test.h \
-	torrent/utils/net_test.cc \
-	torrent/utils/net_test.h \
 	torrent/utils/option_strings_test.cc \
 	torrent/utils/option_strings_test.h \
 	torrent/utils/test_extents.cc \
 	torrent/utils/test_extents.h \
+	torrent/utils/test_log_buffer.cc \
+	torrent/utils/test_log_buffer.h \
 	torrent/utils/test_queue_buckets.cc \
 	torrent/utils/test_queue_buckets.h \
 	torrent/utils/test_uri_parser.cc \
diff --git a/test/data/hash_check_queue_test.cc b/test/data/hash_check_queue_test.cc
index c6bdeaec..4b15245e 100644
--- a/test/data/hash_check_queue_test.cc
+++ b/test/data/hash_check_queue_test.cc
@@ -1,7 +1,7 @@
 #include "config.h"
 
+#include <functional>
 #include <signal.h>
-#include lt_tr1_functional
 
 #include "data/hash_queue_node.h"
 #include "utils/sha1.h"
diff --git a/test/data/hash_queue_test.cc b/test/data/hash_queue_test.cc
index 287c28e9..d7ce3ba8 100644
--- a/test/data/hash_queue_test.cc
+++ b/test/data/hash_queue_test.cc
@@ -1,7 +1,7 @@
 #include "config.h"
 
+#include <functional>
 #include <signal.h>
-#include lt_tr1_functional
 
 #include "data/hash_queue_node.h"
 #include "torrent/chunk_manager.h"
diff --git a/test/helpers/expect_fd.h b/test/helpers/expect_fd.h
new file mode 100644
index 00000000..178cbabc
--- /dev/null
+++ b/test/helpers/expect_fd.h
@@ -0,0 +1,107 @@
+#ifndef LIBTORRENT_HELPER_EXPECT_FD_H
+#define LIBTORRENT_HELPER_EXPECT_FD_H
+
+#include "helpers/mock_function.h"
+
+#include <fcntl.h>
+#include <torrent/event.h>
+#include <torrent/net/fd.h>
+#include <torrent/net/socket_address.h>
+
+typedef std::vector<torrent::sa_unique_ptr> sap_cache_type;
+
+inline const sockaddr*
+sap_cache_copy_addr_c_ptr(sap_cache_type& sap_cache, const torrent::c_sa_unique_ptr& sap, uint16_t port = 0) {
+  sap_cache.push_back(torrent::sap_copy_addr(sap, port));
+  return sap_cache.back().get();
+}
+
+inline void
+expect_event_open_re(int idx) {
+  mock_expect(&torrent::poll_event_open, mock_compare_map<torrent::Event>::begin_pointer + idx);
+  mock_expect(&torrent::poll_event_insert_read, mock_compare_map<torrent::Event>::begin_pointer + idx);
+  mock_expect(&torrent::poll_event_insert_error, mock_compare_map<torrent::Event>::begin_pointer + idx);
+}
+
+inline void
+expect_event_closed_fd(int idx, int fd) {
+  mock_expect(&torrent::fd__close, 0, fd);
+  mock_expect(&torrent::poll_event_closed, mock_compare_map<torrent::Event>::begin_pointer + idx);
+}
+
+inline void
+expect_fd_inet_tcp(int fd) {
+  mock_expect(&torrent::fd__socket, fd, (int)PF_INET, (int)SOCK_STREAM, (int)IPPROTO_TCP);
+}
+
+inline void
+expect_fd_inet6_tcp(int fd) {
+  mock_expect(&torrent::fd__socket, fd, (int)PF_INET6, (int)SOCK_STREAM, (int)IPPROTO_TCP);
+}
+
+inline void
+expect_fd_inet_tcp_nonblock(int fd) {
+  mock_expect(&torrent::fd__socket, fd, (int)PF_INET, (int)SOCK_STREAM, (int)IPPROTO_TCP);
+  mock_expect(&torrent::fd__fcntl_int, 0, fd, F_SETFL, O_NONBLOCK);
+}
+
+inline void
+expect_fd_inet6_tcp_nonblock(int fd) {
+  mock_expect(&torrent::fd__socket, fd, (int)PF_INET6, (int)SOCK_STREAM, (int)IPPROTO_TCP);
+  mock_expect(&torrent::fd__fcntl_int, 0, fd, F_SETFL, O_NONBLOCK);
+}
+
+inline void
+expect_fd_inet_tcp_nonblock_reuseaddr(int fd) {
+  mock_expect(&torrent::fd__socket, fd, (int)PF_INET, (int)SOCK_STREAM, (int)IPPROTO_TCP);
+  mock_expect(&torrent::fd__fcntl_int, 0, fd, F_SETFL, O_NONBLOCK);
+  mock_expect(&torrent::fd__setsockopt_int, 0, fd, (int)SOL_SOCKET, (int)SO_REUSEADDR, (int)true);
+}
+
+inline void
+expect_fd_inet6_tcp_nonblock_reuseaddr(int fd) {
+  mock_expect(&torrent::fd__socket, fd, (int)PF_INET6, (int)SOCK_STREAM, (int)IPPROTO_TCP);
+  mock_expect(&torrent::fd__fcntl_int, 0, fd, F_SETFL, O_NONBLOCK);
+  mock_expect(&torrent::fd__setsockopt_int, 0, fd, (int)SOL_SOCKET, (int)SO_REUSEADDR, (int)true);
+}
+
+inline void
+expect_fd_inet6_tcp_v6only_nonblock(int fd) {
+  mock_expect(&torrent::fd__socket, fd, (int)PF_INET6, (int)SOCK_STREAM, (int)IPPROTO_TCP);
+  mock_expect(&torrent::fd__setsockopt_int, 0, fd, (int)IPPROTO_IPV6, (int)IPV6_V6ONLY, (int)true);
+  mock_expect(&torrent::fd__fcntl_int, 0, fd, F_SETFL, O_NONBLOCK);
+}
+
+inline void
+expect_fd_inet6_tcp_v6only_nonblock_reuseaddr(int fd) {
+  mock_expect(&torrent::fd__socket, fd, (int)PF_INET6, (int)SOCK_STREAM, (int)IPPROTO_TCP);
+  mock_expect(&torrent::fd__setsockopt_int, 0, fd, (int)IPPROTO_IPV6, (int)IPV6_V6ONLY, (int)true);
+  mock_expect(&torrent::fd__fcntl_int, 0, fd, F_SETFL, O_NONBLOCK);
+  mock_expect(&torrent::fd__setsockopt_int, 0, fd, (int)SOL_SOCKET, (int)SO_REUSEADDR, (int)true);
+}
+
+inline void
+expect_fd_bind_connect(int fd, const torrent::c_sa_unique_ptr& bind_sap, const torrent::c_sa_unique_ptr& connect_sap) {
+  mock_expect(&torrent::fd__bind, 0, fd, bind_sap.get(), (socklen_t)torrent::sap_length(bind_sap));
+  mock_expect(&torrent::fd__connect, 0, fd, connect_sap.get(), (socklen_t)torrent::sap_length(connect_sap));
+}
+
+inline void
+expect_fd_bind_fail_range(int fd, sap_cache_type& sap_cache, const torrent::c_sa_unique_ptr& sap, uint16_t first_port, uint16_t last_port) {
+  do {
+    mock_expect(&torrent::fd__bind, -1, fd, sap_cache_copy_addr_c_ptr(sap_cache, sap, first_port), (socklen_t)torrent::sap_length(sap));
+  } while (first_port++ != last_port);
+}
+
+inline void
+expect_fd_bind_listen(int fd, const torrent::c_sa_unique_ptr& sap) {
+  mock_expect(&torrent::fd__bind, 0, fd, sap.get(), (socklen_t)torrent::sap_length(sap));
+  mock_expect(&torrent::fd__listen, 0, fd, SOMAXCONN);
+}
+
+inline void
+expect_fd_connect(int fd, const torrent::c_sa_unique_ptr& sap) {
+  mock_expect(&torrent::fd__connect, 0, fd, sap.get(), (socklen_t)torrent::sap_length(sap));
+}
+
+#endif
diff --git a/test/helpers/expect_utils.h b/test/helpers/expect_utils.h
new file mode 100644
index 00000000..c84a11e0
--- /dev/null
+++ b/test/helpers/expect_utils.h
@@ -0,0 +1,13 @@
+#ifndef LIBTORRENT_HELPER_EXPECT_UTILS_H
+#define LIBTORRENT_HELPER_EXPECT_UTILS_H
+
+#include "helpers/mock_function.h"
+
+#include <torrent/utils/random.h>
+
+inline void
+expect_random_uniform_uint16(uint16_t result, uint16_t first, uint16_t last) {
+  mock_expect(&torrent::random_uniform_uint16, result, first, last);
+}
+
+#endif
diff --git a/test/helpers/mock_compare.h b/test/helpers/mock_compare.h
new file mode 100644
index 00000000..3ea90305
--- /dev/null
+++ b/test/helpers/mock_compare.h
@@ -0,0 +1,96 @@
+#ifndef LIBTORRENT_HELPERS_MOCK_COMPARE_H
+#define LIBTORRENT_HELPERS_MOCK_COMPARE_H
+
+#include <algorithm>
+#include <type_traits>
+#include <torrent/event.h>
+#include <torrent/net/socket_address.h>
+
+// Compare arguments to mock functions with what is expected. The lhs
+// are the expected arguments, rhs are the ones called with.
+
+template <typename Arg>
+inline bool mock_compare_arg(Arg lhs, Arg rhs) { return lhs == rhs; }
+
+template <int I, typename A, typename... Args>
+typename std::enable_if<I == 1, int>::type
+mock_compare_tuple(const std::tuple<A, Args...>& lhs, const std::tuple<Args...>& rhs) {
+  return mock_compare_arg(std::get<I>(lhs), std::get<I - 1>(rhs)) ? 0 : 1;
+}
+
+template <int I, typename A, typename... Args>
+typename std::enable_if<1 < I, int>::type
+mock_compare_tuple(const std::tuple<A, Args...>& lhs, const std::tuple<Args...>& rhs) {
+  auto res = mock_compare_tuple<I - 1>(lhs, rhs);
+
+  if (res != 0)
+    return res;
+
+  return mock_compare_arg(std::get<I>(lhs), std::get<I - 1>(rhs)) ? 0 : I;
+}
+
+//template <typename T, typename std::enable_if<!std::is_const<T>::value, int>::type = 0>
+template <typename T>
+struct mock_compare_map {
+  typedef std::map<const T*, const T*> values_type;
+
+  constexpr static T* begin_pointer = reinterpret_cast<T*>(0x1000);
+  constexpr static T* end_pointer = reinterpret_cast<T*>(0x2000);
+
+  static bool is_key(const T* k) {
+    return k >= begin_pointer && k < end_pointer;
+  }
+
+  static bool has_key(const T* k) {
+    return values.find(k) != values.end();
+  }
+
+  static bool has_value(const T* v) {
+    return std::find_if(values.begin(), values.end(), [v](typename values_type::value_type& kv) { return v == kv.second; }) != values.end();
+  }
+
+  static const T* get(const T* k) {
+    auto itr = values.find(k);
+    CPPUNIT_ASSERT_MESSAGE("mock_compare_map get failed, not inserted", itr != values.end());
+    return itr->second;
+  }
+
+  static values_type values;
+};
+
+template<typename T>
+typename mock_compare_map<T>::values_type mock_compare_map<T>::values;
+
+template<typename T>
+void mock_compare_add(T* v) {
+  mock_compare_map<T>::add_value(v);
+}
+
+//
+// Specialize:
+//
+
+template <>
+inline bool mock_compare_arg<sockaddr*>(sockaddr* lhs, sockaddr* rhs) {
+  return lhs != nullptr && rhs != nullptr && torrent::sa_equal(lhs, rhs);
+}
+template <>
+inline bool mock_compare_arg<const sockaddr*>(const sockaddr* lhs, const sockaddr* rhs) {
+  return lhs != nullptr && rhs != nullptr && torrent::sa_equal(lhs, rhs);
+}
+
+template <>
+inline bool mock_compare_arg<torrent::Event*>(torrent::Event* lhs, torrent::Event* rhs) {
+  if (mock_compare_map<torrent::Event>::is_key(lhs)) {
+    if (!mock_compare_map<torrent::Event>::has_value(rhs)) {
+      mock_compare_map<torrent::Event>::values[lhs] = rhs;
+      return true;
+    }
+    
+    return mock_compare_map<torrent::Event>::has_key(lhs) && mock_compare_map<torrent::Event>::get(lhs) == rhs;
+  }
+  
+  return lhs == rhs;
+}
+
+#endif
diff --git a/test/helpers/mock_function.cc b/test/helpers/mock_function.cc
new file mode 100644
index 00000000..83e81551
--- /dev/null
+++ b/test/helpers/mock_function.cc
@@ -0,0 +1,170 @@
+#include "config.h"
+
+#include "mock_function.h"
+
+#include <fcntl.h>
+#include <iostream>
+#include <torrent/event.h>
+#include <torrent/net/socket_address.h>
+#include <torrent/net/fd.h>
+#include <torrent/utils/log.h>
+#include <torrent/utils/random.h>
+
+#define MOCK_CLEANUP_MAP(MOCK_FUNC) \
+  CPPUNIT_ASSERT_MESSAGE("expected mock function calls not completed for '" #MOCK_FUNC "'", mock_cleanup_map(&MOCK_FUNC) || ignore_assert);
+#define MOCK_LOG(log_fmt, ...)                                          \
+  lt_log_print(torrent::LOG_MOCK_CALLS, "%s: " log_fmt, __func__, __VA_ARGS__);
+
+void
+mock_clear(bool ignore_assert) {
+  MOCK_CLEANUP_MAP(torrent::fd__accept);
+  MOCK_CLEANUP_MAP(torrent::fd__bind);
+  MOCK_CLEANUP_MAP(torrent::fd__close);
+  MOCK_CLEANUP_MAP(torrent::fd__connect);
+  MOCK_CLEANUP_MAP(torrent::fd__fcntl_int);
+  MOCK_CLEANUP_MAP(torrent::fd__listen);
+  MOCK_CLEANUP_MAP(torrent::fd__setsockopt_int);
+  MOCK_CLEANUP_MAP(torrent::fd__socket);
+
+  MOCK_CLEANUP_MAP(torrent::poll_event_open);
+  MOCK_CLEANUP_MAP(torrent::poll_event_close);
+  MOCK_CLEANUP_MAP(torrent::poll_event_closed);
+  MOCK_CLEANUP_MAP(torrent::poll_event_insert_read);
+  MOCK_CLEANUP_MAP(torrent::poll_event_insert_write);
+  MOCK_CLEANUP_MAP(torrent::poll_event_insert_error);
+  MOCK_CLEANUP_MAP(torrent::poll_event_remove_read);
+  MOCK_CLEANUP_MAP(torrent::poll_event_remove_write);
+  MOCK_CLEANUP_MAP(torrent::poll_event_remove_error);
+
+  MOCK_CLEANUP_MAP(torrent::random_uniform_uint16);
+  MOCK_CLEANUP_MAP(torrent::random_uniform_uint32);
+
+  mock_compare_map<torrent::Event>::values.clear();
+};
+
+void mock_init() {
+  log_add_group_output(torrent::LOG_MOCK_CALLS, "test_output");
+  mock_clear(true);
+}
+
+void mock_cleanup() {
+  mock_clear(false);
+}
+
+namespace torrent {
+
+//
+// Mock functions for 'torrent/net/fd.h':
+//
+
+int fd__accept(int socket, sockaddr *address, socklen_t *address_len) {
+  MOCK_LOG("entry socket:%i address:%s address_len:%u",
+           socket, torrent::sa_pretty_str(address).c_str(), (unsigned int)(*address_len));
+  auto ret = mock_call<int>(__func__, &torrent::fd__accept, socket, address, address_len);
+  MOCK_LOG("exit socket:%i address:%s address_len:%u",
+           socket, torrent::sa_pretty_str(address).c_str(), (unsigned int)(*address_len));
+  return ret;
+}
+
+int fd__bind(int socket, const sockaddr *address, socklen_t address_len) {
+  MOCK_LOG("socket:%i address:%s address_len:%u",
+           socket, torrent::sa_pretty_str(address).c_str(), (unsigned int)address_len);
+  return mock_call<int>(__func__, &torrent::fd__bind, socket, address, address_len);
+}
+
+int fd__close(int fildes) {
+  MOCK_LOG("filedes:%i", fildes);
+  return mock_call<int>(__func__, &torrent::fd__close, fildes);
+}
+
+int fd__connect(int socket, const sockaddr *address, socklen_t address_len) {
+  MOCK_LOG("socket:%i address:%s address_len:%u",
+           socket, torrent::sa_pretty_str(address).c_str(), (unsigned int)address_len);
+  return mock_call<int>(__func__, &torrent::fd__connect, socket, address, address_len);
+}
+
+int fd__fcntl_int(int fildes, int cmd, int arg) {
+  MOCK_LOG("filedes:%i cmd:%i arg:%i", fildes, cmd, arg);
+  return mock_call<int>(__func__, &torrent::fd__fcntl_int, fildes, cmd, arg);
+}
+
+int fd__listen(int socket, int backlog) {
+  MOCK_LOG("socket:%i backlog:%i", socket, backlog);
+  return mock_call<int>(__func__, &torrent::fd__listen, socket, backlog);
+}
+
+int fd__setsockopt_int(int socket, int level, int option_name, int option_value) {
+  MOCK_LOG("socket:%i level:%i option_name:%i option_value:%i",
+           socket, level, option_name, option_value);
+  return mock_call<int>(__func__, &torrent::fd__setsockopt_int, socket, level, option_name, option_value);
+}
+
+int fd__socket(int domain, int type, int protocol) {
+  MOCK_LOG("domain:%i type:%i protocol:%i", domain, type, protocol);
+  return mock_call<int>(__func__, &torrent::fd__socket, domain, type, protocol);
+}
+
+//
+// Mock functions for 'torrent/event.h':
+//
+
+void poll_event_open(Event* event) {
+  MOCK_LOG("fd:%i type_name:%s", event->file_descriptor(), event->type_name());
+  return mock_call<void>(__func__, &torrent::poll_event_open, event);
+}
+
+void poll_event_close(Event* event) {
+  MOCK_LOG("fd:%i type_name:%s", event->file_descriptor(), event->type_name());
+  return mock_call<void>(__func__, &torrent::poll_event_close, event);
+}
+
+void poll_event_closed(Event* event) {
+  MOCK_LOG("fd:%i type_name:%s", event->file_descriptor(), event->type_name());
+  return mock_call<void>(__func__, &torrent::poll_event_closed, event);
+}
+
+void poll_event_insert_read(Event* event) {
+  MOCK_LOG("fd:%i type_name:%s", event->file_descriptor(), event->type_name());
+  return mock_call<void>(__func__, &torrent::poll_event_insert_read, event);
+}
+
+void poll_event_insert_write(Event* event) {
+  MOCK_LOG("fd:%i type_name:%s", event->file_descriptor(), event->type_name());
+  return mock_call<void>(__func__, &torrent::poll_event_insert_write, event);
+}
+
+void poll_event_insert_error(Event* event) {
+  MOCK_LOG("fd:%i type_name:%s", event->file_descriptor(), event->type_name());
+  return mock_call<void>(__func__, &torrent::poll_event_insert_error, event);
+}
+
+void poll_event_remove_read(Event* event) {
+  MOCK_LOG("fd:%i type_name:%s", event->file_descriptor(), event->type_name());
+  return mock_call<void>(__func__, &torrent::poll_event_remove_read, event);
+}
+
+void poll_event_remove_write(Event* event) {
+  MOCK_LOG("fd:%i type_name:%s", event->file_descriptor(), event->type_name());
+  return mock_call<void>(__func__, &torrent::poll_event_remove_write, event);
+}
+
+void poll_event_remove_error(Event* event) {
+  MOCK_LOG("fd:%i type_name:%s", event->file_descriptor(), event->type_name());
+  return mock_call<void>(__func__, &torrent::poll_event_remove_error, event);
+}
+
+//
+// Mock functions for 'torrent/utils/random.h':
+//
+
+uint16_t random_uniform_uint16(uint16_t min, uint16_t max) {
+  MOCK_LOG("min:%" PRIu16 " max:%" PRIu16, min, max);
+  return mock_call<uint16_t>(__func__, &torrent::random_uniform_uint16, min, max);
+}
+
+uint32_t random_uniform_uint32(uint32_t min, uint32_t max) {
+  MOCK_LOG("min:%" PRIu32 " max:%" PRIu32, min, max);
+  return mock_call<uint32_t>(__func__, &torrent::random_uniform_uint32, min, max);
+}
+
+}
diff --git a/test/helpers/mock_function.h b/test/helpers/mock_function.h
new file mode 100644
index 00000000..6c194137
--- /dev/null
+++ b/test/helpers/mock_function.h
@@ -0,0 +1,133 @@
+#ifndef LIBTORRENT_HELPERS_MOCK_FUNCTION_H
+#define LIBTORRENT_HELPERS_MOCK_FUNCTION_H
+
+#include <functional>
+#include <map>
+#include <string>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+#include <cppunit/extensions/HelperMacros.h>
+
+#include "helpers/mock_compare.h"
+
+template<typename R, typename... Args>
+struct mock_function_map {
+  typedef std::tuple<R, Args...> call_type;
+  typedef std::vector<call_type> call_list_type;
+  typedef std::map<void*, call_list_type> func_map_type;
+
+  typedef std::function<R (Args...)> function_type;
+  typedef std::map<void*, function_type> redirect_map_type;
+
+  static func_map_type functions;
+  static redirect_map_type redirects;
+
+  static bool cleanup(void* fn) {
+    redirects.erase(fn);
+    return functions.erase(fn) == 0;
+  }
+
+  static R ret_erase(void* fn) {
+    auto itr = functions.find(fn);
+    auto ret = std::get<0>(itr->second.front());
+    itr->second.erase(itr->second.begin());
+
+    if (itr->second.empty())
+      functions.erase(itr);
+
+    return ret;
+  }
+};
+
+template<typename R, typename... Args>
+typename mock_function_map<R, Args...>::func_map_type mock_function_map<R, Args...>::functions;
+template<typename R, typename... Args>
+typename mock_function_map<R, Args...>::redirect_map_type mock_function_map<R, Args...>::redirects;
+
+struct mock_void {};
+
+template<typename R, typename... Args>
+struct mock_function_type {
+  typedef mock_function_map<R, Args...> type;
+
+  static int compare_expected(typename type::call_type lhs, Args... rhs) {
+    return mock_compare_tuple<sizeof...(Args)>(lhs, std::make_tuple(rhs...));
+  }
+
+  static R    ret_erase(void* fn) { return type::ret_erase(fn); }
+  static bool has_redirect(void* fn) { return type::redirects.find(fn) != type::redirects.end(); }
+  static R    call_redirect(void* fn, Args... args) { return type::redirects.find(fn)->second(args...); }
+};
+
+template<typename... Args>
+struct mock_function_type<void, Args...> {
+  typedef mock_function_map<mock_void, Args...> type;
+
+  static int compare_expected(typename type::call_type lhs, Args... rhs) {
+    return mock_compare_tuple<sizeof...(Args)>(lhs, std::make_tuple(rhs...));
+  }
+
+  static void ret_erase(void* fn) { type::ret_erase(fn); }
+  static bool has_redirect(void* fn) { return type::redirects.find(fn) != type::redirects.end(); }
+  static void call_redirect(void* fn, Args... args) { type::redirects.find(fn)->second(args...); }
+};
+
+void mock_init();
+void mock_cleanup();
+
+template<typename R, typename... Args>
+bool
+mock_cleanup_map(R fn[[gnu::unused]](Args...)) {
+  return mock_function_type<R, Args...>::type::cleanup(reinterpret_cast<void*>(fn));
+}
+
+template<typename R, typename... Args>
+void
+mock_expect(R fn(Args...), R ret, Args... args) {
+  typedef mock_function_map<R, Args...> mock_map;
+  mock_map::functions[reinterpret_cast<void*>(fn)].push_back(std::tuple<R, Args...>(ret, args...));
+}
+
+template<typename... Args>
+void
+mock_expect(void fn(Args...), Args... args) {
+  typedef mock_function_map<mock_void, Args...> mock_map;
+  mock_map::functions[reinterpret_cast<void*>(fn)].push_back(std::tuple<mock_void, Args...>(mock_void(), args...));
+}
+
+template<typename R, typename... Args>
+void
+mock_redirect(R fn(Args...), std::function<R (Args...)> func) {
+  typedef mock_function_map<R, Args...> mock_map;
+  mock_map::redirects[reinterpret_cast<void*>(fn)] = func;
+}
+
+template<typename R, typename... Args>
+auto
+mock_call_direct(std::string name, R fn(Args...), Args... args) -> decltype(fn(args...)) {
+  typedef mock_function_type<R, Args...> mock_type;
+
+  auto itr = mock_type::type::functions.find(reinterpret_cast<void*>(fn));
+  CPPUNIT_ASSERT_MESSAGE(("mock_call expected function calls exhausted by '" + name + "'").c_str(),
+                         itr != mock_type::type::functions.end());
+
+  auto mismatch_arg = mock_type::compare_expected(itr->second.front(), args...);
+  CPPUNIT_ASSERT_MESSAGE(("mock_call expected function call argument " + std::to_string(mismatch_arg) + " mismatch for '" + name + "'").c_str(),
+                         mismatch_arg == 0);
+
+  return mock_type::ret_erase(reinterpret_cast<void*>(fn));
+}
+
+template<typename R, typename... Args>
+auto
+mock_call(std::string name, R fn(Args...), Args... args) -> decltype(fn(args...)) {
+  typedef mock_function_type<R, Args...> mock_type;
+
+  if (mock_type::has_redirect(reinterpret_cast<void*>(fn)))
+    return mock_type::call_redirect(reinterpret_cast<void*>(fn), args...);
+
+  return mock_call_direct(name, fn, args...);
+}
+
+#endif
diff --git a/test/helpers/network.h b/test/helpers/network.h
new file mode 100644
index 00000000..6cf2f870
--- /dev/null
+++ b/test/helpers/network.h
@@ -0,0 +1,182 @@
+#ifndef LIBTORRENT_HELPER_NETWORK_H
+#define LIBTORRENT_HELPER_NETWORK_H
+
+#include <functional>
+#include <string>
+#include <cppunit/extensions/HelperMacros.h>
+
+#include "torrent/net/address_info.h"
+
+//
+// Socket addresses
+//
+
+#define TEST_DEFAULT_SA                                                 \
+  auto sin_any = wrap_ai_get_first_sa("0.0.0.0");                       \
+  auto sin_any_5000 = wrap_ai_get_first_sa("0.0.0.0", "5000");          \
+  auto sin_any_5005 = wrap_ai_get_first_sa("0.0.0.0", "5005");          \
+  auto sin_bc = wrap_ai_get_first_sa("255.255.255.255");                \
+  auto sin_bc_5000 = wrap_ai_get_first_sa("255.255.255.255", "5000");   \
+  auto sin_bnd = wrap_ai_get_first_sa("123.123.123.123");               \
+  auto sin_1 = wrap_ai_get_first_sa("1.2.3.4");                         \
+  auto sin_1_5000 = wrap_ai_get_first_sa("1.2.3.4", "5000");            \
+  auto sin_1_5005 = wrap_ai_get_first_sa("1.2.3.4", "5005");            \
+  auto sin_1_5100 = wrap_ai_get_first_sa("1.2.3.4", "5100");            \
+  auto sin_2      = wrap_ai_get_first_sa("4.3.2.1");                    \
+  auto sin_2_5000 = wrap_ai_get_first_sa("4.3.2.1", "5000");            \
+  auto sin_2_5100 = wrap_ai_get_first_sa("4.3.2.1", "5100");            \
+                                                                        \
+  auto sin6_any = wrap_ai_get_first_sa("::");                           \
+  auto sin6_any_5000 = wrap_ai_get_first_sa("::", "5000");              \
+  auto sin6_any_5005 = wrap_ai_get_first_sa("::", "5005");              \
+  auto sin6_bnd = wrap_ai_get_first_sa("ff01::123");                    \
+  auto sin6_1 = wrap_ai_get_first_sa("ff01::1");                        \
+  auto sin6_1_5000 = wrap_ai_get_first_sa("ff01::1", "5000");           \
+  auto sin6_1_5005 = wrap_ai_get_first_sa("ff01::1", "5005");           \
+  auto sin6_1_5100 = wrap_ai_get_first_sa("ff01::1", "5100");           \
+  auto sin6_2      = wrap_ai_get_first_sa("ff02::2");                   \
+  auto sin6_2_5000 = wrap_ai_get_first_sa("ff02::2", "5000");           \
+  auto sin6_2_5100 = wrap_ai_get_first_sa("ff02::2", "5100");           \
+  auto sin6_v4_1 = wrap_ai_get_first_sa("::ffff:1.2.3.4");              \
+  auto sin6_v4_1_5000 = wrap_ai_get_first_sa("::ffff:1.2.3.4", "5000"); \
+  auto sin6_v4_any = wrap_ai_get_first_sa("::ffff:0.0.0.0");            \
+  auto sin6_v4_any_5000 = wrap_ai_get_first_sa("::ffff:0.0.0.0", "5000"); \
+  auto sin6_v4_bc = wrap_ai_get_first_sa("::ffff:255.255.255.255");     \
+  auto sin6_v4_bc_5000 = wrap_ai_get_first_sa("::ffff:255.255.255.255", "5000"); \
+  auto sin6_v4_bnd = wrap_ai_get_first_sa("::ffff:123.123.123.123");    \
+                                                                        \
+  auto c_sin_any = wrap_ai_get_first_c_sa("0.0.0.0");                   \
+  auto c_sin_any_5000 = wrap_ai_get_first_c_sa("0.0.0.0", "5000");      \
+  auto c_sin_any_5005 = wrap_ai_get_first_c_sa("0.0.0.0", "5005");      \
+  auto c_sin_any_5010 = wrap_ai_get_first_c_sa("0.0.0.0", "5010");      \
+  auto c_sin_any_6881 = wrap_ai_get_first_c_sa("0.0.0.0", "6881");      \
+  auto c_sin_any_6900 = wrap_ai_get_first_c_sa("0.0.0.0", "6900");      \
+  auto c_sin_any_6999 = wrap_ai_get_first_c_sa("0.0.0.0", "6999");      \
+  auto c_sin_bc = wrap_ai_get_first_c_sa("255.255.255.255");            \
+  auto c_sin_bc_5000 = wrap_ai_get_first_c_sa("255.255.255.255", "5000"); \
+  auto c_sin_bnd = wrap_ai_get_first_c_sa("123.123.123.123");           \
+  auto c_sin_bnd_5000 = wrap_ai_get_first_c_sa("123.123.123.123", "5000"); \
+  auto c_sin_bnd_6881 = wrap_ai_get_first_c_sa("123.123.123.123", "6881"); \
+  auto c_sin_bnd_6900 = wrap_ai_get_first_c_sa("123.123.123.123", "6900"); \
+  auto c_sin_bnd_6999 = wrap_ai_get_first_c_sa("123.123.123.123", "6999"); \
+  auto c_sin_1 = wrap_ai_get_first_c_sa("1.2.3.4");                     \
+  auto c_sin_1_5000 = wrap_ai_get_first_c_sa("1.2.3.4", "5000");        \
+  auto c_sin_1_5005 = wrap_ai_get_first_c_sa("1.2.3.4", "5005");        \
+  auto c_sin_1_5010 = wrap_ai_get_first_c_sa("1.2.3.4", "5010");        \
+  auto c_sin_1_6881 = wrap_ai_get_first_c_sa("1.2.3.4", "6881");        \
+  auto c_sin_1_6900 = wrap_ai_get_first_c_sa("1.2.3.4", "6900");        \
+  auto c_sin_1_6999 = wrap_ai_get_first_c_sa("1.2.3.4", "6999");        \
+  auto c_sin_2      = wrap_ai_get_first_c_sa("4.3.2.1");                \
+  auto c_sin_2_5000 = wrap_ai_get_first_c_sa("4.3.2.1", "5000");        \
+  auto c_sin_2_5100 = wrap_ai_get_first_c_sa("4.3.2.1", "5100");        \
+                                                                        \
+  auto c_sin6_any = wrap_ai_get_first_c_sa("::");                       \
+  auto c_sin6_any_5000 = wrap_ai_get_first_c_sa("::", "5000");          \
+  auto c_sin6_any_5005 = wrap_ai_get_first_c_sa("::", "5005");          \
+  auto c_sin6_any_5010 = wrap_ai_get_first_c_sa("::", "5010");          \
+  auto c_sin6_any_6881 = wrap_ai_get_first_c_sa("::", "6881");          \
+  auto c_sin6_any_6900 = wrap_ai_get_first_c_sa("::", "6900");          \
+  auto c_sin6_any_6999 = wrap_ai_get_first_c_sa("::", "6999");          \
+  auto c_sin6_bnd = wrap_ai_get_first_c_sa("ff01::123");                \
+  auto c_sin6_bnd_5000 = wrap_ai_get_first_c_sa("ff01::123", "5000");   \
+  auto c_sin6_bnd_6881 = wrap_ai_get_first_c_sa("ff01::123", "6881");   \
+  auto c_sin6_bnd_6900 = wrap_ai_get_first_c_sa("ff01::123", "6900");   \
+  auto c_sin6_bnd_6999 = wrap_ai_get_first_c_sa("ff01::123", "6999");   \
+  auto c_sin6_v4_1_5000 = wrap_ai_get_first_c_sa("::ffff:1.2.3.4", "5000"); \
+  auto c_sin6_1 = wrap_ai_get_first_c_sa("ff01::1");                    \
+  auto c_sin6_1_5000 = wrap_ai_get_first_c_sa("ff01::1", "5000");       \
+  auto c_sin6_1_5005 = wrap_ai_get_first_c_sa("ff01::1", "5005");       \
+  auto c_sin6_1_5010 = wrap_ai_get_first_c_sa("ff01::1", "5010");       \
+  auto c_sin6_1_5100 = wrap_ai_get_first_c_sa("ff01::1", "5100");       \
+  auto c_sin6_1_6881 = wrap_ai_get_first_c_sa("ff01::1", "6881");       \
+  auto c_sin6_1_6900 = wrap_ai_get_first_c_sa("ff01::1", "6900");       \
+  auto c_sin6_1_6999 = wrap_ai_get_first_c_sa("ff01::1", "6999");       \
+  auto c_sin6_2      = wrap_ai_get_first_c_sa("ff02::2");               \
+  auto c_sin6_2_5000 = wrap_ai_get_first_c_sa("ff02::2", "5000");       \
+  auto c_sin6_2_5100 = wrap_ai_get_first_c_sa("ff02::2", "5100");
+
+inline bool
+compare_sin6_addr(in6_addr lhs, in6_addr rhs) {
+  return std::equal(lhs.s6_addr, lhs.s6_addr + 16, rhs.s6_addr);
+}
+
+inline bool
+compare_listen_result(const torrent::listen_result_type& lhs, int rhs_fd, const torrent::c_sa_unique_ptr& rhs_sap) {
+  return lhs.fd == rhs_fd &&
+    ((lhs.address && rhs_sap) || ((lhs.address && rhs_sap) && torrent::sap_equal(lhs.address, rhs_sap)));
+}
+
+inline torrent::sa_unique_ptr
+wrap_ai_get_first_sa(const char* nodename, const char* servname = nullptr, const addrinfo* hints = nullptr) {
+  auto sa = torrent::ai_get_first_sa(nodename, servname, hints);
+
+  CPPUNIT_ASSERT_MESSAGE(("wrap_ai_get_first_sa: nodename:'" + std::string(nodename) + "'").c_str(),
+                        sa != nullptr);
+  return sa;
+}
+
+inline torrent::c_sa_unique_ptr
+wrap_ai_get_first_c_sa(const char* nodename, const char* servname = nullptr, const addrinfo* hints = nullptr) {
+  auto sa = torrent::ai_get_first_sa(nodename, servname, hints);
+
+  CPPUNIT_ASSERT_MESSAGE(("wrap_ai_get_first_sa: nodename:'" + std::string(nodename) + "'").c_str(),
+                        sa != nullptr);
+  return torrent::c_sa_unique_ptr(sa.release());
+}
+
+//
+// Address info tests:
+//
+
+typedef std::function<int (torrent::ai_unique_ptr&)> test_ai_ref;
+
+enum ai_flags_enum : int {
+      aif_none = 0x0,
+      aif_inet = 0x1,
+      aif_inet6 = 0x2,
+      aif_any = 0x4,
+};
+
+constexpr ai_flags_enum operator | (ai_flags_enum a, ai_flags_enum b) {
+  return static_cast<ai_flags_enum>(static_cast<int>(a) | static_cast<int>(b));
+}
+
+template <ai_flags_enum ai_flags>
+inline bool
+test_valid_ai_ref(test_ai_ref ftor, uint16_t port = 0) {
+  torrent::ai_unique_ptr ai;
+
+  if (int err = ftor(ai)) {
+    std::cout << std::endl << "valid_ai_ref got error '" << gai_strerror(err) << "'" << std::endl;
+    return false;
+  }
+
+  if ((ai_flags & aif_inet) && !torrent::sa_is_inet(ai->ai_addr))
+    return false;
+
+  if ((ai_flags & aif_inet6) && !torrent::sa_is_inet6(ai->ai_addr))
+    return false;
+
+  if (!!(ai_flags & aif_any) == !torrent::sa_is_any(ai->ai_addr))
+    return false;
+
+  if (torrent::sa_port(ai->ai_addr) != port)
+    return false;
+
+  return true;
+}
+
+inline bool
+test_valid_ai_ref_err(test_ai_ref ftor, int expect_err) {
+  torrent::ai_unique_ptr ai;
+  int err = ftor(ai);
+
+  if (err != expect_err) {
+    std::cout << std::endl << "ai_ref_err got wrong error, expected '" << gai_strerror(expect_err) << "', got '" << gai_strerror(err) << "'" << std::endl;
+    return false;
+  }
+
+  return true;
+}
+
+#endif
diff --git a/test/helpers/progress_listener.cc b/test/helpers/progress_listener.cc
new file mode 100644
index 00000000..02803ffc
--- /dev/null
+++ b/test/helpers/progress_listener.cc
@@ -0,0 +1,63 @@
+#include "config.h"
+
+#include "progress_listener.h"
+
+#include <algorithm>
+#include <iostream>
+#include <iterator>
+#include <numeric>
+#include <stdexcept>
+#include "torrent/utils/log.h"
+#include "torrent/utils/log_buffer.h"
+
+static std::string
+get_test_path(const test_list_type& tl) {
+  if (tl.size() < 2)
+    return "";
+
+  return std::accumulate(std::next(tl.begin()), std::prev(tl.end()), std::string(), [](std::string result, CppUnit::Test* test) {
+      return std::move(result) + test->getName() + "::";
+    });
+}
+
+void
+progress_listener::startTest(CppUnit::Test *test) {
+  std::cout << get_test_path(m_test_path) << test->getName() << std::flush;
+
+  torrent::log_cleanup();
+
+  m_last_test_failed = false;
+  m_current_log_buffer = torrent::log_open_log_buffer("test_output");
+}
+
+void
+progress_listener::addFailure(const CppUnit::TestFailure &failure) {
+  // AddFailure is called for parent test suits, so only deal with leafs.
+  if (m_current_log_buffer == nullptr)
+    return;
+
+  std::cout << " : " << (failure.isError() ? "error" : "assertion");
+
+  m_last_test_failed = true;
+  m_failures.push_back(std::move(failure_type{failure.failedTestName(), std::move(m_current_log_buffer)}));
+}
+
+void
+progress_listener::endTest(CppUnit::Test *test) {
+  std::cout << (m_last_test_failed ? "" : " : OK") << std::endl;
+
+  m_current_log_buffer.reset();
+  torrent::log_cleanup();
+}
+
+void
+progress_listener::startSuite(CppUnit::Test *suite) {
+  m_test_path.push_back(suite);
+
+  std::cout << std::endl << get_test_path(m_test_path) << suite->getName() << ":" << std::endl;
+}
+
+void
+progress_listener::endSuite(CppUnit::Test *suite) {
+  m_test_path.pop_back();
+}
diff --git a/test/helpers/progress_listener.h b/test/helpers/progress_listener.h
new file mode 100644
index 00000000..18fb8faa
--- /dev/null
+++ b/test/helpers/progress_listener.h
@@ -0,0 +1,47 @@
+#include <memory>
+#include <vector>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TestListener.h>
+
+#include "torrent/utils/log_buffer.h"
+
+struct failure_type {
+  std::string name;
+  torrent::log_buffer_ptr log;
+};
+
+typedef std::unique_ptr<CppUnit::TestFailure> test_failure_ptr;
+typedef std::vector<CppUnit::Test*> test_list_type;
+typedef std::vector<failure_type> failure_list_type;
+
+class progress_listener : public CppUnit::TestListener {
+public:
+  progress_listener() : m_last_test_failed(false) {}
+
+  void startTest(CppUnit::Test *test) override;
+  void addFailure(const CppUnit::TestFailure &failure) override;
+  void endTest(CppUnit::Test *test) override;
+
+  void startSuite(CppUnit::Test *suite) override;
+  void endSuite(CppUnit::Test *suite) override;
+
+  //Called by a TestRunner before running the test.
+  // void startTestRun(CppUnit::Test *test, CppUnit::TestResult *event_manager) override;
+
+  // Called by a TestRunner after running the test.
+  // void endTestRun(CppUnit::Test *test, CppUnit::TestResult *event_manager) override;
+
+  const failure_list_type& failures() { return m_failures; }
+  failure_list_type&& move_failures() { return std::move(m_failures); }
+
+private:
+  progress_listener(const progress_listener& rhs) = delete;
+  void operator =(const progress_listener& rhs) = delete;
+
+  test_list_type    m_test_path;
+  failure_list_type m_failures;
+  bool              m_last_test_failed;
+
+  torrent::log_buffer_ptr m_current_log_buffer;
+};
diff --git a/test/helpers/test_fixture.cc b/test/helpers/test_fixture.cc
new file mode 100644
index 00000000..4d8d7214
--- /dev/null
+++ b/test/helpers/test_fixture.cc
@@ -0,0 +1,18 @@
+#include "config.h"
+
+#include "test_fixture.h"
+
+#include "torrent/utils/log.h"
+
+void
+test_fixture::setUp() {
+  mock_init();
+
+  log_add_group_output(torrent::LOG_CONNECTION_BIND, "test_output");
+  log_add_group_output(torrent::LOG_CONNECTION_FD, "test_output");
+}
+
+void
+test_fixture::tearDown() {
+  mock_cleanup();
+}
diff --git a/test/helpers/test_fixture.h b/test/helpers/test_fixture.h
new file mode 100644
index 00000000..312d5009
--- /dev/null
+++ b/test/helpers/test_fixture.h
@@ -0,0 +1,14 @@
+#ifndef LIBTORRENT_HELPER_TEST_FIXTURE_H
+#define LIBTORRENT_HELPER_TEST_FIXTURE_H
+
+#include <cppunit/extensions/HelperMacros.h>
+
+#include "helpers/mock_function.h"
+
+class test_fixture : public CppUnit::TestFixture {
+public:
+  void setUp();
+  void tearDown();
+};
+
+#endif
diff --git a/test/helpers/utils.h b/test/helpers/utils.h
new file mode 100644
index 00000000..d18450c1
--- /dev/null
+++ b/test/helpers/utils.h
@@ -0,0 +1,60 @@
+#ifndef LIBTORRENT_HELPER_UTILS_H
+#define LIBTORRENT_HELPER_UTILS_H
+
+#include <algorithm>
+#include <iostream>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <torrent/utils/log.h>
+
+static void
+dump_failure_log(const failure_type& failure) {
+  if (failure.log->empty())
+    return;
+
+  std::cout << std::endl << failure.name << std::endl;
+
+  // Doesn't print dump messages as log_buffer drops them.
+  std::for_each(failure.log->begin(), failure.log->end(), [](const torrent::log_entry& entry) {
+      std::cout << entry.timestamp << ' ' << entry.message << '\n';
+    });
+
+  std::cout << std::flush;
+}
+
+static void
+dump_failures(const failure_list_type& failures) {
+  if (failures.empty())
+    return;
+
+  std::cout << std::endl
+            << "=================" << std::endl
+            << "Failed Test Logs:" << std::endl
+            << "=================" << std::endl;
+
+  std::for_each(failures.begin(), failures.end(), [](const failure_type& failure) {
+      dump_failure_log(failure);
+    });
+  std::cout << std::endl;
+}
+
+static
+void add_tests(CppUnit::TextUi::TestRunner& runner, const char* c_test_names) {
+  if (c_test_names == NULL || std::string(c_test_names).empty()) {
+    runner.addTest(CppUnit::TestFactoryRegistry::getRegistry().makeTest());
+    return;
+  }
+
+  const std::string& test_names(c_test_names);
+
+  size_t pos = 0;
+  size_t next = 0;
+
+  while ((next = test_names.find(',', pos)) < test_names.size()) {
+    runner.addTest(CppUnit::TestFactoryRegistry::getRegistry(test_names.substr(pos, next - pos)).makeTest());
+    pos = next + 1;
+  }
+
+  runner.addTest(CppUnit::TestFactoryRegistry::getRegistry(test_names.substr(pos)).makeTest());
+}
+
+#endif
diff --git a/test/main.cc b/test/main.cc
index e69d3d70..da93fead 100644
--- a/test/main.cc
+++ b/test/main.cc
@@ -1,44 +1,92 @@
+#include "config.h"
+
+#include <cstdlib>
 #include <stdexcept>
+#include <signal.h>
+#include <string.h>
 #include <cppunit/BriefTestProgressListener.h>
 #include <cppunit/CompilerOutputter.h>
 #include <cppunit/TestResult.h>
 #include <cppunit/TestResultCollector.h>
+#include <cppunit/extensions/HelperMacros.h>
 #include <cppunit/extensions/TestFactoryRegistry.h>
 #include <cppunit/ui/text/TestRunner.h>
 
-int main(int argc, char* argv[])
-{
+#ifdef USE_EXECINFO
+#include <execinfo.h>
+#endif
+
+#include "helpers/progress_listener.h"
+#include "helpers/utils.h"
+
+CPPUNIT_REGISTRY_ADD_TO_DEFAULT("net");
+CPPUNIT_REGISTRY_ADD_TO_DEFAULT("torrent/net");
+CPPUNIT_REGISTRY_ADD_TO_DEFAULT("torrent/utils");
+
+void
+do_test_panic(int signum) {
+  signal(signum, SIG_DFL);
+
+  std::cout << std::endl << std::endl << "Caught " << strsignal(signum) << ", dumping stack:" << std::endl << std::endl;
+  
+#ifdef USE_EXECINFO
+  void* stackPtrs[20];
+
+  // Print the stack and exit.
+  int stackSize = backtrace(stackPtrs, 20);
+  char** stackStrings = backtrace_symbols(stackPtrs, stackSize);
+
+  for (int i = 0; i < stackSize; ++i)
+    std::cout << stackStrings[i] << std::endl;
+
+#else
+  std::cout << "Stack dump not enabled." << std::endl;
+#endif
+
+  std::cout << std::endl;
+  torrent::log_cleanup();
+  std::abort();
+}
+
+void
+register_signal_handlers() {
+  struct sigaction sa;
+  sigemptyset(&sa.sa_mask);
+  sa.sa_flags = SA_RESTART;
+  sa.sa_handler = &do_test_panic;
+
+  if (sigaction(SIGSEGV, &sa, NULL) == -1) {
+    std::cout << "Could not register signal handlers." << std::endl;
+    exit(-1);
+  }
+}
+
+int main(int argc, char* argv[]) {
+  register_signal_handlers();
+
   CppUnit::TestResult controller;
   CppUnit::TestResultCollector result;
-  CppUnit::BriefTestProgressListener progressListener;
+  progress_listener progress;
 
   controller.addListener( &result );        
-  controller.addListener( &progressListener );
-
-  // Get the top level suite from the registry
-  CppUnit::Test *suite = CppUnit::TestFactoryRegistry::getRegistry().makeTest();
+  controller.addListener( &progress );
 
-  // Adds the test to the list of test to run
   CppUnit::TextUi::TestRunner runner;
-  runner.addTest( suite );
+  add_tests(runner, std::getenv("TEST_NAME"));
 
-  // Change the default outputter to a compiler error format outputter
-  runner.setOutputter( new CppUnit::CompilerOutputter( &runner.result(),
-                                                       std::cerr ) );
   try {
     std::cout << "Running ";
     runner.run( controller );
  
-    std::cerr << std::endl;
- 
+    // TODO: Make outputter.
+    dump_failures(progress.failures());
+
     // Print test in a compiler compatible format.
     CppUnit::CompilerOutputter outputter( &result, std::cerr );
     outputter.write();                      
 
   } catch ( std::invalid_argument &e ) { // Test path not resolved
-    std::cerr  <<  std::endl  
-               <<  "ERROR: "  <<  e.what()
-               << std::endl;
+    std::cerr  <<  std::endl <<  "ERROR: "  <<  e.what() << std::endl;
     return 1;
   }
 
diff --git a/test/net/test_socket_listen.cc b/test/net/test_socket_listen.cc
new file mode 100644
index 00000000..e86a078b
--- /dev/null
+++ b/test/net/test_socket_listen.cc
@@ -0,0 +1,398 @@
+#include "config.h"
+
+#include "test_socket_listen.h"
+
+#include "helpers/expect_fd.h"
+#include "helpers/expect_utils.h"
+#include "helpers/mock_function.h"
+#include "helpers/network.h"
+
+#include <net/socket_listen.h>
+#include <torrent/exceptions.h>
+#include <torrent/utils/log.h>
+
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(test_socket_listen, "net");
+
+struct test_sl_deleter {
+  void operator()(torrent::socket_listen* sl) const { if (!sl->is_open()) delete sl; }
+};
+
+typedef std::unique_ptr<torrent::socket_listen, test_sl_deleter> test_sl_unique_ptr;
+
+#define TEST_SL_BEGIN(name)                                     \
+  test_sl_unique_ptr sl(new torrent::socket_listen);            \
+  std::vector<torrent::sa_unique_ptr> sap_cache;                \
+  lt_log_print(torrent::LOG_MOCK_CALLS, "sl_begin: %s", name);  \
+  TEST_DEFAULT_SA;
+
+#define TEST_SL_ASSERT_OPEN(_sap_bind, _sap_result, _flags)             \
+  TEST_SL_ASSERT_OPEN_PORT(_sap_bind, _sap_result, 5000, 5009, 5005, _flags); \
+  CPPUNIT_ASSERT(sl->socket_address_port() == 5005);
+
+#define TEST_SL_ASSERT_OPEN_PORT(_sap_bind, _sap_result, _first_port, _last_port, _itr_port, _flags) \
+  expect_event_open_re(0);                                              \
+  CPPUNIT_ASSERT(sl->open(_sap_bind, _first_port, _last_port, _itr_port, _flags)); \
+  CPPUNIT_ASSERT(sl->is_open());                                        \
+  CPPUNIT_ASSERT(torrent::sa_equal(sl->socket_address(), _sap_result.get()));
+
+#define TEST_SL_ASSERT_OPEN_SEQUENTIAL(_sap_bind, _sap_result, _first_port, _last_port, _flags) \
+  expect_event_open_re(0);                                              \
+  CPPUNIT_ASSERT(sl->open_sequential(_sap_bind, _first_port, _last_port, _flags)); \
+  CPPUNIT_ASSERT(sl->is_open());                                        \
+  CPPUNIT_ASSERT(torrent::sa_equal(sl->socket_address(), _sap_result.get()));
+
+#define TEST_SL_ASSERT_OPEN_RANDOMIZE(_sap_bind, _sap_result, _first_port, _last_port, _flags) \
+  expect_event_open_re(0);                                              \
+  CPPUNIT_ASSERT(sl->open_randomize(_sap_bind, _first_port, _last_port, _flags)); \
+  CPPUNIT_ASSERT(sl->is_open());                                        \
+  CPPUNIT_ASSERT(torrent::sa_equal(sl->socket_address(), _sap_result.get()));
+
+#define TEST_SL_ASSERT_CLOSED()                           \
+  CPPUNIT_ASSERT(!sl->is_open());                         \
+  CPPUNIT_ASSERT(sl->file_descriptor() == -1);            \
+  CPPUNIT_ASSERT(sl->socket_address() == nullptr);        \
+  CPPUNIT_ASSERT(sl->socket_address_port() == 0);
+
+#define TEST_SL_CLOSE(_fd)                                              \
+  mock_expect(&torrent::fd__close, 0, _fd);                             \
+  mock_expect(&torrent::poll_event_closed, (torrent::Event*)sl.get());  \
+  CPPUNIT_ASSERT_NO_THROW(sl->close());                                 \
+  TEST_SL_ASSERT_CLOSED();
+
+#define TEST_SL_MOCK_CLOSED_PORT_RANGE(_src_sap, _first_port, _last_port) \
+  { uint16_t _port = _first_port; do {                                  \
+      sap_cache.push_back(torrent::sap_copy(_src_sap));                 \
+      torrent::sap_set_port(sap_cache.back(), _port);                   \
+      mock_expect(&torrent::fd__bind, -1, 1000,                         \
+                  (const sockaddr*)sap_cache.back().get(),              \
+                  (socklen_t)torrent::sap_length(sap_cache.back()));    \
+    } while (_port++ != _last_port);                                    \
+  }
+
+void
+test_socket_listen::test_basic() {
+  TEST_SL_BEGIN("basic");
+  TEST_SL_ASSERT_CLOSED();
+  CPPUNIT_ASSERT(sl->backlog() == SOMAXCONN);
+  CPPUNIT_ASSERT(sl->type_name() == std::string("socket_listen"));
+}
+
+void
+test_socket_listen::test_open_error() {
+  { TEST_SL_BEGIN("open twice");
+    expect_fd_inet6_tcp_nonblock(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy(sin6_any), c_sin6_any_5005, torrent::fd_flag_stream | torrent::fd_flag_nonblock);
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 5000, 5009, 5005, torrent::fd_flag_stream),
+                         torrent::internal_error);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin_any, stream, no v4only");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin_any), 5000, 5009, 5005, torrent::fd_flag_stream),
+                         torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+}
+
+void
+test_socket_listen::test_open_sap() {
+  { TEST_SL_BEGIN("sin6_any, stream");
+    expect_fd_inet6_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy(sin6_any), c_sin6_any_5005, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin_any, stream|v4only");
+    expect_fd_inet_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy(sin_any), c_sin_any_5005, torrent::fd_flag_stream | torrent::fd_flag_v4only);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin_1, stream|v4only");
+    expect_fd_inet_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin_1_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy(sin_1), c_sin_1_5005, torrent::fd_flag_stream | torrent::fd_flag_v4only);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream|v6only");
+    expect_fd_inet6_tcp(1000);
+    mock_expect(&torrent::fd__setsockopt_int, 0, 1000, (int)IPPROTO_IPV6, (int)IPV6_V6ONLY, (int)true);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy(sin6_any), c_sin6_any_5005, torrent::fd_flag_stream | torrent::fd_flag_v6only);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_1, stream|v6only");
+    expect_fd_inet6_tcp(1000);
+    mock_expect(&torrent::fd__setsockopt_int, 0, 1000, (int)IPPROTO_IPV6, (int)IPV6_V6ONLY, (int)true);
+    expect_fd_bind_listen(1000, c_sin6_1_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy(sin6_1), c_sin6_1_5005, torrent::fd_flag_stream | torrent::fd_flag_v6only);
+    TEST_SL_CLOSE(1000);
+  };
+}
+
+void
+test_socket_listen::test_open_sap_error() {
+  { TEST_SL_BEGIN("unspec");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sa_make_unspec(), 5000, 5009, 5005, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("unix");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sa_make_unix("test"), 5000, 5009, 5005, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin_any_5005");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin_any_5005), 5000, 5009, 5005, torrent::fd_flag_stream | torrent::fd_flag_v4only), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any_5005");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any_5005), 5000, 5009, 5005, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin_any");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_to_v4mapped(sin_any), 5000, 5009, 5005, torrent::fd_flag_stream | torrent::fd_flag_v4only), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin_1, v4mapped");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_to_v4mapped(sin_1), 5000, 5009, 5005, torrent::fd_flag_stream | torrent::fd_flag_v4only), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin_broadcast");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin_bc), 5000, 5009, 5005, torrent::fd_flag_stream | torrent::fd_flag_v4only), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+}
+
+void
+test_socket_listen::test_open_flags() {
+  { TEST_SL_BEGIN("sin_any, stream|v4only|nonblock");
+    expect_fd_inet_tcp_nonblock(1000);
+    expect_fd_bind_listen(1000, c_sin_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy_addr(sin_any), c_sin_any_5005, torrent::fd_flag_stream | torrent::fd_flag_v4only | torrent::fd_flag_nonblock);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream|nonblock");
+    expect_fd_inet6_tcp_nonblock(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy(sin6_any), c_sin6_any_5005, torrent::fd_flag_stream | torrent::fd_flag_nonblock);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin_any, stream|v4only|reuse_address");
+    expect_fd_inet_tcp(1000);
+    mock_expect(&torrent::fd__setsockopt_int, 0, 1000, (int)SOL_SOCKET, (int)SO_REUSEADDR, (int)true);
+    expect_fd_bind_listen(1000, c_sin_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy_addr(sin_any), c_sin_any_5005, torrent::fd_flag_stream | torrent::fd_flag_v4only | torrent::fd_flag_reuse_address);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream|reuse_address");
+    expect_fd_inet6_tcp(1000);
+    mock_expect(&torrent::fd__setsockopt_int, 0, 1000, (int)SOL_SOCKET, (int)SO_REUSEADDR, (int)true);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy(sin6_any), c_sin6_any_5005, torrent::fd_flag_stream | torrent::fd_flag_reuse_address);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin_any, stream|v4only|nonblock|reuse_address");
+    expect_fd_inet_tcp_nonblock(1000);
+    mock_expect(&torrent::fd__setsockopt_int, 0, 1000, (int)SOL_SOCKET, (int)SO_REUSEADDR, (int)true);
+    expect_fd_bind_listen(1000, c_sin_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy_addr(sin_any), c_sin_any_5005, torrent::fd_flag_stream | torrent::fd_flag_v4only | torrent::fd_flag_nonblock | torrent::fd_flag_reuse_address);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream|nonblock|reuse_address");
+    expect_fd_inet6_tcp_nonblock_reuseaddr(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN(torrent::sap_copy(sin6_any), c_sin6_any_5005, torrent::fd_flag_stream | torrent::fd_flag_nonblock | torrent::fd_flag_reuse_address);
+    TEST_SL_CLOSE(1000);
+  };
+}
+
+void
+test_socket_listen::test_open_flags_error() {
+  { TEST_SL_BEGIN("sin6_any, fd_flags(0)");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 5000, 5009, 5005, torrent::fd_flags(0)), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, fd_flags(0xffff)");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 5000, 5009, 5005, torrent::fd_flags(0xffff)), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+}
+
+void
+test_socket_listen::test_open_port_single() {
+  { TEST_SL_BEGIN("sin6_any, stream");
+    expect_fd_inet6_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5000);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin6_any), c_sin6_any_5000, 5000, 5000, 5000, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin_any, stream");
+    expect_fd_inet_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin_any_5000);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin_any), c_sin_any_5000, 5000, 5000, 5000, torrent::fd_flag_stream | torrent::fd_flag_v4only);
+    TEST_SL_CLOSE(1000);
+  };
+}
+
+void
+test_socket_listen::test_open_port_single_error() {
+  { TEST_SL_BEGIN("sin6_any, 0, 0, 0");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 0, 0, 0, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, 1000, 0, 0");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 1000, 0, 0, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, 0, 1000, 0");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 0, 1000, 0, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, 0, 0, 500");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 0, 0, 500, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, 0, 1000, 500");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 0, 1000, 500, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+}
+
+void
+test_socket_listen::test_open_port_range() {
+  { TEST_SL_BEGIN("sin6_any, stream, first");
+    expect_fd_inet6_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5000);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin6_any), c_sin6_any_5000, 5000, 5010, 5000, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream, from first to middle port");
+    expect_fd_inet6_tcp(1000);
+    TEST_SL_MOCK_CLOSED_PORT_RANGE(sin6_any, 5000, 5004);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin6_any), c_sin6_any_5005, 5000, 5010, 5000, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream, from first to last port");
+    expect_fd_inet6_tcp(1000);
+    TEST_SL_MOCK_CLOSED_PORT_RANGE(sin6_any, 5000, 5009);
+    expect_fd_bind_listen(1000, c_sin6_any_5010);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin6_any), c_sin6_any_5010, 5000, 5010, 5000, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream, middle");
+    expect_fd_inet6_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin6_any), c_sin6_any_5005, 5000, 5010, 5005, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream, from middle to last port");
+    expect_fd_inet6_tcp(1000);
+    TEST_SL_MOCK_CLOSED_PORT_RANGE(sin6_any, 5005, 5009);
+    expect_fd_bind_listen(1000, c_sin6_any_5010);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin6_any), c_sin6_any_5010, 5000, 5010, 5005, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream, last");
+    expect_fd_inet6_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5010);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin6_any), c_sin6_any_5010, 5000, 5010, 5010, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream, from last to first port");
+    expect_fd_inet6_tcp(1000);
+    TEST_SL_MOCK_CLOSED_PORT_RANGE(sin6_any, 5010, 5010);
+    expect_fd_bind_listen(1000, c_sin6_any_5000);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin6_any), c_sin6_any_5000, 5000, 5010, 5010, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+  { TEST_SL_BEGIN("sin6_any, stream, from last to middle port");
+    expect_fd_inet6_tcp(1000);
+    TEST_SL_MOCK_CLOSED_PORT_RANGE(sin6_any, 5010, 5010);
+    TEST_SL_MOCK_CLOSED_PORT_RANGE(sin6_any, 5000, 5004);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN_PORT(torrent::sap_copy(sin6_any), c_sin6_any_5005, 5000, 5010, 5010, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+}
+
+void
+test_socket_listen::test_open_port_range_error() {
+  { TEST_SL_BEGIN("sin6_any, first > last");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 5000, 4999, 5000, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, first > itr");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 5001, 5009, 5000, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, itr > last");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 5000, 5009, 5010, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, min first > last");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 2, 1, 2, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, min first > itr");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 2, 1000, 1, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, min itr > last");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 1, 2, 3, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, max first > last");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 0xffff, 0xfffe, 0xffff, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, max first > itr");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 0xffff, 0xffff, 0xfffe, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+  { TEST_SL_BEGIN("sin6_any, max itr > last");
+    CPPUNIT_ASSERT_THROW(sl->open(torrent::sap_copy(sin6_any), 0xfffe, 0xfffe, 0xffff, torrent::fd_flag_stream), torrent::internal_error);
+    TEST_SL_ASSERT_CLOSED();
+  };
+}
+
+void
+test_socket_listen::test_open_sequential() {
+  { TEST_SL_BEGIN("sin6_any, stream");
+    expect_fd_inet6_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5000);
+    TEST_SL_ASSERT_OPEN_SEQUENTIAL(torrent::sap_copy(sin6_any), c_sin6_any_5000, 5000, 5010, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+}
+
+void
+test_socket_listen::test_open_randomize() {
+  { TEST_SL_BEGIN("sin6_any, stream");
+    expect_random_uniform_uint16(5005, 5000, 5010);
+    expect_fd_inet6_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5005);
+    TEST_SL_ASSERT_OPEN_RANDOMIZE(torrent::sap_copy(sin6_any), c_sin6_any_5005, 5000, 5010, torrent::fd_flag_stream);
+    TEST_SL_CLOSE(1000);
+  };
+}
+
+// deal with reuse error
+
+void
+test_socket_listen::test_accept() {
+  { TEST_SL_BEGIN("sin6_any, stream");
+    expect_fd_inet6_tcp(1000);
+    expect_fd_bind_listen(1000, c_sin6_any_5000);
+    TEST_SL_ASSERT_OPEN_SEQUENTIAL(torrent::sap_copy(sin6_any), c_sin6_any_5000, 5000, 5010, torrent::fd_flag_stream);
+
+    std::vector<torrent::fd_sap_tuple> accepted_connections;
+
+    sl->set_slot_accepted([&accepted_connections](int accept_fd, torrent::sa_unique_ptr sap) {
+        accepted_connections.push_back(torrent::fd_sap_tuple{accept_fd, std::move(sap)});
+      });
+
+    // CPPUNIT_ASSERT(accepted_connections.size() > 0 && torrent::fd_sap_equal(accepted_connections[0], torrent::fd_sap_tuple{2000, torrent::sap_copy(sin6_1_5100)}));
+
+    TEST_SL_CLOSE(1000);
+  };
+}
diff --git a/test/net/test_socket_listen.h b/test/net/test_socket_listen.h
new file mode 100644
index 00000000..5d06f7f3
--- /dev/null
+++ b/test/net/test_socket_listen.h
@@ -0,0 +1,44 @@
+#include "helpers/test_fixture.h"
+
+class test_socket_listen : public test_fixture {
+  CPPUNIT_TEST_SUITE(test_socket_listen);
+
+  CPPUNIT_TEST(test_basic);
+
+  CPPUNIT_TEST(test_open_error);
+  CPPUNIT_TEST(test_open_sap);
+  CPPUNIT_TEST(test_open_sap_error);
+  CPPUNIT_TEST(test_open_flags);
+  CPPUNIT_TEST(test_open_flags_error);
+
+  CPPUNIT_TEST(test_open_port_single);
+  CPPUNIT_TEST(test_open_port_single_error);
+  CPPUNIT_TEST(test_open_port_range);
+  CPPUNIT_TEST(test_open_port_range_error);
+
+  CPPUNIT_TEST(test_open_sequential);
+  CPPUNIT_TEST(test_open_randomize);
+
+  CPPUNIT_TEST(test_accept);
+
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+  void test_basic();
+
+  void test_open_error();
+  void test_open_sap();
+  void test_open_sap_error();
+  void test_open_flags();
+  void test_open_flags_error();
+
+  void test_open_port_single();
+  void test_open_port_single_error();
+  void test_open_port_range();
+  void test_open_port_range_error();
+
+  void test_open_sequential();
+  void test_open_randomize();
+
+  void test_accept();
+};
diff --git a/test/torrent/net/test_address_info.cc b/test/torrent/net/test_address_info.cc
new file mode 100644
index 00000000..e3ee24d1
--- /dev/null
+++ b/test/torrent/net/test_address_info.cc
@@ -0,0 +1,62 @@
+#include "config.h"
+
+#include "test_address_info.h"
+
+#include "helpers/network.h"
+#include "torrent/net/address_info.h"
+#include "torrent/net/socket_address.h"
+
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(test_address_info, "torrent/net");
+
+void
+test_address_info::test_basic() {
+  CPPUNIT_ASSERT(test_valid_ai_ref<aif_inet|aif_any> (std::bind(torrent::ai_get_addrinfo, "0.0.0.0", nullptr, nullptr, std::placeholders::_1)));
+  CPPUNIT_ASSERT(test_valid_ai_ref<aif_inet6|aif_any>(std::bind(torrent::ai_get_addrinfo, "::", nullptr, nullptr, std::placeholders::_1)));
+
+  CPPUNIT_ASSERT(test_valid_ai_ref<aif_inet> (std::bind(torrent::ai_get_addrinfo, "1.1.1.1", nullptr, nullptr, std::placeholders::_1)));
+  CPPUNIT_ASSERT(test_valid_ai_ref<aif_inet6>(std::bind(torrent::ai_get_addrinfo, "ff01::1", nullptr, nullptr, std::placeholders::_1)));
+  CPPUNIT_ASSERT(test_valid_ai_ref<aif_inet6>(std::bind(torrent::ai_get_addrinfo, "2001:0db8:85a3:0000:0000:8a2e:0370:7334", nullptr, nullptr, std::placeholders::_1)));
+
+  CPPUNIT_ASSERT(test_valid_ai_ref<aif_inet> (std::bind(torrent::ai_get_addrinfo, "1.1.1.1", "22123", nullptr, std::placeholders::_1), 22123));
+  CPPUNIT_ASSERT(test_valid_ai_ref<aif_inet6>(std::bind(torrent::ai_get_addrinfo, "2001:db8:a::", "22123", nullptr, std::placeholders::_1), 22123));
+
+  CPPUNIT_ASSERT(test_valid_ai_ref<aif_none> (std::bind(torrent::ai_get_addrinfo, "localhost", nullptr, nullptr, std::placeholders::_1)));
+
+  CPPUNIT_ASSERT(test_valid_ai_ref_err(std::bind(torrent::ai_get_addrinfo, "1.1.1.300", nullptr, nullptr, std::placeholders::_1), EAI_NONAME));
+  CPPUNIT_ASSERT(test_valid_ai_ref_err(std::bind(torrent::ai_get_addrinfo, "2001:db8:a::22123", nullptr, nullptr, std::placeholders::_1), EAI_NONAME));
+}
+
+void
+test_address_info::test_numericserv() {
+  CPPUNIT_ASSERT(test_valid_ai_ref<aif_inet> (std::bind(torrent::ai_get_addrinfo, "1.1.1.1", nullptr, torrent::ai_make_hint(AI_NUMERICHOST, 0, 0).get(), std::placeholders::_1)));
+
+  CPPUNIT_ASSERT(test_valid_ai_ref_err(std::bind(torrent::ai_get_addrinfo, "localhost", nullptr, torrent::ai_make_hint(AI_NUMERICHOST, 0, 0).get(), std::placeholders::_1), EAI_NONAME));
+}
+
+void
+test_address_info::test_helpers() {
+  torrent::sin_unique_ptr sin_zero = torrent::sin_from_sa(wrap_ai_get_first_sa("0.0.0.0"));
+  CPPUNIT_ASSERT(sin_zero != nullptr);
+  CPPUNIT_ASSERT(sin_zero->sin_family == AF_INET);
+  CPPUNIT_ASSERT(sin_zero->sin_port == 0);
+  CPPUNIT_ASSERT(sin_zero->sin_addr.s_addr == in_addr().s_addr);
+
+  torrent::sin_unique_ptr sin_1 = torrent::sin_from_sa(wrap_ai_get_first_sa("1.2.3.4"));
+  CPPUNIT_ASSERT(sin_1 != nullptr);
+  CPPUNIT_ASSERT(sin_1->sin_family == AF_INET);
+  CPPUNIT_ASSERT(sin_1->sin_port == 0);
+  CPPUNIT_ASSERT(sin_1->sin_addr.s_addr == htonl(0x01020304));
+
+  torrent::sin6_unique_ptr sin6_zero = torrent::sin6_from_sa(wrap_ai_get_first_sa("::"));
+  CPPUNIT_ASSERT(sin6_zero != nullptr);
+  CPPUNIT_ASSERT(sin6_zero->sin6_family == AF_INET6);
+  CPPUNIT_ASSERT(sin6_zero->sin6_port == 0);
+  CPPUNIT_ASSERT(compare_sin6_addr(sin6_zero->sin6_addr, in6_addr{0}));
+
+  torrent::sin6_unique_ptr sin6_1 = torrent::sin6_from_sa(wrap_ai_get_first_sa("ff01::1"));
+  CPPUNIT_ASSERT(sin6_1 != nullptr);
+  CPPUNIT_ASSERT(sin6_1->sin6_family == AF_INET6);
+  CPPUNIT_ASSERT(sin6_1->sin6_port == 0);
+  CPPUNIT_ASSERT(compare_sin6_addr(sin6_1->sin6_addr, in6_addr{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}));
+  CPPUNIT_ASSERT(!compare_sin6_addr(sin6_1->sin6_addr, in6_addr{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2}));
+}
diff --git a/test/torrent/net/test_address_info.h b/test/torrent/net/test_address_info.h
new file mode 100644
index 00000000..c2ce9188
--- /dev/null
+++ b/test/torrent/net/test_address_info.h
@@ -0,0 +1,19 @@
+#include <cppunit/extensions/HelperMacros.h>
+
+class test_address_info : public CppUnit::TestFixture {
+  CPPUNIT_TEST_SUITE(test_address_info);
+
+  CPPUNIT_TEST(test_basic);
+  CPPUNIT_TEST(test_numericserv);
+  CPPUNIT_TEST(test_helpers);
+
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+  void setUp() {}
+  void tearDown() {}
+
+  void test_basic();
+  void test_numericserv();
+  void test_helpers();
+};
diff --git a/test/torrent/net/test_fd.cc b/test/torrent/net/test_fd.cc
new file mode 100644
index 00000000..3cab0c5e
--- /dev/null
+++ b/test/torrent/net/test_fd.cc
@@ -0,0 +1,24 @@
+#include "config.h"
+
+#include "test_fd.h"
+
+#include <torrent/net/fd.h>
+
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(test_fd, "torrent/net");
+
+void
+test_fd::test_valid_flags() {
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream));
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_nonblock));
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_reuse_address));
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_v4only));
+  CPPUNIT_ASSERT(torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_v6only));
+
+  CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flag_v4only | torrent::fd_flag_v6only));
+  CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flag_stream | torrent::fd_flag_v4only | torrent::fd_flag_v6only));
+
+  CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flags()));
+  CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flags(~torrent::fd_flag_all)));
+  CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flags(torrent::fd_flag_stream | ~torrent::fd_flag_all)));
+  CPPUNIT_ASSERT(!torrent::fd_valid_flags(torrent::fd_flags(0x3245132)));
+}
diff --git a/test/torrent/net/test_fd.h b/test/torrent/net/test_fd.h
new file mode 100644
index 00000000..6ba718fc
--- /dev/null
+++ b/test/torrent/net/test_fd.h
@@ -0,0 +1,12 @@
+#include "helpers/test_fixture.h"
+
+class test_fd : public test_fixture {
+  CPPUNIT_TEST_SUITE(test_fd);
+
+  CPPUNIT_TEST(test_valid_flags);
+
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+  void test_valid_flags();
+};
diff --git a/test/torrent/net/test_socket_address.cc b/test/torrent/net/test_socket_address.cc
new file mode 100644
index 00000000..8a1b0c8a
--- /dev/null
+++ b/test/torrent/net/test_socket_address.cc
@@ -0,0 +1,383 @@
+#include "config.h"
+
+#include "test_socket_address.h"
+
+#include "helpers/network.h"
+#include "torrent/exceptions.h"
+#include "torrent/net/socket_address.h"
+
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(test_socket_address, "torrent/net");
+
+void
+test_socket_address::test_sa_is_any() {
+  TEST_DEFAULT_SA;
+
+  CPPUNIT_ASSERT(torrent::sap_is_any(sin_any));
+  CPPUNIT_ASSERT(torrent::sap_is_any(sin_any_5000));
+  CPPUNIT_ASSERT(torrent::sap_is_any(sin6_v4_any));
+  CPPUNIT_ASSERT(torrent::sap_is_any(sin6_v4_any_5000));
+
+  CPPUNIT_ASSERT(!torrent::sap_is_any(sin_bc));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(sin_1));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(sin6_1));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(sin_bc_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(sin_1_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(sin6_1_5000));
+
+  CPPUNIT_ASSERT(!torrent::sap_is_any(c_sin_bc));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(c_sin_1));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(c_sin6_1));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(c_sin_bc_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(c_sin_1_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_any(c_sin6_1_5000));
+}
+
+void
+test_socket_address::test_sa_is_broadcast() {
+  TEST_DEFAULT_SA;
+
+  CPPUNIT_ASSERT(torrent::sap_is_broadcast(sin_bc));
+  CPPUNIT_ASSERT(torrent::sap_is_broadcast(sin_bc_5000));
+  CPPUNIT_ASSERT(torrent::sap_is_broadcast(sin6_v4_bc));
+  CPPUNIT_ASSERT(torrent::sap_is_broadcast(sin6_v4_bc_5000));
+
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(sin_any));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(sin_1));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(sin6_any));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(sin6_1));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(sin_any_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(sin_1_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(sin6_any_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(sin6_1_5000));
+
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(c_sin_any));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(c_sin_1));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(c_sin6_any));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(c_sin6_1));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(c_sin_any_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(c_sin_1_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(c_sin6_any_5000));
+  CPPUNIT_ASSERT(!torrent::sap_is_broadcast(c_sin6_1_5000));
+}
+
+void
+test_socket_address::test_make() {
+  torrent::sa_unique_ptr sa_unspec = torrent::sa_make_unspec();
+  CPPUNIT_ASSERT(sa_unspec != nullptr);
+  CPPUNIT_ASSERT(sa_unspec->sa_family == AF_UNSPEC);
+
+  torrent::sa_unique_ptr sa_inet = torrent::sa_make_inet();
+  CPPUNIT_ASSERT(sa_inet != nullptr);
+  CPPUNIT_ASSERT(sa_inet->sa_family == AF_INET);
+
+  sockaddr_in* sin_inet = reinterpret_cast<sockaddr_in*>(sa_inet.get());
+  CPPUNIT_ASSERT(sin_inet->sin_family == AF_INET);
+  CPPUNIT_ASSERT(sin_inet->sin_port == 0);
+  CPPUNIT_ASSERT(sin_inet->sin_addr.s_addr == in_addr().s_addr);
+
+  torrent::sa_unique_ptr sa_inet6 = torrent::sa_make_inet6();
+  CPPUNIT_ASSERT(sa_inet6 != nullptr);
+  CPPUNIT_ASSERT(sa_inet6->sa_family == AF_INET6);
+
+  sockaddr_in6* sin6_inet6 = reinterpret_cast<sockaddr_in6*>(sa_inet6.get());
+  CPPUNIT_ASSERT(sin6_inet6->sin6_family == AF_INET6);
+  CPPUNIT_ASSERT(sin6_inet6->sin6_port == 0);
+  CPPUNIT_ASSERT(sin6_inet6->sin6_flowinfo == 0);
+  CPPUNIT_ASSERT(compare_sin6_addr(sin6_inet6->sin6_addr, in6_addr{0}));
+  CPPUNIT_ASSERT(sin6_inet6->sin6_scope_id == 0);
+
+  torrent::sa_unique_ptr sa_unix = torrent::sa_make_unix("");
+  CPPUNIT_ASSERT(sa_unix != nullptr);
+  CPPUNIT_ASSERT(sa_unix->sa_family == AF_UNIX);
+}
+
+void
+test_socket_address::test_sin_from_sa() {
+  torrent::sa_unique_ptr sa_zero = wrap_ai_get_first_sa("0.0.0.0");
+  torrent::sin_unique_ptr sin_zero;
+
+  CPPUNIT_ASSERT(sa_zero != nullptr);
+  CPPUNIT_ASSERT_NO_THROW({ sin_zero = torrent::sin_from_sa(std::move(sa_zero)); });
+  CPPUNIT_ASSERT(sa_zero == nullptr);
+  CPPUNIT_ASSERT(sin_zero != nullptr);
+
+  CPPUNIT_ASSERT(sin_zero->sin_addr.s_addr == htonl(0x0));
+
+  torrent::sa_unique_ptr sa_inet = wrap_ai_get_first_sa("1.2.3.4");
+  torrent::sin_unique_ptr sin_inet;
+
+  CPPUNIT_ASSERT(sa_inet != nullptr);
+  CPPUNIT_ASSERT_NO_THROW({ sin_inet = torrent::sin_from_sa(std::move(sa_inet)); });
+  CPPUNIT_ASSERT(sa_inet == nullptr);
+  CPPUNIT_ASSERT(sin_inet != nullptr);
+
+  CPPUNIT_ASSERT(sin_inet->sin_addr.s_addr == htonl(0x01020304));
+  
+  CPPUNIT_ASSERT_THROW(torrent::sin_from_sa(torrent::sa_unique_ptr()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sin_from_sa(torrent::sa_make_unspec()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sin_from_sa(torrent::sa_make_inet6()), torrent::internal_error);
+}
+
+void
+test_socket_address::test_sin6_from_sa() {
+  torrent::sa_unique_ptr sa_zero = wrap_ai_get_first_sa("::");
+  torrent::sin6_unique_ptr sin6_zero;
+
+  CPPUNIT_ASSERT(sa_zero != nullptr);
+  CPPUNIT_ASSERT_NO_THROW({ sin6_zero = torrent::sin6_from_sa(std::move(sa_zero)); });
+  CPPUNIT_ASSERT(sa_zero == nullptr);
+  CPPUNIT_ASSERT(sin6_zero != nullptr);
+
+  CPPUNIT_ASSERT(sin6_zero->sin6_addr.s6_addr[0] == 0x0);
+  CPPUNIT_ASSERT(sin6_zero->sin6_addr.s6_addr[1] == 0x0);
+  CPPUNIT_ASSERT(sin6_zero->sin6_addr.s6_addr[15] == 0x0);
+
+  torrent::sa_unique_ptr sa_inet6 = wrap_ai_get_first_sa("ff01::1");
+  torrent::sin6_unique_ptr sin6_inet6;
+
+  CPPUNIT_ASSERT(sa_inet6 != nullptr);
+  CPPUNIT_ASSERT_NO_THROW({ sin6_inet6 = torrent::sin6_from_sa(std::move(sa_inet6)); });
+  CPPUNIT_ASSERT(sa_inet6 == nullptr);
+  CPPUNIT_ASSERT(sin6_inet6 != nullptr);
+  
+  CPPUNIT_ASSERT(sin6_inet6->sin6_addr.s6_addr[0] == 0xff);
+  CPPUNIT_ASSERT(sin6_inet6->sin6_addr.s6_addr[1] == 0x01);
+  CPPUNIT_ASSERT(sin6_inet6->sin6_addr.s6_addr[15] == 0x01);
+
+  CPPUNIT_ASSERT_THROW(torrent::sin6_from_sa(torrent::sa_unique_ptr()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sin6_from_sa(torrent::sa_make_unspec()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sin6_from_sa(torrent::sa_make_inet()), torrent::internal_error);
+}
+
+void
+test_socket_address::test_sa_equal() {
+  TEST_DEFAULT_SA;
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sa_make_unspec(), torrent::sa_make_unspec()));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sa_make_inet(), torrent::sa_make_inet()));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sa_make_inet6(), torrent::sa_make_inet6()));
+
+  CPPUNIT_ASSERT(!torrent::sap_equal(torrent::sa_make_unspec(), torrent::sa_make_inet()));
+  CPPUNIT_ASSERT(!torrent::sap_equal(torrent::sa_make_unspec(), torrent::sa_make_inet6()));
+  CPPUNIT_ASSERT(!torrent::sap_equal(torrent::sa_make_inet(), torrent::sa_make_inet6()));
+  CPPUNIT_ASSERT(!torrent::sap_equal(torrent::sa_make_inet6(), torrent::sa_make_inet()));
+
+  CPPUNIT_ASSERT(torrent::sap_equal(sin_1, sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(sin_1, c_sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(c_sin_1, sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(c_sin_1, c_sin_1));
+
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin_1, sin_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin_1, c_sin_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal(c_sin_1, sin_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal(c_sin_1, c_sin_2));
+
+  CPPUNIT_ASSERT(torrent::sap_equal(sin6_1, sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(sin6_1, c_sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(c_sin6_1, sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(c_sin6_1, c_sin6_1));
+
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin6_1, sin6_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin6_1, c_sin6_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal(c_sin6_1, sin6_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal(c_sin6_1, c_sin6_2));
+
+  CPPUNIT_ASSERT(torrent::sap_equal(sin_1_5000, sin_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal(sin6_1_5000, sin6_1_5000));
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin_1_5000, sin_1_5100));
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin6_1_5000, sin6_1_5100));
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin_1_5000, sin_2_5000));
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin6_1_5000, sin6_2_5000));
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin_1_5000, sin_2_5100));
+  CPPUNIT_ASSERT(!torrent::sap_equal(sin6_1_5000, sin6_2_5100));
+
+  CPPUNIT_ASSERT_THROW(torrent::sap_equal(torrent::sa_make_unix(""), torrent::sa_make_unix("")), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_equal(torrent::sa_make_unix(""), sin6_1), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_equal(sin6_1, torrent::sa_make_unix("")), torrent::internal_error);
+}
+
+void
+test_socket_address::test_sa_equal_addr() {
+  TEST_DEFAULT_SA;
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(torrent::sa_make_unspec(), torrent::sa_make_unspec()));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(torrent::sa_make_inet(), torrent::sa_make_inet()));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(torrent::sa_make_inet6(), torrent::sa_make_inet6()));
+
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(torrent::sa_make_unspec(), torrent::sa_make_inet()));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(torrent::sa_make_unspec(), torrent::sa_make_inet6()));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(torrent::sa_make_inet(), torrent::sa_make_inet6()));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(torrent::sa_make_inet6(), torrent::sa_make_inet()));
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(sin_1, sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(sin_1, c_sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(c_sin_1, sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(c_sin_1, c_sin_1));
+
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(sin_1, sin_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(sin_1, c_sin_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(c_sin_1, sin_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(c_sin_1, c_sin_2));
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(sin6_1, sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(sin6_1, c_sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(c_sin6_1, sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(c_sin6_1, c_sin6_1));
+
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(sin6_1, sin6_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(sin6_1, c_sin6_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(c_sin6_1, sin6_2));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(c_sin6_1, c_sin6_2));
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(sin_1_5000, sin_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(sin6_1_5000, sin6_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(sin_1_5000, sin_1_5100));
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(sin6_1_5000, sin6_1_5100));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(sin_1_5000, sin_2_5000));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(sin6_1_5000, sin6_2_5000));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(sin_1_5000, sin_2_5100));
+  CPPUNIT_ASSERT(!torrent::sap_equal_addr(sin6_1_5000, sin6_2_5100));
+
+  CPPUNIT_ASSERT_THROW(torrent::sap_equal_addr(torrent::sa_make_unix(""), torrent::sa_make_unix("")), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_equal_addr(torrent::sa_make_unix(""), sin6_1), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_equal_addr(sin6_1, torrent::sa_make_unix("")), torrent::internal_error);
+}
+
+void
+test_socket_address::test_sa_copy() {
+  TEST_DEFAULT_SA;
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(torrent::sa_make_unspec()), torrent::sa_make_unspec()));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(torrent::sa_make_inet()), sin_any));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(torrent::sa_make_inet6()), sin6_any));
+
+  CPPUNIT_ASSERT(torrent::sap_copy(sin_1).get() != sin_1.get());
+  CPPUNIT_ASSERT(torrent::sap_copy(c_sin_1).get() != c_sin_1.get());
+  CPPUNIT_ASSERT(torrent::sap_copy(sin6_1).get() != sin6_1.get());
+  CPPUNIT_ASSERT(torrent::sap_copy(c_sin6_1).get() != c_sin6_1.get());
+  CPPUNIT_ASSERT(torrent::sap_copy(sin_1_5000).get() != sin_1_5000.get());
+  CPPUNIT_ASSERT(torrent::sap_copy(sin6_1_5000).get() != sin6_1_5000.get());
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(sin_1), sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(sin_1), c_sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(c_sin_1), sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(c_sin_1), c_sin_1));
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(sin6_1), sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(sin6_1), c_sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(c_sin6_1), sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(c_sin6_1), c_sin6_1));
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(sin_1_5000), sin_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(sin6_1_5000), sin6_1_5000));
+
+  auto sin6_flags = torrent::sap_copy(sin6_1_5000);
+  reinterpret_cast<sockaddr_in6*>(sin6_flags.get())->sin6_flowinfo = 0x12345678;
+  reinterpret_cast<sockaddr_in6*>(sin6_flags.get())->sin6_scope_id = 0x12345678;
+
+  // TODO: Need 'strict' equal test.
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy(sin6_flags), sin6_flags));
+
+  CPPUNIT_ASSERT_THROW(torrent::sap_copy(torrent::sa_unique_ptr()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_copy(torrent::c_sa_unique_ptr()), torrent::internal_error);
+}
+
+void
+test_socket_address::test_sa_copy_addr() {
+  TEST_DEFAULT_SA;
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(torrent::sa_make_unspec()), torrent::sa_make_unspec()));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(torrent::sa_make_inet()), sin_any));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(torrent::sa_make_inet6()), sin6_any));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(torrent::sa_make_unspec(), 5000), torrent::sa_make_unspec()));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(torrent::sa_make_inet(), 5000), sin_any_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(torrent::sa_make_inet6(), 5000), sin6_any_5000));
+
+  CPPUNIT_ASSERT(torrent::sap_copy_addr(sin_1).get() != sin_1.get());
+  CPPUNIT_ASSERT(torrent::sap_copy_addr(c_sin_1).get() != c_sin_1.get());
+  CPPUNIT_ASSERT(torrent::sap_copy_addr(sin6_1).get() != sin6_1.get());
+  CPPUNIT_ASSERT(torrent::sap_copy_addr(c_sin6_1).get() != c_sin6_1.get());
+  CPPUNIT_ASSERT(torrent::sap_copy_addr(sin_1_5000).get() != sin_1_5000.get());
+  CPPUNIT_ASSERT(torrent::sap_copy_addr(sin6_1_5000).get() != sin6_1_5000.get());
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin_1), sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin_1), c_sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(c_sin_1), sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(c_sin_1), c_sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin_1, 5000), sin_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin_1, 5000), c_sin_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(c_sin_1, 5000), sin_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(c_sin_1, 5000), c_sin_1_5000));
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin6_1), sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin6_1), c_sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(c_sin6_1), sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(c_sin6_1), c_sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin6_1, 5000), sin6_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin6_1, 5000), c_sin6_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(c_sin6_1, 5000), sin6_1_5000));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(c_sin6_1, 5000), c_sin6_1_5000));
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin_1_5000), sin_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin6_1_5000), sin6_1));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin_1_5000, 5100), sin_1_5100));
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin6_1_5000, 5100), sin6_1_5100));
+
+  auto sin6_flags = wrap_ai_get_first_sa("ff01::1", "5555");
+  reinterpret_cast<sockaddr_in6*>(sin6_flags.get())->sin6_flowinfo = 0x12345678;
+  reinterpret_cast<sockaddr_in6*>(sin6_flags.get())->sin6_scope_id = 0x12345678;
+
+  CPPUNIT_ASSERT(torrent::sap_equal(torrent::sap_copy_addr(sin6_flags), sin6_1));
+
+  CPPUNIT_ASSERT_THROW(torrent::sap_copy_addr(torrent::sa_unique_ptr()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_copy_addr(torrent::c_sa_unique_ptr()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_copy_addr(torrent::sa_unique_ptr(), 5000), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_copy_addr(torrent::c_sa_unique_ptr(), 5000), torrent::internal_error);
+}
+
+void
+test_socket_address::test_sa_from_v4mapped() {
+  TEST_DEFAULT_SA;
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(torrent::sap_from_v4mapped(sin6_v4_any), sin_any));
+  CPPUNIT_ASSERT(torrent::sap_is_port_any(torrent::sap_from_v4mapped(sin6_v4_any)));
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(torrent::sap_from_v4mapped(sin6_v4_1), sin_1));
+  CPPUNIT_ASSERT(torrent::sap_is_port_any(torrent::sap_from_v4mapped(sin6_v4_1)));
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(torrent::sap_from_v4mapped(sin6_v4_bc), sin_bc));
+  CPPUNIT_ASSERT(torrent::sap_is_port_any(torrent::sap_from_v4mapped(sin6_v4_bc)));
+
+  CPPUNIT_ASSERT_THROW(torrent::sap_from_v4mapped(torrent::sa_make_unspec()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_from_v4mapped(torrent::sa_make_inet()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_from_v4mapped(torrent::sa_make_unix("")), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_from_v4mapped(sin_any), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_from_v4mapped(sin_bc), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_from_v4mapped(sin_1), torrent::internal_error);
+}
+
+void
+test_socket_address::test_sa_to_v4mapped() {
+  TEST_DEFAULT_SA;
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(torrent::sap_to_v4mapped(sin_any), sin6_v4_any));
+  CPPUNIT_ASSERT(torrent::sap_is_v4mapped(torrent::sap_to_v4mapped(sin_any)));
+  CPPUNIT_ASSERT(torrent::sap_is_port_any(torrent::sap_to_v4mapped(sin_any)));
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(torrent::sap_to_v4mapped(sin_bc), sin6_v4_bc));
+  CPPUNIT_ASSERT(torrent::sap_is_v4mapped(torrent::sap_to_v4mapped(sin_bc)));
+  CPPUNIT_ASSERT(torrent::sap_is_port_any(torrent::sap_to_v4mapped(sin_bc)));
+
+  CPPUNIT_ASSERT(torrent::sap_equal_addr(torrent::sap_to_v4mapped(sin_1), sin6_v4_1));
+  CPPUNIT_ASSERT(torrent::sap_is_v4mapped(torrent::sap_to_v4mapped(sin_1)));
+  CPPUNIT_ASSERT(torrent::sap_is_port_any(torrent::sap_to_v4mapped(sin_1)));
+
+  CPPUNIT_ASSERT_THROW(torrent::sap_to_v4mapped(torrent::sa_make_unspec()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_to_v4mapped(torrent::sa_make_inet6()), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_to_v4mapped(torrent::sa_make_unix("")), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_to_v4mapped(sin6_any), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_to_v4mapped(sin6_1), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_to_v4mapped(sin6_v4_any), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_to_v4mapped(sin6_v4_bc), torrent::internal_error);
+  CPPUNIT_ASSERT_THROW(torrent::sap_to_v4mapped(sin6_v4_1), torrent::internal_error);
+}
diff --git a/test/torrent/net/test_socket_address.h b/test/torrent/net/test_socket_address.h
new file mode 100644
index 00000000..6157f366
--- /dev/null
+++ b/test/torrent/net/test_socket_address.h
@@ -0,0 +1,43 @@
+#include <cppunit/extensions/HelperMacros.h>
+
+class test_socket_address : public CppUnit::TestFixture {
+  CPPUNIT_TEST_SUITE(test_socket_address);
+
+  CPPUNIT_TEST(test_sa_is_any);
+  CPPUNIT_TEST(test_sa_is_broadcast);
+
+  CPPUNIT_TEST(test_make);
+
+  CPPUNIT_TEST(test_sin_from_sa);
+  CPPUNIT_TEST(test_sin6_from_sa);
+
+  CPPUNIT_TEST(test_sa_equal);
+  CPPUNIT_TEST(test_sa_equal_addr);
+  CPPUNIT_TEST(test_sa_copy);
+  CPPUNIT_TEST(test_sa_copy_addr);
+
+  CPPUNIT_TEST(test_sa_from_v4mapped);
+  CPPUNIT_TEST(test_sa_to_v4mapped);
+
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+  void setUp() {}
+  void tearDown() {}
+
+  void test_sa_is_any();
+  void test_sa_is_broadcast();
+
+  void test_make();
+
+  void test_sin_from_sa();
+  void test_sin6_from_sa();
+
+  void test_sa_equal();
+  void test_sa_equal_addr();
+  void test_sa_copy();
+  void test_sa_copy_addr();
+
+  void test_sa_from_v4mapped();
+  void test_sa_to_v4mapped();
+};
diff --git a/test/torrent/net/test_socket_address_key.cc b/test/torrent/net/test_socket_address_key.cc
deleted file mode 100644
index 7892e730..00000000
--- a/test/torrent/net/test_socket_address_key.cc
+++ /dev/null
@@ -1,87 +0,0 @@
-#include "config.h"
-
-#include lt_tr1_functional
-#include <sys/types.h>
-#include <sys/socket.h>
-
-#include "test_socket_address_key.h"
-
-#include "torrent/utils/net.h"
-#include "torrent/net/socket_address_key.h"
-
-CPPUNIT_TEST_SUITE_REGISTRATION(test_socket_address_key);
-
-// TODO: Move into a test utilities header:
-
-typedef std::function<struct addrinfo* ()> addrinfo_ftor;
-
-static torrent::socket_address_key
-test_create_valid(const char* hostname, addrinfo_ftor ftor) {
-  struct addrinfo* addr_info;
-
-  try {
-    addr_info = ftor();
-  } catch (torrent::address_info_error& e) {
-    CPPUNIT_ASSERT_MESSAGE("Caught address_info_error for '" + std::string(hostname) + "'", false);
-  }
-
-  CPPUNIT_ASSERT_MESSAGE("test_create_valid could not find '" + std::string(hostname) + "'",
-                         addr_info != NULL);
-
-  torrent::socket_address_key sock_key = torrent::socket_address_key::from_sockaddr(addr_info->ai_addr);
-
-  CPPUNIT_ASSERT_MESSAGE("test_create_valid failed to create valid socket_address_key for '" + std::string(hostname) + "'",
-                         sock_key.is_valid());
-
-  return sock_key;
-}
-
-static bool
-test_create_throws(const char* hostname, addrinfo_ftor ftor) {
-  try {
-    ftor();
-
-    return false;
-  } catch (torrent::address_info_error& e) {
-    return true;
-  }
-}
-
-static torrent::socket_address_key
-test_create_inet(const char* hostname) {
-  return test_create_valid(hostname, std::bind(&torrent::address_info_lookup, hostname, AF_INET, 0));
-}
-
-static bool
-test_create_inet_throws(const char* hostname) {
-  return test_create_throws(hostname, std::bind(&torrent::address_info_lookup, hostname, AF_INET, 0));
-}
-
-static torrent::socket_address_key
-test_create_inet6(const char* hostname) {
-  return test_create_valid(hostname, std::bind(&torrent::address_info_lookup, hostname, AF_INET6, 0));
-}
-
-static bool
-test_create_inet6_throws(const char* hostname) {
-  return test_create_throws(hostname, std::bind(&torrent::address_info_lookup, hostname, AF_INET6, 0));
-}
-
-//
-// Basic tests:
-//
-
-void
-test_socket_address_key::test_basic() {
-  CPPUNIT_ASSERT(test_create_inet("1.1.1.1").is_valid());
-  CPPUNIT_ASSERT(test_create_inet_throws("1.1.1.300"));
-
-  CPPUNIT_ASSERT(test_create_inet6("ff01::1").is_valid());
-  CPPUNIT_ASSERT(test_create_inet6("2001:0db8:85a3:0000:0000:8a2e:0370:7334").is_valid());
-  CPPUNIT_ASSERT(test_create_inet6("2001:db8:a::123").is_valid());
-
-  CPPUNIT_ASSERT(test_create_inet6_throws("2001:db8:a::22123"));
-}
-
-
-// Test lexical comparison:
diff --git a/test/torrent/object_stream_test.cc b/test/torrent/object_stream_test.cc
index c8a17049..5ad0c23e 100644
--- a/test/torrent/object_stream_test.cc
+++ b/test/torrent/object_stream_test.cc
@@ -1,10 +1,8 @@
 #include "config.h"
 
-#define __STDC_CONSTANT_MACROS
-
 #include <iostream>
 #include <sstream>
-#include <inttypes.h>
+#include <cinttypes>
 #include <torrent/object.h>
 
 #include "object_stream_test.h"
diff --git a/test/torrent/tracker_controller_features.cc b/test/torrent/tracker_controller_features.cc
index 63f163f5..0a6a57d6 100644
--- a/test/torrent/tracker_controller_features.cc
+++ b/test/torrent/tracker_controller_features.cc
@@ -1,7 +1,7 @@
 #include "config.h"
 
+#include <functional>
 #include <iostream>
-#include lt_tr1_functional
 
 #include "rak/priority_queue_default.h"
 
diff --git a/test/torrent/tracker_controller_requesting.cc b/test/torrent/tracker_controller_requesting.cc
index 5bc25169..92e664b3 100644
--- a/test/torrent/tracker_controller_requesting.cc
+++ b/test/torrent/tracker_controller_requesting.cc
@@ -1,7 +1,7 @@
 #include "config.h"
 
+#include <functional>
 #include <iostream>
-#include lt_tr1_functional
 
 #include "rak/priority_queue_default.h"
 
diff --git a/test/torrent/tracker_controller_test.cc b/test/torrent/tracker_controller_test.cc
index 823a9d34..9406c99e 100644
--- a/test/torrent/tracker_controller_test.cc
+++ b/test/torrent/tracker_controller_test.cc
@@ -1,7 +1,7 @@
 #include "config.h"
 
+#include <functional>
 #include <iostream>
-#include lt_tr1_functional
 
 #include "rak/priority_queue_default.h"
 
diff --git a/test/torrent/tracker_list_features_test.cc b/test/torrent/tracker_list_features_test.cc
index 57c05f40..5257b1a7 100644
--- a/test/torrent/tracker_list_features_test.cc
+++ b/test/torrent/tracker_list_features_test.cc
@@ -1,6 +1,6 @@
 #include "config.h"
 
-#include lt_tr1_functional
+#include <functional>
 
 #include "torrent/http.h"
 #include "net/address_list.h"
diff --git a/test/torrent/utils/directory_events_test.cc b/test/torrent/utils/directory_events_test.cc
index 2cea5ab5..b97fd1d4 100644
--- a/test/torrent/utils/directory_events_test.cc
+++ b/test/torrent/utils/directory_events_test.cc
@@ -1,6 +1,6 @@
 #include "config.h"
 
-#include <tr1/functional>
+#include <functional>
 #include <torrent/exceptions.h>
 #include <torrent/utils/directory_events.h>
 
@@ -8,8 +8,6 @@
 
 CPPUNIT_TEST_SUITE_REGISTRATION(utils_directory_events_test);
 
-namespace tr1 { using namespace std::tr1; }
-
 void
 utils_directory_events_test::setUp() {
 }
diff --git a/test/torrent/utils/log_buffer_test.h b/test/torrent/utils/log_buffer_test.h
deleted file mode 100644
index f2824594..00000000
--- a/test/torrent/utils/log_buffer_test.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#include <cppunit/extensions/HelperMacros.h>
-
-#include "torrent/utils/log_buffer.h"
-
-class utils_log_buffer_test : public CppUnit::TestFixture {
-  CPPUNIT_TEST_SUITE(utils_log_buffer_test);
-  CPPUNIT_TEST(test_basic);
-  CPPUNIT_TEST(test_timestamps);
-  CPPUNIT_TEST_SUITE_END();
-
-public:
-  void setUp();
-  void tearDown();
-
-  void test_basic();
-  void test_timestamps();
-};
diff --git a/test/torrent/utils/log_test.cc b/test/torrent/utils/log_test.cc
index 9f975636..8cc00ef8 100644
--- a/test/torrent/utils/log_test.cc
+++ b/test/torrent/utils/log_test.cc
@@ -3,8 +3,9 @@
 #include <algorithm>
 #include <cstring>
 #include <fstream>
+#include <functional>
 #include <iostream>
-#include lt_tr1_functional
+
 #include <torrent/exceptions.h>
 #include <torrent/utils/log.h>
 
@@ -37,6 +38,7 @@ void
 utils_log_test::setUp() {
   // Don't initialize since this creates the group->child connections.
   //  torrent::log_initialize();
+  torrent::log_cleanup();
 }
 
 void
diff --git a/test/torrent/utils/net_test.cc b/test/torrent/utils/net_test.cc
deleted file mode 100644
index d136e869..00000000
--- a/test/torrent/utils/net_test.cc
+++ /dev/null
@@ -1,32 +0,0 @@
-#include "config.h"
-
-#include <torrent/exceptions.h>
-#include <torrent/utils/net.h>
-
-#include "net_test.h"
-
-CPPUNIT_TEST_SUITE_REGISTRATION(utils_net_test);
-
-static void inc_value(int* value) { (*value)++; }
-
-#define LTUNIT_AI_CALL(lt_ai, lt_flags) {                               \
-  int test_value = 0;                                                   \
-  CPPUNIT_ASSERT(torrent::address_info_call(ai, 0, std::bind(&inc_value, &test_value))); \
-  CPPUNIT_ASSERT(test_value); }                                         \
-
-void
-utils_net_test::setUp() {
-}
-
-void
-utils_net_test::tearDown() {
-}
-
-void
-utils_net_test::test_basic() {
-  addrinfo* ai = torrent::address_info_lookup("localhost", AF_INET, SOCK_STREAM);
-
-  LTUNIT_AI_CALL(ai, 0);
-
-  torrent::address_info_free(ai);
-}
diff --git a/test/torrent/utils/net_test.h b/test/torrent/utils/net_test.h
deleted file mode 100644
index e538ab39..00000000
--- a/test/torrent/utils/net_test.h
+++ /dev/null
@@ -1,15 +0,0 @@
-#include <cppunit/extensions/HelperMacros.h>
-
-#include "torrent/utils/net.h"
-
-class utils_net_test : public CppUnit::TestFixture {
-  CPPUNIT_TEST_SUITE(utils_net_test);
-  CPPUNIT_TEST(test_basic);
-  CPPUNIT_TEST_SUITE_END();
-
-public:
-  void setUp();
-  void tearDown();
-
-  void test_basic();
-};
diff --git a/test/torrent/utils/option_strings_test.cc b/test/torrent/utils/option_strings_test.cc
index c6302f98..a9bdcc89 100644
--- a/test/torrent/utils/option_strings_test.cc
+++ b/test/torrent/utils/option_strings_test.cc
@@ -1,8 +1,9 @@
 #include "config.h"
 
 #include <fstream>
+#include <functional>
 #include <iostream>
-#include lt_tr1_functional
+
 #include <torrent/exceptions.h>
 #include <torrent/utils/option_strings.h>
 
diff --git a/test/torrent/utils/test_extents.cc b/test/torrent/utils/test_extents.cc
index d6b8d11d..87424d62 100644
--- a/test/torrent/utils/test_extents.cc
+++ b/test/torrent/utils/test_extents.cc
@@ -2,7 +2,7 @@
 
 #include "test_extents.h"
 
-#include <inttypes.h>
+#include <cinttypes>
 #include <iostream>
 #include <torrent/utils/extents.h>
 
diff --git a/test/torrent/utils/log_buffer_test.cc b/test/torrent/utils/test_log_buffer.cc
similarity index 86%
rename from test/torrent/utils/log_buffer_test.cc
rename to test/torrent/utils/test_log_buffer.cc
index a0ede0a0..a56a5365 100644
--- a/test/torrent/utils/log_buffer_test.cc
+++ b/test/torrent/utils/test_log_buffer.cc
@@ -1,23 +1,23 @@
 #include "config.h"
 
-#include <torrent/utils/log_buffer.h>
+#include "test_log_buffer.h"
 
 #include "globals.h"
-#include "log_buffer_test.h"
+#include <torrent/utils/log_buffer.h>
 
-CPPUNIT_TEST_SUITE_REGISTRATION(utils_log_buffer_test);
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(test_log_buffer, "torrent/utils");
 
 void
-utils_log_buffer_test::setUp() {
+test_log_buffer::setUp() {
   torrent::cachedTime = rak::timer::from_seconds(1000);
 }
 
 void
-utils_log_buffer_test::tearDown() {
+test_log_buffer::tearDown() {
 }
 
 void
-utils_log_buffer_test::test_basic() {
+test_log_buffer::test_basic() {
   torrent::log_buffer log;
 
   log.lock();
@@ -44,7 +44,7 @@ utils_log_buffer_test::test_basic() {
 }
 
 void
-utils_log_buffer_test::test_timestamps() {
+test_log_buffer::test_timestamps() {
   torrent::log_buffer log;
 
   log.lock_and_push_log("foobar", 6, 0);
diff --git a/test/torrent/utils/test_log_buffer.h b/test/torrent/utils/test_log_buffer.h
new file mode 100644
index 00000000..290df4c1
--- /dev/null
+++ b/test/torrent/utils/test_log_buffer.h
@@ -0,0 +1,17 @@
+#include "helpers/test_fixture.h"
+
+class test_log_buffer : public test_fixture {
+  CPPUNIT_TEST_SUITE(test_log_buffer);
+
+  CPPUNIT_TEST(test_basic);
+  CPPUNIT_TEST(test_timestamps);
+
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+  void setUp();
+  void tearDown();
+
+  void test_basic();
+  void test_timestamps();
+};
diff --git a/test/torrent/utils/test_uri_parser.cc b/test/torrent/utils/test_uri_parser.cc
index c3b46eef..1f4bebe8 100644
--- a/test/torrent/utils/test_uri_parser.cc
+++ b/test/torrent/utils/test_uri_parser.cc
@@ -2,7 +2,7 @@
 
 #include "test_uri_parser.h"
 
-#include <inttypes.h>
+#include <cinttypes>
 #include <iostream>
 #include <torrent/utils/uri_parser.h>
 
diff --git a/test/torrent/utils/thread_base_test.cc b/test/torrent/utils/thread_base_test.cc
index 5cb7553f..8366c9ba 100644
--- a/test/torrent/utils/thread_base_test.cc
+++ b/test/torrent/utils/thread_base_test.cc
@@ -1,7 +1,8 @@
 #include "config.h"
 
+#include <functional>
 #include <unistd.h>
-#include lt_tr1_functional
+
 #include <torrent/exceptions.h>
 #include <torrent/poll_select.h>
 #include <torrent/utils/thread_base.h>
