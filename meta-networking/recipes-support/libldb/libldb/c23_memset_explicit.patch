C23 introduced memset_explicit with the same parameters as
memset (3 args). New glibc implements it, so the symbol now
exists in the global namespace with that prototype, causing
“too many arguments” when your code passes 4 args.

Provide a compatibility macro to address the problem

Upstream-Status: Pending
Signed-off-by: Khem Raj <raj.khem@gmail.com>
--- a/lib/replace/replace.c
+++ b/lib/replace/replace.c
@@ -1,4 +1,4 @@
-/* 
+/*
    Unix SMB/CIFS implementation.
    replacement routines for broken systems
    Copyright (C) Andrew Tridgell 1992-1998
@@ -8,7 +8,7 @@
      ** NOTE! The following LGPL license applies to the replace
      ** library. This does NOT imply that all of Samba is released
      ** under the LGPL
-   
+
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
@@ -44,6 +44,18 @@
 void replace_dummy(void);
 void replace_dummy(void) {}
 
+#if defined(HAVE_MEMSET_EXPLICIT)
+#  define LDB_MEMSET_EXPLICIT(dest, destsz, ch, n) memset_explicit((dest),(ch),(n))
+#elif defined(HAVE_MEMSET_S)
+#  define LDB_MEMSET_EXPLICIT(dest, destsz, ch, n) memset_s((dest),(destsz),(ch),(n))
+#else
+#  define LDB_MEMSET_EXPLICIT(dest, destsz, ch, n) do { \
+        volatile unsigned char *p = (volatile unsigned char*)(dest); \
+        size_t _N = (n); unsigned char _CH = (unsigned char)(ch); \
+        for (size_t _i = 0; _i < _N; ++_i) p[_i] = _CH; \
+    } while (0)
+#endif
+
 #ifndef HAVE_FTRUNCATE
  /*******************************************************************
 ftruncate for operating systems that don't have it
@@ -91,7 +103,7 @@ size_t rep_strlcpy(char *d, const char *
 #endif
 
 #ifndef HAVE_STRLCAT
-/* like strncat but does not 0 fill the buffer and always null 
+/* like strncat but does not 0 fill the buffer and always null
    terminates. bufsize is the length of the buffer, which should
    be one more than the maximum resulting string length */
 size_t rep_strlcat(char *d, const char *s, size_t bufsize)
@@ -116,7 +128,7 @@ size_t rep_strlcat(char *d, const char *
 
 #ifndef HAVE_MKTIME
 /*******************************************************************
-a mktime() replacement for those who don't have it - contributed by 
+a mktime() replacement for those who don't have it - contributed by
 C.A. Lademann <cal@zls.com>
 Corrections by richard.kettlewell@kewill.com
 ********************************************************************/
@@ -137,7 +149,7 @@ time_t rep_mktime(struct tm *t)
     return((time_t)-1);
 
   n = t->tm_year + 1900 - 1;
-  epoch = (t->tm_year - 70) * YEAR + 
+  epoch = (t->tm_year - 70) * YEAR +
     ((n / 4 - n / 100 + n / 400) - (1969 / 4 - 1969 / 100 + 1969 / 400)) * DAY;
 
   y = t->tm_year + 1900;
@@ -147,7 +159,7 @@ time_t rep_mktime(struct tm *t)
     epoch += mon [m] * DAY;
     if(m == 1 && y % 4 == 0 && (y % 100 != 0 || y % 400 == 0))
       epoch += DAY;
-    
+
     if(++m > 11) {
       m = 0;
       y++;
@@ -156,7 +168,7 @@ time_t rep_mktime(struct tm *t)
 
   epoch += (t->tm_mday - 1) * DAY;
   epoch += t->tm_hour * HOUR + t->tm_min * MINUTE + t->tm_sec;
-  
+
   if((u = localtime(&epoch)) != NULL) {
     t->tm_sec = u->tm_sec;
     t->tm_min = u->tm_min;
@@ -176,7 +188,7 @@ time_t rep_mktime(struct tm *t)
 
 #ifndef HAVE_INITGROUPS
 /****************************************************************************
- some systems don't have an initgroups call 
+ some systems don't have an initgroups call
 ****************************************************************************/
 int rep_initgroups(char *name, gid_t id)
 {
@@ -194,7 +206,7 @@ int rep_initgroups(char *name, gid_t id)
 	int    i,j;
 	struct group *g;
 	char   *gr;
-	
+
 	if((grouplst = malloc(sizeof(gid_t) * max_gr)) == NULL) {
 		errno = ENOMEM;
 		return -1;
@@ -250,9 +262,9 @@ void *rep_memmove(void *dest,const void
 
 	if (d < s) {
 		/* we can forward copy */
-		if (s-d >= sizeof(int) && 
-		    !(s%sizeof(int)) && 
-		    !(d%sizeof(int)) && 
+		if (s-d >= sizeof(int) &&
+		    !(s%sizeof(int)) &&
+		    !(d%sizeof(int)) &&
 		    !(size%sizeof(int))) {
 			/* do it all as words */
 			int *idest = (int *)dest;
@@ -267,9 +279,9 @@ void *rep_memmove(void *dest,const void
 		}
 	} else {
 		/* must backward copy */
-		if (d-s >= sizeof(int) && 
-		    !(s%sizeof(int)) && 
-		    !(d%sizeof(int)) && 
+		if (d-s >= sizeof(int) &&
+		    !(s%sizeof(int)) &&
+		    !(d%sizeof(int)) &&
 		    !(size%sizeof(int))) {
 			/* do it all as words */
 			int *idest = (int *)dest;
@@ -281,7 +293,7 @@ void *rep_memmove(void *dest,const void
 			char *cdest = (char *)dest;
 			char *csrc = (char *)src;
 			for (i=size-1;i>=0;i--) cdest[i] = csrc[i];
-		}      
+		}
 	}
 	return(dest);
 }
@@ -334,16 +346,16 @@ void rep_vsyslog (int facility_priority,
  size_t rep_strnlen(const char *s, size_t max)
 {
         size_t len;
-  
+
         for (len = 0; len < max; len++) {
                 if (s[len] == '\0') {
                         break;
                 }
         }
-        return len;  
+        return len;
 }
 #endif
-  
+
 #ifndef HAVE_STRNDUP
 /**
  Some platforms don't have strndup.
@@ -351,7 +363,7 @@ void rep_vsyslog (int facility_priority,
 char *rep_strndup(const char *s, size_t n)
 {
 	char *ret;
-	
+
 	n = strnlen(s, n);
 	ret = malloc(n+1);
 	if (!ret)
@@ -407,7 +419,7 @@ int rep_chroot(const char *dname)
 
 /*****************************************************************
  Possibly replace mkstemp if it is broken.
-*****************************************************************/  
+*****************************************************************/
 
 #ifndef HAVE_SECURE_MKSTEMP
 int rep_mkstemp(char *template)
@@ -425,7 +437,7 @@ int rep_mkstemp(char *template)
 char *rep_mkdtemp(char *template)
 {
 	char *dname;
-	
+
 	if ((dname = mktemp(template))) {
 		if (mkdir(dname, 0700) >= 0) {
 			return dname;
@@ -532,7 +544,7 @@ long long int rep_strtoll(const char *st
 {
 #ifdef HAVE_STRTOQ
 	return strtoq(str, endptr, base);
-#elif defined(HAVE___STRTOLL) 
+#elif defined(HAVE___STRTOLL)
 	return __strtoll(str, endptr, base);
 #elif SIZEOF_LONG == SIZEOF_LONG_LONG
 	return (long long int) strtol(str, endptr, base);
@@ -568,7 +580,7 @@ unsigned long long int rep_strtoull(cons
 {
 #ifdef HAVE_STRTOUQ
 	return strtouq(str, endptr, base);
-#elif defined(HAVE___STRTOULL) 
+#elif defined(HAVE___STRTOULL)
 	return __strtoull(str, endptr, base);
 #elif SIZEOF_LONG == SIZEOF_LONG_LONG
 	return (unsigned long long int) strtoul(str, endptr, base);
@@ -599,7 +611,7 @@ unsigned long long int rep_strtoull(cons
 #endif /* HAVE_STRTOULL */
 
 #ifndef HAVE_SETENV
-int rep_setenv(const char *name, const char *value, int overwrite) 
+int rep_setenv(const char *name, const char *value, int overwrite)
 {
 	char *p;
 	size_t l1, l2;
@@ -644,10 +656,10 @@ int rep_unsetenv(const char *name)
 	for (i=0;environ[i];i++) /* noop */ ;
 
 	count=i;
-	
+
 	for (i=0;i<count;) {
 		if (strncmp(environ[i], name, len) == 0 && environ[i][len] == '=') {
-			/* note: we do _not_ free the old variable here. It is unsafe to 
+			/* note: we do _not_ free the old variable here. It is unsafe to
 			   do so, as the pointer may not have come from malloc */
 			memmove(&environ[i], &environ[i+1], (count-i)*sizeof(char *));
 			count--;
@@ -688,7 +700,7 @@ int rep_utimes(const char *filename, con
 #endif
 
 #ifndef HAVE_DUP2
-int rep_dup2(int oldfd, int newfd) 
+int rep_dup2(int oldfd, int newfd)
 {
 	errno = ENOSYS;
 	return -1;
@@ -970,7 +982,7 @@ int rep_memset_s(void *dest, size_t dest
 	}
 
 #if defined(HAVE_MEMSET_EXPLICIT)
-	memset_explicit(dest, destsz, ch, count);
+	LDB_MEMSET_EXPLICIT(dest, destsz, ch, count);
 #else /* HAVE_MEMSET_EXPLICIT */
 	memset(dest, ch, count);
 # if defined(HAVE_GCC_VOLATILE_MEMORY_PROTECTION)
